<?xml version="1.0" encoding="UTF-8" standalone="no"?><Entities build="b1495" majorVersion="9" minorVersion="3" modelPersistenceProviderPackage="MssqlPersistenceProviderPackage" revision="8" schemaVersion="1134" universal=""><StyleDefinitions/><Networks/><PersistenceProviderPackages/><Mashups/><ScriptFunctionLibraries/><Projects><Project artifactId="" aspect.isEditableExtensionObject="true" aspect.isExtension="true" aspect.projectType="Component" dependsOn="{&quot;extensions&quot;:&quot;&quot;,&quot;projects&quot;:&quot;PTC.OperationKPIImpl:0.0.0&quot;}" description="" documentationContent="" groupId="" homeMashup="" lastModifiedDate="2023-08-29T15:25:37.408Z" minPlatformVersion="" name="PTCDTS.OperationKPIImpl" packageVersion="1.0.0" projectName="PTCDTS.OperationKPIImpl" publishResult="" state="DRAFT" tags=""><Owner name="SuperUser" type="User"/><avatar/><DesignTimePermissions><Create/><Read/><Update/><Delete/><Metadata/></DesignTimePermissions><RunTimePermissions/><VisibilityPermissions><Visibility/></VisibilityPermissions><ConfigurationTableDefinitions/><ConfigurationTables/><ConfigurationChanges><ConfigurationChange changeAction="CREATE" changeReason="Importing Extension Package Metadata" timestamp="2023-08-29T15:25:37.408Z" user="SuperUser"/></ConfigurationChanges></Project></Projects><Users/><DirectoryServices/><Widgets/><MediaEntities/><Groups><Group aspect.isEditableExtensionObject="true" aspect.isExtension="true" description="" documentationContent="" homeMashup="" lastModifiedDate="2023-08-29T15:25:37.365Z" name="PTCDTS.OperationKPIImpl.Default_UG" projectName="PTCDTS.OperationKPIImpl" scimDisplayName="" scimExternalId="" scimId="" tags=""><Owner name="SuperUser" type="User"/><avatar/><DesignTimePermissions><Create/><Read/><Update/><Delete/><Metadata/></DesignTimePermissions><RunTimePermissions/><VisibilityPermissions><Visibility/></VisibilityPermissions><ConfigurationTableDefinitions/><ConfigurationTables/><Members><Members><Member name="PTCDTS.Base.Permissions.Default_UG" type="Group"/></Members></Members><ConfigurationChanges><ConfigurationChange changeAction="CREATE" changeReason="Importing Extension Package Metadata" timestamp="2023-08-29T15:25:37.365Z" user="SuperUser"/></ConfigurationChanges></Group><Group aspect.isEditableExtensionObject="true" aspect.isExtension="true" description="" documentationContent="" homeMashup="" lastModifiedDate="2023-08-29T15:25:37.366Z" name="PTCDTS.OperationKPIImpl.Admin_UG" projectName="PTCDTS.OperationKPIImpl" scimDisplayName="" scimExternalId="" scimId="" tags=""><Owner name="SuperUser" type="User"/><avatar/><DesignTimePermissions><Create/><Read/><Update/><Delete/><Metadata/></DesignTimePermissions><RunTimePermissions/><VisibilityPermissions><Visibility/></VisibilityPermissions><ConfigurationTableDefinitions/><ConfigurationTables/><Members><Members><Member name="PTCDTS.Base.Permissions.ApplicationAdmin_UG" type="Group"/></Members></Members><ConfigurationChanges><ConfigurationChange changeAction="CREATE" changeReason="Importing Extension Package Metadata" timestamp="2023-08-29T15:25:37.366Z" user="SuperUser"/></ConfigurationChanges></Group></Groups><PersistenceProviders/><ModelTags/><LocalizationTables/><Dashboards/><StyleThemes/><DataShapes><DataShape aspect.isEditableExtensionObject="true" aspect.isExtension="true" baseDataShape="" description="" documentationContent="" homeMashup="" lastModifiedDate="2023-08-29T15:25:37.369Z" name="PTCDTS.DisplayNonPacemakersConfiguration" projectName="PTCDTS.OperationKPIImpl" tags=""><Owner name="SuperUser" type="User"/><avatar/><DesignTimePermissions><Create/><Read/><Update/><Delete/><Metadata/></DesignTimePermissions><RunTimePermissions/><VisibilityPermissions><Visibility/></VisibilityPermissions><ConfigurationTableDefinitions/><ConfigurationTables/><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="false" baseType="BOOLEAN" description="If true, non pacemakers are displayed and accounted for in Production Dashboard screens." name="DisplayNonPacemakers" ordinal="1"/></FieldDefinitions><ConfigurationChanges><ConfigurationChange changeAction="CREATE" changeReason="Importing Extension Package Metadata" timestamp="2023-08-29T15:25:37.369Z" user="SuperUser"/></ConfigurationChanges></DataShape></DataShapes><Things><Thing aspect.isEditableExtensionObject="true" aspect.isExtension="true" aspect.isSystemObject="false" description="Impl for MMM testing" documentationContent="" effectiveThingPackage="ConfiguredThing" enabled="true" homeMashup="" identifier="" inheritedValueStream="" lastModifiedDate="2023-08-29T15:25:37.412Z" name="PTCDTS.OperationKPIImpl.EntryPoint" projectName="PTCDTS.OperationKPIImpl" published="false" tags="" thingTemplate="PTCDTS.OperationKPIImpl.EntryPoint_TT" valueStream=""><Owner name="SuperUser" type="User"/><avatar/><DesignTimePermissions><Create/><Read/><Update/><Delete/><Metadata/></DesignTimePermissions><RunTimePermissions/><VisibilityPermissions><Visibility/></VisibilityPermissions><ConfigurationTableDefinitions/><ConfigurationTables><ConfigurationTable dataShapeName="" description="Configuration table to store the components core manager" isMultiRow="true" name="ComponentManager" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="true" baseType="STRING" description="unique identifier for the manager that needs to be configured" name="id" ordinal="1"/><FieldDefinition aspect.isPrimaryKey="false" aspect.thingShape="PTC.Base.CommonManagement_TS" baseType="THINGNAME" description="Name of the Manager Thing to be configured" name="managerThingName" ordinal="2"/></FieldDefinitions></DataShape><Rows><Row><id><![CDATA[ComponentManager]]></id><managerThingName><![CDATA[PTCDTS.OperationKPIImpl.Manager]]></managerThingName></Row></Rows></ConfigurationTable></ConfigurationTables><ThingShape><PropertyDefinitions/><ServiceDefinitions/><EventDefinitions/><ServiceMappings/><ServiceImplementations/><Subscriptions/></ThingShape><PropertyBindings/><RemotePropertyBindings/><RemoteServiceBindings/><RemoteEventBindings/><AlertConfigurations/><ImplementedShapes/><ThingProperties><componentDefaultOrg><Value><![CDATA[PTCDTS.OperationKPIImpl.Default_OR]]></Value><Timestamp>2022-02-04T18:17:26.379Z</Timestamp><Quality>GOOD</Quality></componentDefaultOrg><componentDefaultUserGroup><Value><![CDATA[PTCDTS.OperationKPIImpl.Default_UG]]></Value><Timestamp>2022-02-04T18:17:26.379Z</Timestamp><Quality>GOOD</Quality></componentDefaultUserGroup><componentDeploymentState><Value><![CDATA[Configured]]></Value><Timestamp>2023-08-29T15:26:42.819Z</Timestamp><Quality>GOOD</Quality></componentDeploymentState><componentDescription><Value><![CDATA[Impl for MMM testing]]></Value><Timestamp>2022-02-04T18:17:26.379Z</Timestamp><Quality>GOOD</Quality></componentDescription><componentMainMashup><Value/><Timestamp>2022-02-16T13:03:56.111Z</Timestamp><Quality>GOOD</Quality></componentMainMashup><componentName><Value><![CDATA[PTCDTS.OperationKPIImpl]]></Value><Timestamp>2022-02-04T18:17:26.379Z</Timestamp><Quality>GOOD</Quality></componentName><componentThumbnail><Value/><Timestamp>2022-02-16T13:03:56.111Z</Timestamp><Quality>GOOD</Quality></componentThumbnail><componentType><Value><![CDATA[Implementation]]></Value><Timestamp>2022-02-04T18:17:26.379Z</Timestamp><Quality>GOOD</Quality></componentType><componentVersion><Value><![CDATA[1.2.0]]></Value><Timestamp>2022-06-15T17:20:06.376Z</Timestamp><Quality>GOOD</Quality></componentVersion><dependentComponents><Value><infoTable><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="Common name of the component" name="ComponentName" ordinal="0"/><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="Component's project name" name="ComponentProjectName" ordinal="0"/></FieldDefinitions></DataShape><Rows/></infoTable></Value><Timestamp>2022-02-16T13:03:56.110Z</Timestamp><Quality>GOOD</Quality></dependentComponents><deployComponentStatus><Value><infoTable><DataShape><FieldDefinitions><FieldDefinition aspect.defaultValue="{}" aspect.isPrimaryKey="false" baseType="JSON" description="Information about the internal status." name="additionalInfo" ordinal="0"/><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="Name of the Component" name="name" ordinal="0"/><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="config status of the component" name="status" ordinal="0"/><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="Type of action." name="type" ordinal="0"/></FieldDefinitions></DataShape><Rows/></infoTable></Value><Timestamp>2022-02-16T13:03:56.110Z</Timestamp><Quality>GOOD</Quality></deployComponentStatus><migrateComponentStatus><Value><infoTable><DataShape><FieldDefinitions><FieldDefinition aspect.defaultValue="{}" aspect.isPrimaryKey="false" baseType="JSON" description="Information about the internal status." name="additionalInfo" ordinal="0"/><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="Name of the Component" name="name" ordinal="0"/><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="config status of the component" name="status" ordinal="0"/><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="Type of action." name="type" ordinal="0"/></FieldDefinitions></DataShape><Rows/></infoTable></Value><Timestamp>2022-02-16T13:03:56.110Z</Timestamp><Quality>GOOD</Quality></migrateComponentStatus><upgradeComponentStatus><Value><infoTable><DataShape><FieldDefinitions><FieldDefinition aspect.defaultValue="{}" aspect.isPrimaryKey="false" baseType="JSON" description="Information about the internal status." name="additionalInfo" ordinal="0"/><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="Name of the Component" name="name" ordinal="0"/><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="config status of the component" name="status" ordinal="0"/><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="Type of action." name="type" ordinal="0"/></FieldDefinitions></DataShape><Rows/></infoTable></Value><Timestamp>2022-02-16T13:03:56.111Z</Timestamp><Quality>GOOD</Quality></upgradeComponentStatus><componentAbstractBlockName><Value><![CDATA[PTC.OperationKPI]]></Value><Timestamp>2022-02-16T13:15:57.528Z</Timestamp><Quality>GOOD</Quality></componentAbstractBlockName></ThingProperties><ConfigurationChanges><ConfigurationChange changeAction="CREATE" changeReason="Importing Extension Package Metadata" timestamp="2023-08-29T15:25:37.412Z" user="SuperUser"/></ConfigurationChanges></Thing><Thing aspect.isEditableExtensionObject="true" aspect.isExtension="true" description="Scheduler which runs once a minute. Will process all functions that are required to run every minute, such as updating shift information or production block properties" documentationContent="" effectiveThingPackage="SchedulerThing" enabled="true" homeMashup="" identifier="" inheritedValueStream="" lastModifiedDate="2023-08-29T15:25:37.415Z" name="PTCDTS.OperationKPI.MonitoringScheduler" projectName="PTCDTS.OperationKPIImpl" published="false" tags="" thingTemplate="Scheduler" valueStream=""><Owner name="SuperUser" type="User"/><avatar/><DesignTimePermissions><Create/><Read/><Update/><Delete/><Metadata/></DesignTimePermissions><RunTimePermissions/><VisibilityPermissions><Visibility/></VisibilityPermissions><ConfigurationTableDefinitions/><ConfigurationTables><ConfigurationTable dataShapeName="" description="Configuration table used to identify managers that the building block should use" isMultiRow="true" name="ManagerConfiguration" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="true" baseType="STRING" description="unique identifier for the manager that needs to be configured" name="id" ordinal="1"/><FieldDefinition aspect.isPrimaryKey="false" aspect.thingShape="PTC.Base.CommonManagement_TS" baseType="THINGNAME" description="Name of the Manager Thing to be configured" name="managerThingName" ordinal="2"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable><ConfigurationTable dataShapeName="" description="" isMultiRow="true" name="MashupConfiguration" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="true" baseType="STRING" description="unique identifier used to identify the thing or mashup that is being configured" name="id" ordinal="1"/><FieldDefinition aspect.isPrimaryKey="false" baseType="MASHUPNAME" description="name of the mashup to configure" name="mashupName" ordinal="2"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable><ConfigurationTable dataShapeName="" description="Configuration table for dynamic menus. Menu Items can be specified here and they will show up for the given menu name. " isMultiRow="true" name="MenuConfiguration" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="" name="menuItemMashupName" ordinal="2"/><FieldDefinition aspect.isPrimaryKey="true" baseType="STRING" description="" name="menuName" ordinal="3"/><FieldDefinition aspect.isPrimaryKey="false" baseType="INTEGER" description="An optional field to indicate the ordering of the menu items" name="menuOrderPreference" ordinal="5"/><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="Localization table key for the optional section that groups like menus together" name="menuSectionKey" ordinal="4"/><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="Localization table key for the menu label" name="menuTitleKey" ordinal="1"/><FieldDefinition aspect.dataShape="PTC.Base.ComponentMenuConfiguration" aspect.isPrimaryKey="false" baseType="INFOTABLE" description="" name="submenu" ordinal="6"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable><ConfigurationTable dataShapeName="" description="General Settings" isHidden="true" isMultiRow="false" name="Settings" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.defaultValue="true" baseType="BOOLEAN" description="Automatically enable scheduler on startup" name="enabled" ordinal="0"/><FieldDefinition baseType="USERNAME" description="User context in which to run event handlers" name="runAsUser" ordinal="0"/><FieldDefinition aspect.defaultValue="0 0/1 * * * ?" baseType="SCHEDULE" description="Execution Schedule (Cron String)" name="schedule" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><enabled>true</enabled><runAsUser><![CDATA[Administrator]]></runAsUser><schedule><![CDATA[0 0/1 * * * ?]]></schedule></Row></Rows></ConfigurationTable><ConfigurationTable dataShapeName="" description="Configuration table for any Things that need to be configured. This allows for OOTB things to be customized, and the new version that should be used can be configured here" isMultiRow="true" name="ThingConfiguration" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="true" baseType="STRING" description="unique identifier used to identify the thing or mashup that is being configured" name="id" ordinal="1"/><FieldDefinition aspect.isPrimaryKey="false" baseType="THINGNAME" description="Name of the Thing entity or Mashup entity that is to be configured" name="thingName" ordinal="2"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable></ConfigurationTables><ThingShape><PropertyDefinitions><PropertyDefinition aspect.cacheTime="0.0" aspect.dataChangeType="VALUE" aspect.defaultValue="false" baseType="BOOLEAN" category="" description="" isLocalOnly="false" name="processingLock" ordinal="2"/></PropertyDefinitions><ServiceDefinitions><ServiceDefinition aspect.isAsync="false" category="" description="Creates a new production block." isAllowOverride="true" isLocalOnly="false" isOpen="false" isPrivate="false" name="CreateProductionBlocks"><ResultType baseType="NOTHING" description="" name="result" ordinal="0"/><ParameterDefinitions/></ServiceDefinition><ServiceDefinition aspect.isAsync="false" category="" description="Gets a list of pacemakers that have expired production blocks, and sets their 'Production Block Expired' property to true. " isAllowOverride="true" isLocalOnly="false" isOpen="false" isPrivate="false" name="UpdateProductionBlockExpiredOnPacemakers"><ResultType baseType="INFOTABLE" description="" name="result" ordinal="0"/><ParameterDefinitions/></ServiceDefinition></ServiceDefinitions><EventDefinitions/><ServiceMappings/><ServiceImplementations><ServiceImplementation description="" handlerName="Script" name="CreateProductionBlocks"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[try {
	const operationKPIManagerName = me.GetConfiguredManagerForIdentifier({
		identifier: 'PTC.OperationKPI.Manager'
	});

	let operationKPIManager = Things[operationKPIManagerName];
	if (operationKPIManager) {
		let jobOrderStatus;
		let productionBlockTypeUid;
		let lastProductionBlocks = operationKPIManager.GetLatestProductionBlocks();
		// get last shifts for all pacemakers which have expired
		let currentAndPreviousShiftInstances = operationKPIManager.GetCurrentAndPreviousShiftInstances();

		let autoCreateOrEndPbs = [];
		let workcenterModelUids = [];
		currentAndPreviousShiftInstances.rows.toArray()
			.forEach(currentAndPreviousShiftInstance => {
				var autoCreateOrEndPb = autoCreateOrEndPbs[currentAndPreviousShiftInstance.modelUid];
				if (!autoCreateOrEndPb) {
				workcenterModelUids.push(currentAndPreviousShiftInstance.modelUid);
					autoCreateOrEndPb = {
						thingName: currentAndPreviousShiftInstance.thingName
					};
					autoCreateOrEndPbs[currentAndPreviousShiftInstance.modelUid] = autoCreateOrEndPb;
				}
				if (currentAndPreviousShiftInstance.isCurrentShift) {
					autoCreateOrEndPb.currentShift = currentAndPreviousShiftInstance;
				} else {
					autoCreateOrEndPb.lastExpiredShift = currentAndPreviousShiftInstance;
				}
			});

		lastProductionBlocks.rows.toArray()
			.forEach(lastProductionBlock => {
				var autoCreateOrEndPb = autoCreateOrEndPbs[lastProductionBlock.modelUid];
				if (!autoCreateOrEndPb) {
					workcenterModelUids.push(lastProductionBlock.modelUid);
					autoCreateOrEndPb = {
						thingName: lastProductionBlock.thingName
					};
					autoCreateOrEndPbs[lastProductionBlock.modelUid] = autoCreateOrEndPb;
				}
				//if (lastProductionBlock.isPacemaker) {
					autoCreateOrEndPb.lastProductionBlockForPacemaker = lastProductionBlock;
				//}

				if (!autoCreateOrEndPb.lastProductionBlock) {
					autoCreateOrEndPb.lastProductionBlock = lastProductionBlock;
				} else if (lastProductionBlock.endDateTime > autoCreateOrEndPb.lastProductionBlock.endDateTime) {
					autoCreateOrEndPb.lastProductionBlock = lastProductionBlock;
				}
			});

		workcenterModelUids.forEach(modelUid => {
			let row = autoCreateOrEndPbs[modelUid];
			let model = Things[row.thingName];
			if (model && model.IsEnabled()) {
				let lastProductionBlock;
				let lastProductionBlockForPacemaker;
				let dispatchStatus;
				if (row.lastProductionBlock) {
					lastProductionBlock = DataShapes["PTC.OperationKPI.ProductionBlock"].CreateValues();
					lastProductionBlock.AddRow({
						uid: row.lastProductionBlock.productionBlockUid,
						jobOrderUid: row.lastProductionBlock.jobOrderUid,
						startDateTime: row.lastProductionBlock.startDateTime,
						endDateTime: row.lastProductionBlock.endDateTime
					});
				}
				if (row.lastProductionBlockForPacemaker) {
					lastProductionBlockForPacemaker = DataShapes["PTC.OperationKPI.ProductionBlock"].CreateValues();
					lastProductionBlockForPacemaker.AddRow({
						uid: row.lastProductionBlockForPacemaker.productionBlockUid,
						jobOrderUid: row.lastProductionBlockForPacemaker.jobOrderUid,
						startDateTime: row.lastProductionBlockForPacemaker.startDateTime,
						endDateTime: row.lastProductionBlockForPacemaker.endDateTime
					});

                    // result: STRING
                    let workDefinitionUid = operationKPIManager.GetWorkDefinitionForModelAndJobOrder({
                        jobOrderUid: row.lastProductionBlockForPacemaker.jobOrderUid /* STRING */,
                        modelUid: row.lastProductionBlockForPacemaker.modelUid /* STRING */
                    });
                    
                    // result: INFOTABLE dataShape: "PTC.SCA.SCO.WorkDefinition"
                    dispatchStatus = operationKPIManager.GetWorkDefinition({
                        workDefinitionUid: workDefinitionUid /* STRING */
                    }).dispatchStatus;
                    
				}
				let lastExpiredShiftInstance;
				if (row.lastExpiredShift) {
					lastExpiredShiftInstance = DataShapes["PTC.Shift.ShiftInstance"].CreateValues();
					lastExpiredShiftInstance.AddRow({
						uid: row.lastExpiredShift.shiftInstanceUid,
						actualStartTime: row.lastExpiredShift.actualStartTime,
						actualEndTime: row.lastExpiredShift.actualEndTime
					});
				}
				let currentShiftInstance;
				if (row.currentShift) {
					currentShiftInstance = DataShapes["PTC.Shift.ShiftInstance"].CreateValues();
					currentShiftInstance.AddRow({
						uid: row.currentShift.shiftInstanceUid,
						actualStartTime: row.currentShift.actualStartTime,
						actualEndTime: row.currentShift.actualEndTime
					});
				}
				if (lastExpiredShiftInstance || currentShiftInstance || lastProductionBlockForPacemaker || lastProductionBlock) {
					if (!jobOrderStatus) {
						jobOrderStatus = getJobOrderStatus(operationKPIManager);
					}
					if (!productionBlockTypeUid) {
						productionBlockTypeUid = getHourByHourPBTypeUid(operationKPIManager);
					}

					model.AutoCreateOrEndPTCProductionBlock({
						lastProductionBlock: lastProductionBlock,
						lastProductionBlockForPacemaker: lastProductionBlockForPacemaker,
						lastPBJobOrderDispatchStatus: dispatchStatus,
						lastExpiredShiftInstance: lastExpiredShiftInstance,
						currentShiftInstance: currentShiftInstance,
						jobOrderStatus: jobOrderStatus,
						productionBlockTypeUid: productionBlockTypeUid
					});
				}
			}
		});
	}
} catch (err) {
	logger.error("{} - {}:{} - {}", me.name, err.fileName, err.lineNumber, err);
	throw ("An error has occurred. Please check the script logs for more details.");
}

function getJobOrderStatus(operationKPIManager) {
	return Things[operationKPIManager.GetJobOrderManager()].GetJobOrderDispatchStatuses();
}

function getHourByHourPBTypeUid(operationKPIManager) {
	let filter = {
		filters: {
			dataShapeName: "PTC.WorkMaster.ProductionBlockType",
			fieldName: "name",
			type: "EQ",
			value: "HourByHour"
		}
	};

	let hourByHour = Things[operationKPIManager.GetWorkMasterManager()].GetProductionBlockTypes({
		filter: filter,
		limit: 1
	});
	return hourByHour.uid;
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="UpdateProductionBlockExpiredOnPacemakers"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[try {
	let operationKPIManagerName = me.GetConfiguredManagerForIdentifier({
		identifier: 'PTC.OperationKPI.Manager'
	});

	let operationKPIManager = Things[operationKPIManagerName];
	if (operationKPIManager) {
		let pacemakers = operationKPIManager.GetPacemakerUnitsWithExpiredProductionBlocks();
		const DATE_FORMAT = "yyyy-MM-dd HH:mm:ss.SSSSSSS ZZ";

		pacemakers.rows.toArray().forEach(row => {
			let productionBlockEndTime = parseDate(row.enddatetime, DATE_FORMAT);
			let model = Things[row.thingName];
			if (model && model.IsEnabled() && row.jobOrderUid) {
				model.ValidatePTCProductionBlockExpired({
					productionBlockEndTime: productionBlockEndTime,
					productionBlockUid: row.productionBlockUid
				});
			}
		});
		var result = pacemakers;
	}
} catch (err) {
	logger.error("{} - {}:{} - {}", me.name, err.fileName, err.lineNumber, err);
	throw ("An error has occurred. Please check the script logs for more details.");
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation></ServiceImplementations><Subscriptions><Subscription description="Subscribes to this entities scheduled event." enabled="true" eventName="ScheduledEvent" name="SchedulerSubscription" source="" sourceProperty="" sourceType="Thing"><ServiceImplementation description="" handlerName="Script" name="SchedulerSubscription"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[//////////////////////////////
if (logger.debugEnabled) {
	logger.debug("Entering {}:MonitoringSchedulerSubscription", me.name);
}
if (!me.processingLock) {
	me.processingLock = true;
	try {
		process();
	} catch (err) {
		logger.error("Thing [{}] Service [{}] error at line [{}] : {}", me.name, err.fileName, err.lineNumber, err);
	} finally {
		me.processingLock = false;
	}
}
if (logger.debugEnabled) {
	logger.debug("Exiting {}:MonitoringSchedulerSubscription", me.name);
}

function process() {
	try {
		me.UpdateProductionBlockExpiredOnPacemakers();
	} catch (err) {
		logger.error("Thing [{}] Service [{}] error at line [{}] : {}", me.name, err.fileName, err.lineNumber, err);
	}

	try {
		me.CreateProductionBlocks();
	} catch (err) {
		logger.error("Thing [{}] Service [{}] error at line [{}] : {}", me.name, err.fileName, err.lineNumber, err);
	}
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation></Subscription></Subscriptions></ThingShape><PropertyBindings/><RemotePropertyBindings/><RemoteServiceBindings/><RemoteEventBindings/><AlertConfigurations><AlertDefinitions name="processingLock"/></AlertConfigurations><ImplementedShapes><ImplementedShape name="PTC.Base.ConfigManagement_TS" type="ThingShape"/></ImplementedShapes><ThingProperties/><ConfigurationChanges><ConfigurationChange changeAction="CREATE" changeReason="Importing Extension Package Metadata" timestamp="2023-08-29T15:25:37.415Z" user="SuperUser"/></ConfigurationChanges></Thing><Thing aspect.isEditableExtensionObject="true" aspect.isExtension="true" aspect.isSystemObject="false" description="Impl for MMM testing" documentationContent="" effectiveThingPackage="ConfiguredThing" enabled="true" homeMashup="" identifier="" inheritedValueStream="" lastModifiedDate="2023-08-29T15:25:37.411Z" name="PTCDTS.OperationKPIImpl.Manager" projectName="PTCDTS.OperationKPIImpl" published="false" tags="" thingTemplate="PTCDTS.OperationKPIImpl.Manager_TT" valueStream=""><Owner name="SuperUser" type="User"/><avatar/><DesignTimePermissions><Create/><Read/><Update/><Delete/><Metadata/></DesignTimePermissions><RunTimePermissions/><VisibilityPermissions><Visibility/></VisibilityPermissions><ConfigurationTableDefinitions/><ConfigurationTables><ConfigurationTable dataShapeName="PTC.OperationKPI.AnalysisManagementConfiguration" description="" isMultiRow="false" name="AnalysisManagement" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="true" aspect.thingShape="PTC.OperationKPI.AnalysisManagement_TS" baseType="THINGNAME" description="" name="analysisManagement" ordinal="1"/></FieldDefinitions></DataShape><Rows><Row><analysisManagement><![CDATA[PTCDTS.OperationKPIImpl.SQLThingUtility]]></analysisManagement></Row></Rows></ConfigurationTable><ConfigurationTable dataShapeName="PTCDTS.DisplayNonPacemakersConfiguration" description="" isMultiRow="false" name="DisplayNonPacemakers" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="false" baseType="BOOLEAN" description="If true, non pacemakers are displayed and accounted for in Production Dashboard screens." name="DisplayNonPacemakers" ordinal="1"/></FieldDefinitions></DataShape><Rows><Row><DisplayNonPacemakers>true</DisplayNonPacemakers></Row></Rows></ConfigurationTable><ConfigurationTable dataShapeName="" description="Configuration table used to identify managers that the building block should use" isMultiRow="true" name="ManagerConfiguration" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="true" baseType="STRING" description="unique identifier for the manager that needs to be configured" name="id" ordinal="1"/><FieldDefinition aspect.isPrimaryKey="false" aspect.thingShape="PTC.Base.CommonManagement_TS" baseType="THINGNAME" description="Name of the Manager Thing to be configured" name="managerThingName" ordinal="2"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable><ConfigurationTable dataShapeName="" description="" isMultiRow="true" name="MashupConfiguration" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="true" baseType="STRING" description="unique identifier used to identify the thing or mashup that is being configured" name="id" ordinal="1"/><FieldDefinition aspect.isPrimaryKey="false" baseType="MASHUPNAME" description="name of the mashup to configure" name="mashupName" ordinal="2"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable><ConfigurationTable dataShapeName="" description="Configuration table for dynamic menus. Menu Items can be specified here and they will show up for the given menu name. " isMultiRow="true" name="MenuConfiguration" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="" name="menuItemMashupName" ordinal="2"/><FieldDefinition aspect.isPrimaryKey="true" baseType="STRING" description="" name="menuName" ordinal="3"/><FieldDefinition aspect.isPrimaryKey="false" baseType="INTEGER" description="An optional field to indicate the ordering of the menu items" name="menuOrderPreference" ordinal="5"/><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="Localization table key for the optional section that groups like menus together" name="menuSectionKey" ordinal="4"/><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="Localization table key for the menu label" name="menuTitleKey" ordinal="1"/><FieldDefinition aspect.dataShape="PTC.Base.ComponentMenuConfiguration" aspect.isPrimaryKey="false" baseType="INFOTABLE" description="" name="submenu" ordinal="6"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable><ConfigurationTable dataShapeName="" description="Configuration table for any Things that need to be configured. This allows for OOTB things to be customized, and the new version that should be used can be configured here" isMultiRow="true" name="ThingConfiguration" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="true" baseType="STRING" description="unique identifier used to identify the thing or mashup that is being configured" name="id" ordinal="1"/><FieldDefinition aspect.isPrimaryKey="false" baseType="THINGNAME" description="Name of the Thing entity or Mashup entity that is to be configured" name="thingName" ordinal="2"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable></ConfigurationTables><ThingShape><PropertyDefinitions/><ServiceDefinitions/><EventDefinitions/><ServiceMappings/><ServiceImplementations/><Subscriptions/></ThingShape><PropertyBindings/><RemotePropertyBindings/><RemoteServiceBindings/><RemoteEventBindings/><AlertConfigurations/><ImplementedShapes/><ThingProperties/><ConfigurationChanges><ConfigurationChange changeAction="CREATE" changeReason="Importing Extension Package Metadata" timestamp="2023-08-29T15:25:37.411Z" user="SuperUser"/></ConfigurationChanges></Thing><Thing aspect.isEditableExtensionObject="true" aspect.isExtension="true" description="" documentationContent="" effectiveThingPackage="SQLThingPackage" enabled="true" homeMashup="" identifier="" inheritedValueStream="" lastModifiedDate="2023-08-29T15:25:37.414Z" name="PTCDTS.OperationKPIImpl.SQLThingUtility" projectName="PTCDTS.OperationKPIImpl" published="false" tags="PTC:ThingTemplate" thingTemplate="PTCDTS.OperationKPIImpl.SQLThingUtility_TT" valueStream=""><Owner name="SuperUser" type="User"/><avatar/><DesignTimePermissions><Create/><Read/><Update/><Delete/><Metadata/></DesignTimePermissions><RunTimePermissions/><VisibilityPermissions><Visibility/></VisibilityPermissions><ConfigurationTableDefinitions/><ConfigurationTables><ConfigurationTable dataShapeName="" description="Connection Monitoring Settings" isMultiRow="false" name="ConnectionMonitoring" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.defaultValue="30000.0" aspect.friendlyName="Monitor Rate (milliseconds)" baseType="NUMBER" description="Monitor rate in milliseconds" name="connectionMonitorRate" ordinal="1"/><FieldDefinition aspect.defaultValue="false" aspect.friendlyName="Enable Monitoring" baseType="BOOLEAN" description="Enable connection monitoring" name="enableMonitor" ordinal="0"/><FieldDefinition aspect.defaultValue="1.0" aspect.friendlyName="Number of Retries" baseType="NUMBER" description="Number of retries" name="numberOfRetries" ordinal="2"/><FieldDefinition aspect.defaultValue="2000.0" aspect.friendlyName="Retry Delay (milliseconds)" baseType="NUMBER" description="Retry delay in milliseconds" name="retryDelay" ordinal="3"/></FieldDefinitions></DataShape><Rows><Row><connectionMonitorRate>30000.0</connectionMonitorRate><enableMonitor>false</enableMonitor><numberOfRetries>1.0</numberOfRetries><retryDelay>2000.0</retryDelay></Row></Rows></ConfigurationTable><ConfigurationTable dataShapeName="" description="Connection Provider" isMultiRow="false" name="ConnectionProvider" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.defaultValue="false" aspect.friendlyName="Participate in platform transactions" baseType="BOOLEAN" description="Participate in platform transactions" name="isTransactional" ordinal="0"/><FieldDefinition aspect.defaultValue="ThingworxPersistenceProvider" aspect.friendlyName="Persistence Provider Name" baseType="PERSISTENCEPROVIDERNAME" description="The Persistence Provider from which to retrieve connections" name="persistenceProviderName" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><isTransactional>false</isTransactional><persistenceProviderName><![CDATA[PTC.DBConnection.JdbcPersistenceProvider]]></persistenceProviderName></Row></Rows></ConfigurationTable><ConfigurationTable dataShapeName="" description="Field/Column Name Aliases" isMultiRow="true" name="ColumnAliases" ordinal="1"><DataShape><FieldDefinitions><FieldDefinition aspect.friendlyName="Database Column Name" baseType="STRING" description="Database column name" name="columnName" ordinal="0"/><FieldDefinition aspect.friendlyName="Thingworx Field Name" baseType="STRING" description="Thingworx field name" name="fieldName" ordinal="1"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable></ConfigurationTables><ThingShape><PropertyDefinitions/><ServiceDefinitions/><EventDefinitions/><ServiceMappings/><ServiceImplementations/><Subscriptions/></ThingShape><PropertyBindings/><RemotePropertyBindings/><RemoteServiceBindings/><RemoteEventBindings/><AlertConfigurations/><ImplementedShapes/><ThingProperties><minEventAgeInDays><Value>14</Value><Timestamp>1970-01-01T00:00:00.000Z</Timestamp><Quality>UNKNOWN</Quality></minEventAgeInDays></ThingProperties><ConfigurationChanges><ConfigurationChange changeAction="CREATE" changeReason="Importing Extension Package Metadata" timestamp="2023-08-29T15:25:37.414Z" user="SuperUser"/></ConfigurationChanges></Thing></Things><Logs/><Authenticators/><ThingPackages/><NotificationDefinitions/><ApplicationKeys/><StateDefinitions/><ThingTemplates><ThingTemplate aspect.isEditableExtensionObject="true" aspect.isExtension="true" baseThingTemplate="PTCDTS.OperationKPIImpl.DefaultWorkUnit_TT" description="" documentationContent="" effectiveThingPackage="RemoteThingWithTunnelsAndFileTransfer" homeMashup="" inheritedValueStream="" lastModifiedDate="2023-08-29T15:25:37.389Z" name="PTCDTS.OperationKPIImpl.AutomationEventsWorkUnit_TT" projectName="PTCDTS.OperationKPIImpl" tags="" thingPackage="" valueStream="PTC.OperationKPI.Automation_VS"><Owner name="SuperUser" type="User"/><avatar/><DesignTimePermissions><Create/><Read/><Update/><Delete/><Metadata/></DesignTimePermissions><RunTimePermissions/><VisibilityPermissions><Visibility/></VisibilityPermissions><ConfigurationTableDefinitions/><ConfigurationTables><ConfigurationTable dataShapeName="" description="Configuration table used to identify managers that the building block should use" isMultiRow="true" name="ManagerConfiguration" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="true" baseType="STRING" description="unique identifier for the manager that needs to be configured" name="id" ordinal="1"/><FieldDefinition aspect.isPrimaryKey="false" aspect.thingShape="PTC.Base.CommonManagement_TS" baseType="THINGNAME" description="Name of the Manager Thing to be configured" name="managerThingName" ordinal="2"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable><ConfigurationTable dataShapeName="" description="" isMultiRow="true" name="MashupConfiguration" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="true" baseType="STRING" description="unique identifier used to identify the thing or mashup that is being configured" name="id" ordinal="1"/><FieldDefinition aspect.isPrimaryKey="false" baseType="MASHUPNAME" description="name of the mashup to configure" name="mashupName" ordinal="2"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable><ConfigurationTable dataShapeName="" description="Configuration table for dynamic menus. Menu Items can be specified here and they will show up for the given menu name. " isMultiRow="true" name="MenuConfiguration" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="" name="menuItemMashupName" ordinal="2"/><FieldDefinition aspect.isPrimaryKey="true" baseType="STRING" description="" name="menuName" ordinal="3"/><FieldDefinition aspect.isPrimaryKey="false" baseType="INTEGER" description="An optional field to indicate the ordering of the menu items" name="menuOrderPreference" ordinal="5"/><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="Localization table key for the optional section that groups like menus together" name="menuSectionKey" ordinal="4"/><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="Localization table key for the menu label" name="menuTitleKey" ordinal="1"/><FieldDefinition aspect.dataShape="PTC.Base.ComponentMenuConfiguration" aspect.isPrimaryKey="false" baseType="INFOTABLE" description="" name="submenu" ordinal="6"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable><ConfigurationTable dataShapeName="" description="Reporting Settings" isMultiRow="false" name="ReportingConfiguration" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.defaultValue="NotReporting" aspect.isPrimaryKey="true" aspect.isReadOnly="false" aspect.thingTemplate="ReportingStrategy" baseType="THINGNAME" description="Strategy to determine health" name="reportingStrategy" ordinal="1"/></FieldDefinitions></DataShape><Rows><Row><reportingStrategy><![CDATA[AlwaysOnReporting]]></reportingStrategy></Row></Rows></ConfigurationTable><ConfigurationTable dataShapeName="" description="Configuration table for any Things that need to be configured. This allows for OOTB things to be customized, and the new version that should be used can be configured here" isMultiRow="true" name="ThingConfiguration" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="true" baseType="STRING" description="unique identifier used to identify the thing or mashup that is being configured" name="id" ordinal="1"/><FieldDefinition aspect.isPrimaryKey="false" baseType="THINGNAME" description="Name of the Thing entity or Mashup entity that is to be configured" name="thingName" ordinal="2"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable><ConfigurationTable dataShapeName="" description="General Settings" isMultiRow="false" name="TunnelSettings" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.friendlyName="Enable Tunneling" aspect.isNullable="true" baseType="BOOLEAN" description="Enable tunneling" name="enableTunneling" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row/></Rows></ConfigurationTable><ConfigurationTable dataShapeName="" description="Tunneling Destinations" isMultiRow="true" name="Tunnels" ordinal="1"><DataShape><FieldDefinitions><FieldDefinition aspect.defaultValue="" aspect.friendlyName="Application Path" baseType="STRING" description="Location of the client app that will use this tunnel" name="appUri" ordinal="5"/><FieldDefinition aspect.defaultValue="" aspect.friendlyName="Description" baseType="STRING" description="A description of the tunnel" name="description" ordinal="3"/><FieldDefinition aspect.defaultValue="127.0.0.1" aspect.friendlyName="Host" baseType="STRING" description="Host or IP that this tunnel will connect to at the edge" name="host" ordinal="1"/><FieldDefinition aspect.defaultValue="vnc" aspect.friendlyName="Name" baseType="STRING" description="Name of the tunnel" name="name" ordinal="0"/><FieldDefinition aspect.defaultValue="1.0" aspect.friendlyName="Number of Connects" baseType="NUMBER" description="The number of connections required to establish this tunnel" name="numConnects" ordinal="4"/><FieldDefinition aspect.defaultValue="5900.0" aspect.friendlyName="Port" baseType="NUMBER" description="Port that this tunnel will connect to at the edge" name="port" ordinal="2"/><FieldDefinition aspect.defaultValue="tcp" aspect.friendlyName="Protocol" baseType="STRING" description="The protocol used over this tunnel" name="proto" ordinal="6"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable></ConfigurationTables><PropertyBindings/><RemotePropertyBindings/><RemoteServiceBindings/><RemoteEventBindings/><AlertConfigurations/><ThingShape><PropertyDefinitions/><ServiceDefinitions/><EventDefinitions/><ServiceMappings/><ServiceImplementations><ServiceImplementation description="" handlerName="Script" name="AddPTCAutomationEvents"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[try {
	var prodCount = 0;
	if (events && events.productionEvents && events.productionEvents.getRowCount() > 0) {
		prodCount = events.productionEvents.getRowCount();
		me.AddPTCProductionEvent({
			productionEvents: events.productionEvents
		});
	}

	var scrapCount = 0;
	if (events && events.scrapEvents && events.scrapEvents.getRowCount() > 0) {
		scrapCount = events.scrapEvents.getRowCount();    
        //reallocateFromGoodCount doesn't exist on db,so removing it.
		events.scrapEvents.RemoveField('reallocateFromGoodCount');
		me.AddPTCProductionEvent({
			productionEvents: events.scrapEvents
		});
	}

	var availCount = 0;
	if (events && events.availabilityEvents && events.availabilityEvents.getRowCount() > 0) {
		availCount = events.availabilityEvents.getRowCount();
        
        // Remove any manual events that were added in this timeframe
        let sort = {
            name: "eventTime",
            ascending: true
        };
        events.availabilityEvents.Sort(sort);

        Things["PTCDTS.ManualAvailabilityEvents.ProductionDashboardImpl.Manager"].OverrideEventsInTimeRange({
            EndTime: undefined /* DATETIME */,
            StartTime: events.availabilityEvents.eventTime /* DATETIME */,
            thingName: me.name /* THINGNAME */
        });
        
		me.AddPTCAvailabilityEvent({
			availabilityEvents: events.availabilityEvents
		});
	}
	logger.error("[{}] rows inserted into db - prodcount [{}] scrapEvents [{}] availabilityEvents [{}]", me.name, prodCount, scrapCount, availCount);
} catch (err) {
	logger.error("Thing [{}] Service [{}] error at line [{}] : {}", me.name, err.fileName, err.lineNumber, err);
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="IsPTCLatestJobOrderProcessedAfterEventTimestamp"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[let wderManager = Things[me.GetConfiguredManagerForIdentifier({
	identifier: "PTC.WorkDefinitionExecutionResponse.Manager" /* STRING */
})];

// result: INFOTABLE dataShape: "PTCDTS.WorkDefinitionExecutionResponse"
let latestWorkDefinitionExecutionResponseForCurrentJobOrder = wderManager.GetLatestWorkDefinitionExecutionResponseForModel({
	modelUid: me.GetPTCModelUid() /* STRING */
});

result = false;
if (latestWorkDefinitionExecutionResponseForCurrentJobOrder.timestamp) {
	result = latestWorkDefinitionExecutionResponseForCurrentJobOrder.timestamp > eventTimestamp;
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="PopulatePTCAutomationJobOrderUids"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[// result: THINGNAME
let wderManager = Things[me.GetConfiguredManagerForIdentifier({
	identifier: "PTC.WorkDefinitionExecutionResponse.Manager" /* STRING */
})];

try {
	result = populateJobOrderUids(aggregatedEvents);
} catch (err) {
	logger.error("Thing [{}] Service [{}] error at line [{}] : {}", me.name, err.fileName, err.lineNumber, err);
    throw err;
}

function populateJobOrderUids(aggregatedEvents) {
	let startDate = aggregatedEvents.getFirstRow().timestamp;
	let endDate = new Date(aggregatedEvents.getLastRow().timestamp.getTime() + 1);
	let jobOrderPeriods = getRunningJobOrderPeriods(me.GetPTCModelUid(), startDate, endDate);
    
	aggregatedEvents.rows.toArray().forEach(row => {
		let timestamp = row.timestamp;
		for (let j = 0; j < jobOrderPeriods.length; j++) {
			let joPeriod = jobOrderPeriods[j];
			if (timestamp >= joPeriod.startTime && timestamp < joPeriod.endTime) {
				row.PTCJobOrderUid = joPeriod.jobOrderUid;
				break;
			}
		}
	});
	return aggregatedEvents;
}

function getRunningJobOrderPeriods(modelUid, startTime, endTime) {
	let periods = Things[me.GetPTCOperationExecutionManager()].GetRunningJobOrderPeriods({
		startTime: startTime,
		endTime: endTime,
		modelUid: modelUid
	});
    
    //MMM - Sort job orders by descending start times so that it finds the latest job order that is running instead of the first
    periods = Resources["InfoTableFunctions"].Sort({
        sortColumn: "startTime" /* STRING */,
        t: periods /* INFOTABLE */,
        ascending: false /* BOOLEAN {"defaultValue":true} */
    });   
    //MMM - Because multiple job orders can happen at once for a work center, need to find the exact one for the work unit
    let result = [];
    periods.rows.toArray().forEach(jobOrderPeriod => {
        //For each job order period, determine if modeluid has running wder record 
        let runningWDER = wderManager.GetRunningWorkDefinitionExecutionResponsesForWorkUnit({
            startTime: jobOrderPeriod.startTime /* DATETIME */,
            endTime: jobOrderPeriod.endTime /* DATETIME */,
            modeluid: modelUid /* STRING */
        });
        if(runningWDER && runningWDER.rows && runningWDER.rows.length > 0 && runningWDER.joborderuid == jobOrderPeriod.jobOrderUid){
            //running work definition for model found in job order period. Add to result
            let entry = {
                    startTime: jobOrderPeriod.startTime,
                    endTime: jobOrderPeriod.endTime,
                    jobOrderUid: jobOrderPeriod.jobOrderUid
                };
            result.push(entry);
        }
    });
	return result;
//	return periods.rows.toArray().map(row => {
//		return {
//			startTime: row.startTime,
//			endTime: row.endTime,
//			jobOrderUid: row.jobOrderUid
//		};
//	});
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="PopulatePTCEventRelatedData"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[// Customizable managers
let jobOrderManager;
let reasonCodeManager;

// Event DataShapes
const PRODUCTION_EVENT_DS = "PTC.OperationKPI.ProductionEvent";
const AVAIL_EVENT_DS = "PTC.OperationKPI.AvailabilityEvent";
const EVENTS_DS = "PTC.OperationKPI.AutomationEvents_DS";
let defaultReasonTypeForScrap;

let cachedJobOrderData = [];
let cachedReasonCodesForNonProductionEvents = [];
let cachedReasonCodesForProductionEvent;
let cachedUnknownAvailEvent;
let cachedInvalidEvent; //used for invalid scrap machine codes
let cachedRunningAvailEvent;
let siteUid;
try {
	jobOrderManager = me.GetPTCJobOrderManager();
	reasonCodeManager = me.GetPTCReasonCodeManager();
	// Get the event related data

	var result = getEventData(cachedJobOrderData, incomingEvents);

} catch (err) {
	logger.error("Thing [{}] Service [{}] error at line [{}] : {}", me.name, err.fileName, err.lineNumber, err);
    throw err;
}
/*
 * Function used to process the incoming event related info to lookup and build out the 3 different types of events with all
 * of the expected, related data.
 * An InfoTable is returned, containing 3 nested InfoTables of event information. Organized in tables, per event type.
 */
function getEventData(cachedJobOrderData, incomingEvents) {
	// 3 types of events being looked up
	let availabilityEvents;
	let productionEvents;
	let scrapEvents;

	let site = me.GetPTCSiteFromModel();
	if (site && site.rows && site.rows.length) {
		siteUid = site.uid;
	}
	incomingEvents.rows.toArray().forEach(function(incomingEvent) {
		let eventType = incomingEvent.eventType;
		// Query or search the cached data for the corresponding event information
		let row = getEventDataRow(cachedJobOrderData, incomingEvent, eventType);
		// Add that row to the corresponding event type InfoTable, used in the final result set
		if (row) {
			switch (eventType) {
				case "Scrap":
					scrapEvents = initEventsInfoTable(scrapEvents, eventType);
					row.reallocateFromGoodCount = incomingEvent.reallocateFromGoodCount;
					scrapEvents.AddRow(row);
					break;
				case "Availability":
					availabilityEvents = initEventsInfoTable(availabilityEvents, eventType);
					availabilityEvents.AddRow(row);
					break;
				case "Production":
					productionEvents = initEventsInfoTable(productionEvents, eventType);
					productionEvents.AddRow(row);
					break;
			}
		}
	});

	// Create the outer InfoTable that will be returned, containing the 3 event type InfoTables
	let events = DataShapes[EVENTS_DS].CreateValuesWithData({
		values: {
			productionEvents: productionEvents,
			scrapEvents: scrapEvents,
			availabilityEvents: availabilityEvents
		}
	});
	return events;
}

/*
 * Returns an InfoTable with an applied DataShape based on the event type provided
 */
function initEventsInfoTable(events, eventType) {
	if (!events) {
		if (eventType === "Availability") {
			events = DataShapes[AVAIL_EVENT_DS].CreateValues();
		} else if (eventType === "Scrap" || eventType === "Production") {
			events = DataShapes[PRODUCTION_EVENT_DS].CreateValues();
			if (eventType == "Scrap") {
				defaultReasonTypeForScrap = getDefaultReasonTypeForScrap();
				//dynamic field
				let reallocateFromGoodCount = {
					name: 'reallocateFromGoodCount',
					baseType: 'BOOLEAN'
				};
				events.AddField(reallocateFromGoodCount);
			}
		}
	}
	return events;
}

/*
 * Function that determines whether to source the event data from cache, or go out and query for the data upon
 * a new jobOrderUid or machine code being referenced in the incoming event.
 */
function getEventDataRow(cachedJobOrderData, event) {
	const jobOrderUid = event.jobOrderUid;
	const count = event.count;
	const timeStamp = event.timestamp;
	const eventType = event.eventType;

	// Try to get previously cached data, or a new query will be required to get the associated data
	let reasonCodes = getReasonCodes(event.code, eventType); //get from cache or query reason codes
	let cachedEvent = getCachedJobOrder(cachedJobOrderData, jobOrderUid);

	let eventDataRow;
	// If there was cached event data for the job order UID, use it
	// else, no job order information was cached, we have to query
	if (cachedEvent) {
		// Modify properties that may not be same for the given jobOrder and return modifed row
		if (eventType != "Availability") cachedEvent.quantity = count;
		cachedEvent.eventTime = timeStamp;
		cachedEvent.shiftInstanceUid = event.shiftInstanceUid;
		if (reasonCodes) {
			cachedEvent.reasonCategoryUid = parseInt(reasonCodes.reasonCategoryUid);
			if (reasonCodes.reasonTreeNodeUid) {
				cachedEvent.reasonTreeNodeUid = parseInt(reasonCodes.reasonTreeNodeUid);
			}
			cachedEvent.reasonTypeUid = parseInt(reasonCodes.reasonTypeUid);
			if (eventType == "Production") {
				//OOTB notes depends on machinecode Value, there is no machinecodeValue for Production type
				cachedEvent.machineCodeUid = cachedEvent.notes = undefined;
			} else {
				cachedEvent.machineCodeUid = reasonCodes.machineCodeUid;
				cachedEvent.notes = reasonCodes.notes;
			}
		} else {
			//case where reasoncodes are undefined because codeValue is not provided (even for Scrap or Availability event type)
			cachedEvent.reasonTypeUid = eventType == "Scrap" ? defaultReasonTypeForScrap : undefined;
			cachedEvent.reasonCategoryUid = cachedEvent.reasonTreeNodeUid = cachedEvent.notes = cachedEvent.machineCodeUid = undefined;
		}
		eventDataRow = cachedEvent;
	} else {
		eventDataRow = getEventRow(event, jobOrderUid, reasonCodes);
		// Cache the queried for result
		cachedJobOrderData.push({
			jobOrderUid: jobOrderUid,
			eventData: eventDataRow
		});
	}
	//copy reason type and category to event type and category
	eventDataRow.eventTypeUid = eventDataRow.reasonTypeUid;
	eventDataRow.eventCategoryUid = eventDataRow.reasonCategoryUid;
	return eventDataRow;
}

/*
 * Helper to build the final row for the returned data, per event passed in.
 * Sourced from 3 different places: incoming event, query on job order UID, and a query on machine code
 */
function getEventRow(event, jobOrderUid, reasonCodes) {
	const modelUid = me.GetPTCModelUid();

	let row = {
		isAutomation: true,
		modelUid: modelUid,
		reasonModelUid: modelUid,
		eventTime: event.timestamp,
		siteUid: siteUid,
		quantity: event.count,
		shiftInstanceUid: event.shiftInstanceUid,
		jobOrderUid: event.jobOrderUid,
		workCenterUid: me.GetPTCWorkCenterUid()
	};

	let jobOrderExecutionData;
	if (jobOrderUid) {
		// Query from database
		jobOrderExecutionData = Things[jobOrderManager].GetJobOrderExecutionData({
			jobOrderUid: jobOrderUid
		});

		if (jobOrderExecutionData && jobOrderExecutionData.rows && jobOrderExecutionData.rows.length) {
            /*************************************************************
            * MMM Change to find workunit's ideal cycle time
            **************************************************************/
            jobOrderExecutionData = jobOrderExecutionData.Find({
                modelUid: me.GetPTCModelUid()
            });
			row.idealCycleTime = jobOrderExecutionData.idealCycleTime ? jobOrderExecutionData.idealCycleTime : 0;
			row.materialMasterUid = jobOrderExecutionData.materialMasterUid;
		}
	}
	if (reasonCodes) {
		row.reasonCategoryUid = reasonCodes.reasonCategoryUid;
		row.reasonTreeNodeUid = reasonCodes.reasonTreeNodeUid;
		row.reasonTypeUid = reasonCodes.reasonTypeUid;
		row.machineCodeUid = reasonCodes.machineCodeUid;
		row.notes = reasonCodes.notes;
	}
	return row;
}

/*
 * Helper to determine how to source the missing Reason Code event data; query or cached
 */
function getReasonCodes(codeVal, eventType) {
	if (eventType == "Production" && !codeVal) {
		if (cachedReasonCodesForProductionEvent) {
			//return cached result for the production event
			return cachedReasonCodesForProductionEvent;
		}
		// if not cached, query database to get reasoncodes
		cachedReasonCodesForProductionEvent = getReasonCodesForProductionEvent();
		return cachedReasonCodesForProductionEvent;
	}

	// return cached /queried reasoncodes for scrap event or any event where codeValue is present
	let reasonInfoArr = cachedReasonCodesForNonProductionEvents.filter(cachedReasonCodes => cachedReasonCodes.codeValue === codeVal);
	if (reasonInfoArr.length == 1) {
		return reasonInfoArr[0];
	} else if (codeVal != undefined) {
		// Query for the associated Reason information if we haven't looked it up already
		let reasonInfo = Things[reasonCodeManager].GetMachineCodes({
			filter: reasonInfoByMachineCodeFilter(codeVal, me.PTCModelUid)
		});
		if (reasonInfo.rows && reasonInfo.rows.length) {
			let reasoncodes = {
				reasonCategoryUid: reasonInfo.reasonCategoryUid,
				reasonTreeNodeUid: reasonInfo.reasonTreeNodeUid,
				reasonTypeUid: reasonInfo.reasonCategoryReasonTypeUid,
				codeValue: codeVal,
				machineCodeUid: reasonInfo.machineCodeUid,
				notes: me.GetPTCNotes({
					machineCodeValue: codeVal,
					eventType: eventType
				})
			};
			cachedReasonCodesForNonProductionEvents.push(reasoncodes);
			return reasoncodes;
		} else if (eventType == "Scrap") {
			// No MachineCode entry found for that codeValue -- use the default Invalud Event'
			if (!cachedInvalidEvent) {
				cachedInvalidEvent = getInvalidReasonCategory();
			}
			let reasoncodes = {
				reasonCategoryUid: parseInt(cachedInvalidEvent.uid),
				reasonTypeUid: parseInt(cachedInvalidEvent.reasonTypeUid),
				codeValue: codeVal,
				notes: me.GetPTCNotes({
					machineCodeValue: codeVal,
					eventType: eventType
				})
			};
			cachedReasonCodesForNonProductionEvents.push(reasoncodes);
			return reasoncodes;
		} else if (eventType == "Availability") {
			// No MachineCode entry found for that codeValue -- use the default Availability Event 'Unknown Fault'
			if (!cachedUnknownAvailEvent) {
				cachedUnknownAvailEvent = me.GetPTCUnknownFaultCodeReasonTree().rows[0];
			}
			let reasoncodes = {
				reasonCategoryUid: parseInt(cachedUnknownAvailEvent.reasonCategoryUid),
				reasonTreeNodeUid: parseInt(cachedUnknownAvailEvent.uid),
				reasonTypeUid: parseInt(cachedUnknownAvailEvent.reasonCategoryReasonTypeUid),
				codeValue: codeVal,
				machineCodeUid: undefined,
				notes: me.GetPTCNotes({
					machineCodeValue: codeVal,
					eventType: eventType
				})
			};
			cachedReasonCodesForNonProductionEvents.push(reasoncodes);
			return reasoncodes;
		}
	} else {
		logger.error("[{}] No code value to look up for related Reason Information", me.name);
	}
}

/*
 * Filter the cache of job order UID data to return previously looked up data, based on the given jobOrderUid
 */
function getCachedJobOrder(cachedJobOrderData, jobOrderUid) {
	if (jobOrderUid && cachedJobOrderData.length) {
		let filteredJobOrderData = cachedJobOrderData.filter(event => event.jobOrderUid === jobOrderUid);
		if (filteredJobOrderData && filteredJobOrderData.length && filteredJobOrderData[0].eventData) {
			return JSON.parse(JSON.stringify(filteredJobOrderData[0].eventData)); // returning cloned object
		}
	}
}

/*
 * Explicit lookup for the "Production" event type reason code data. Need to lookup Reason data by reason type; ie. Production
 */
function getReasonCodesForProductionEvent() {
	let productionReasonType = DataShapes["PTC.ReasonCode.ReasonType"].CreateValuesWithData({
		values: {
			name: "Production"
		}
	});
	let productionReasonCategory = Things[reasonCodeManager].GetReasonCategoriesByReasonTypes({
		reasonTypes: productionReasonType
	});
	return {
		reasonCategoryUid: productionReasonCategory.uid,
		reasonTreeNodeUid: 0, //similar to manual event
		reasonTypeUid: productionReasonCategory.reasonTypeUid,
	};
}
/*
 * gets default reasontype for scrap event.useful when eventType is scrap and codeValue is unknown.
 */
function getDefaultReasonTypeForScrap() {
	return Things[reasonCodeManager].GetReasonTypes({
		filter: {
			"filters": {
				"fieldName": "name",
				"value": "Scrap",
				"type": "EQ"
			}
		},
	}).uid;
}

function getInvalidReasonCategory() {
	return Things[reasonCodeManager].GetInvalidReasonCategory();
}

function reasonInfoByMachineCodeFilter(code, modelUid) {
	return {
		"select": [{
			"dataShapeName": "PTC.ReasonCode.ReasonCategory",
			"fieldName": "uid",
			"as": "reasonCategoryUid"
		}, {
			"dataShapeName": "PTC.ReasonCode.ReasonTreeNode",
			"fieldName": "uid",
			"as": "reasonTreeNodeUid"
		}, {
			"dataShapeName": "PTC.ReasonCode.ReasonCategory",
			"fieldName": "reasonTypeUid",
			"as": "reasonCategoryReasonTypeUid"
		}, {
			"dataShapeName": "PTC.ReasonCode.MachineCode",
			"fieldName": "uid",
			"as": "machineCodeUid"
		}],
		"filters": {
			"type": "AND",
			"filters": [{
				"dataShapeName": "PTC.ReasonCode.MachineCode",
				"fieldName": "codeValue",
				"type": "EQ",
				"value": code
			}, {
				"dataShapeName": "PTC.ReasonCode.MachineCode",
				"fieldName": "modelUid",
				"type": "EQ",
				"value": modelUid
			}]
		},
		"joins": [{
				"type": "LEFT",
				"sourceDataShapeName": "PTC.ReasonCode.MachineCode",
				"sourceFieldName": "reasonTreeNodeUid",
				"targetDataShapeName": "PTC.ReasonCode.ReasonTreeNode",
				"targetFieldName": "uid"
			},
			{
				"type": "LEFT",
				"sourceDataShapeName": "PTC.ReasonCode.ReasonTreeNode",
				"sourceFieldName": "reasonTreeUid",
				"targetDataShapeName": "PTC.ReasonCode.ReasonTree",
				"targetFieldName": "uid"
			},
			{
				"type": "LEFT",
				"sourceDataShapeName": "PTC.ReasonCode.ReasonTree",
				"sourceFieldName": "reasonCategoryUid",
				"targetDataShapeName": "PTC.ReasonCode.ReasonCategory",
				"targetFieldName": "uid"
			}
		]
	};
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="ProcessPTCAutomationEventsAsync"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[//MMM - Workaround to remove automation timer subscription. Work Centers now subscribe to the automation timer and call child automation workunits synchronously.
//me.ProcessPTCAutomationEvents();]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="ProcessPTCMaterialMasterIDEvent"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[let materialMasterManager;
let jobOrderManager;
let DEFAULT_QUANTITY = me.PTCAutomationDefaultTargetQuantity;
let result = DataShapes["PTC.OperationKPI.AutomationJobOrderEventResult"].CreateValues();
try {
	materialMasterManager = me.GetPTCMaterialMasterManager();
    jobOrderManager = me.GetPTCJobOrderManager();
    let runningJobOrderUid = me.GetPTCRunningJobOrders({
		dateTime: new Date()
	}).jobOrderUid;
    let STOP_JOB_ORDER = me.GetPTCMaterialMasterIDNullValue();
    let canProcess = !me.IsPTCLatestJobOrderProcessedAfterEventTimestamp({
		eventTimestamp: eventTimestamp
	});
	if (canProcess) {
		if (materialMasterID == STOP_JOB_ORDER) {
			result = stopCurrentRunningJobOrder(runningJobOrderUid, eventTimestamp, STOP_JOB_ORDER);
		} else {
			result = createJobOrder(materialMasterID, DEFAULT_QUANTITY, parseInt(runningJobOrderUid), eventTimestamp);
			if (!result.jobOrderStarted) {
				logger.error("[{}] Error creating Job order for MaterialMasterID [{}] and target quantity [{}] [{}]", me.name, materialMasterID, DEFAULT_QUANTITY, eventTimestamp.toString());
			}
		}
	} else {
		if (materialMasterID == STOP_JOB_ORDER) {
			logger.error("[{}] Unable to stop job order because its timestamp is older than the most recent job order [{}]", me.name, eventTimestamp.toString());
			addAutomationMessage(eventTimestamp, [], "PTC.OperationKPI.Automation.JobOrderOlderWithStopJobOrder");
		} else {
			logger.error("[{}] Unable to create Job Order with MaterialMasterID [{}] and TargetQuantity [{}] because its timestamp is older than the most recent job order [{}]", me.name, materialMasterID, DEFAULT_QUANTITY, eventTimestamp.toString());
			addAutomationMessage(eventTimestamp, [materialMasterID, DEFAULT_QUANTITY], "PTC.OperationKPI.Automation.OlderJobOrderWithMaterialMasterAndTargetQuantity");
		}
	}
} catch (err) {
	logger.error("Thing [{}] Service [{}] error at line [{}] : {}", me.name, err.fileName, err.lineNumber, err);
    throw err;
}


function stopCurrentRunningJobOrder(runningJobOrderUid, timestamp, STOP_JOB_ORDER) {
	let automationJobOrders = DataShapes["PTC.OperationKPI.AutomationJobOrderEventResult"].CreateValues();
	let stoppedJobOrder;
	if (runningJobOrderUid) {
        stoppedJobOrder = me.StopPTCProductionWithForceOption({
            dispatchStatusUid: getCompletedDispatchStatusUid() /* STRING [Required] */,
            timestamp: timestamp /* DATETIME */,
            forceJobOrderStop: true /* BOOLEAN */
        });
		if (!stoppedJobOrder) {
			stoppedJobOrder = Things[jobOrderManager].GetJobOrder({
				uid: runningJobOrderUid
			});
			logger.error("[{}] Error while stopping job order {}", me.name, stoppedJobOrder.id);
			addAutomationMessage(timestamp, [stoppedJobOrder.id], "PTC.OperationKPI.Automation.ErrorStoppingJobOrder");
		}
	} else {
		logger.error("[{}] Material Master ID [{}] to stop joborder received,Can not stop job order because no job order is running.", me.name, STOP_JOB_ORDER);
		addAutomationMessage(timestamp, [STOP_JOB_ORDER], "PTC.OperationKPI.Automation.NoRunningJobOrderToStop");
	}
	automationJobOrders.AddRow({
		jobOrderStopped: stoppedJobOrder,
		eventTimestamp: eventTimestamp
	});
	return automationJobOrders;
}

function createJobOrder(materialMasterID, targetQuantity, lastJobOrderUid, timestamp) {
	let automationJobOrders = DataShapes["PTC.OperationKPI.AutomationJobOrderEventResult"].CreateValues();
	let stoppedJobOrder, jobOrderStarted;
	if (lastJobOrderUid) {
		stoppedJobOrder = stopProduction(lastJobOrderUid, timestamp);
	}

	let materialMasterUid = getMaterialMasterById(materialMasterID);
	if (materialMasterUid) {
		jobOrderStarted = me.StartPTCProduction({
			quantity: targetQuantity,
			materialMasterUid: materialMasterUid,
			timestamp: timestamp
		});
	} else {
		logger.error("[{}] Material Master is not found for MaterialMasterID {}", me.name, materialMasterID);
		addAutomationMessage(timestamp, [materialMasterID], "PTC.OperationKPI.Automation.InvalidMaterialMasterID");
	}
	automationJobOrders.AddRow({
		jobOrderStopped: stoppedJobOrder,
		jobOrderStarted: jobOrderStarted,
		eventTimestamp: eventTimestamp
	});
	return automationJobOrders;
}

function stopProduction(jobOrderUid, timestamp) {
	try {
		if (jobOrderUid) {
			logger.debug("[{}] stopping job order for joborder uid " + jobOrderUid, me.name);
            return me.StopPTCProductionWithForceOption({
                dispatchStatusUid: getCompletedDispatchStatusUid() /* STRING [Required] */,
                timestamp: timestamp /* DATETIME */,
                forceJobOrderStop: true /* BOOLEAN */
            });
		}
	} catch (err) {
		let stoppedJobOrder = Things[jobOrderManager].GetJobOrder({
			uid: jobOrderUid
		});
		logger.error("[{}] Error while stopping job order {}", me.name, stoppedJobOrder.id);
		addAutomationMessage(timestamp, [jobOrderUid], "PTC.OperationKPI.Automation.ErrorStoppingJobOrder");

		logger.error("Thing [{}] Service [{}] error at line [{}] : {}", me.name, err.fileName, err.lineNumber, err);
		throw err;
	}
}


function getMaterialMasterById(id) {
	if (!id) {
		return null;
	}
	let materialMasterUid = null;
	let materialMaster = getMaterialMaster(id);

	if (materialMaster) {
		materialMasterUid = materialMaster.uid;
	}
	return materialMasterUid;
}


function getMaterialMaster(id) {
	if (!id)
		return null;

	let filter = {
		filters: {
			"dataShapeName": "PTC.MaterialMaster.MaterialMaster",
			"fieldName": "id",
			"type": "EQ",
			"value": id
		}
	};

	let materialMaster = Things[materialMasterManager].GetMaterialMasters({
		filter: filter,
		limit: 1
	});

	if (materialMaster.rows && materialMaster.rows.length) {
		return materialMaster;
	} else {
		logger.error("[{}] invalid Material Master " + id, me.name);
		return null;
	}
}

function getCompletedDispatchStatusUid() {
	let statuses = getAllDispatchStatuses();
	completedStatusUid = statuses.Find({
		statusName: 'Completed'
	}).uid;
	return completedStatusUid;
}

function getAllDispatchStatuses() {
	var allJobOrderDispatchStatuses = Things[jobOrderManager].GetJobOrderDispatchStatuses();
	return allJobOrderDispatchStatuses;
}

function addAutomationMessage(eventTimestamp, valueList, token) {
	let autMessage = {
		name: token,
		values: []
	};
	valueList.forEach(value => autMessage.values.push({
		value: value
	}));
	me.AddPTCAutomationMessage({
		eventTimestamp: eventTimestamp,
		jsonMessage: autMessage
	});
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation></ServiceImplementations><Subscriptions/></ThingShape><ImplementedShapes><ImplementedShape name="IndustrialThingShape" type="ThingShape"/><ImplementedShape name="PTC.OperationKPI.AutomationEventsModelLogic_TS" type="ThingShape"/></ImplementedShapes><SharedConfigurationTables><ConfigurationTable dataShapeName="" description="Shared Remote Tunneling Settings" isMultiRow="false" name="SharedTunnelSettings" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.defaultValue="false" aspect.friendlyName="Enable Tunneling" baseType="BOOLEAN" description="Enable tunneling" name="enableTunneling" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><enableTunneling>false</enableTunneling></Row></Rows></ConfigurationTable><ConfigurationTable dataShapeName="" description="Shared Tunneling Destinations" isMultiRow="true" name="SharedTunnels" ordinal="1"><DataShape><FieldDefinitions><FieldDefinition aspect.friendlyName="Application Path" baseType="STRING" description="Location of the client app that will use this tunnel" name="appUri" ordinal="5"/><FieldDefinition aspect.friendlyName="Description" baseType="STRING" description="A description of the tunnel" name="description" ordinal="3"/><FieldDefinition aspect.friendlyName="Host" baseType="STRING" description="Host or IP that this tunnel will connect to at the edge" name="host" ordinal="1"/><FieldDefinition aspect.friendlyName="Name" baseType="STRING" description="Name of the tunnel" name="name" ordinal="0"/><FieldDefinition aspect.friendlyName="Number of Connects" baseType="NUMBER" description="The number of connections required to establish this tunnel" name="numConnects" ordinal="4"/><FieldDefinition aspect.friendlyName="Port" baseType="NUMBER" description="Port that this tunnel will connect to at the edge" name="port" ordinal="2"/><FieldDefinition aspect.friendlyName="Protocol" baseType="STRING" description="The protocol used over this tunnel" name="proto" ordinal="6"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable></SharedConfigurationTables><InstanceDesignTimePermissions><Create/><Read/><Update/><Delete/><Metadata/></InstanceDesignTimePermissions><InstanceRunTimePermissions/><InstanceVisibilityPermissions><Visibility/></InstanceVisibilityPermissions><ConfigurationChanges><ConfigurationChange changeAction="CREATE" changeReason="Importing Extension Package Metadata" timestamp="2023-08-29T15:25:37.389Z" user="SuperUser"/></ConfigurationChanges></ThingTemplate><ThingTemplate aspect.isEditableExtensionObject="true" aspect.isExtension="true" baseThingTemplate="PTC.OperationKPIImpl.SQLThingUtility_TT" description="" documentationContent="" effectiveThingPackage="SQLThingPackage" homeMashup="" inheritedValueStream="" lastModifiedDate="2023-08-29T15:25:37.396Z" name="PTCDTS.OperationKPIImpl.SQLThingUtility_TT" projectName="PTCDTS.OperationKPIImpl" tags="PTC:ThingTemplate" thingPackage="" valueStream=""><Owner name="SuperUser" type="User"/><avatar/><DesignTimePermissions><Create/><Read/><Update/><Delete/><Metadata/></DesignTimePermissions><RunTimePermissions/><VisibilityPermissions><Visibility/></VisibilityPermissions><ConfigurationTableDefinitions/><ConfigurationTables><ConfigurationTable dataShapeName="" description="Connection Monitoring Settings" isMultiRow="false" name="ConnectionMonitoring" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.defaultValue="30000.0" aspect.friendlyName="Monitor Rate (milliseconds)" baseType="NUMBER" description="Monitor rate in milliseconds" name="connectionMonitorRate" ordinal="1"/><FieldDefinition aspect.defaultValue="false" aspect.friendlyName="Enable Monitoring" baseType="BOOLEAN" description="Enable connection monitoring" name="enableMonitor" ordinal="0"/><FieldDefinition aspect.defaultValue="1.0" aspect.friendlyName="Number of Retries" baseType="NUMBER" description="Number of retries" name="numberOfRetries" ordinal="2"/><FieldDefinition aspect.defaultValue="2000.0" aspect.friendlyName="Retry Delay (milliseconds)" baseType="NUMBER" description="Retry delay in milliseconds" name="retryDelay" ordinal="3"/></FieldDefinitions></DataShape><Rows><Row><connectionMonitorRate>30000.0</connectionMonitorRate><enableMonitor>false</enableMonitor><numberOfRetries>1.0</numberOfRetries><retryDelay>2000.0</retryDelay></Row></Rows></ConfigurationTable><ConfigurationTable dataShapeName="" description="Connection Provider" isMultiRow="false" name="ConnectionProvider" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.defaultValue="false" aspect.friendlyName="Participate in platform transactions" baseType="BOOLEAN" description="Participate in platform transactions" name="isTransactional" ordinal="0"/><FieldDefinition aspect.defaultValue="ThingworxPersistenceProvider" aspect.friendlyName="Persistence Provider Name" baseType="PERSISTENCEPROVIDERNAME" description="The Persistence Provider from which to retrieve connections" name="persistenceProviderName" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><isTransactional>false</isTransactional><persistenceProviderName><![CDATA[PTC.DBConnection.JdbcPersistenceProvider]]></persistenceProviderName></Row></Rows></ConfigurationTable><ConfigurationTable dataShapeName="" description="Field/Column Name Aliases" isMultiRow="true" name="ColumnAliases" ordinal="1"><DataShape><FieldDefinitions><FieldDefinition aspect.friendlyName="Database Column Name" baseType="STRING" description="Database column name" name="columnName" ordinal="0"/><FieldDefinition aspect.friendlyName="Thingworx Field Name" baseType="STRING" description="Thingworx field name" name="fieldName" ordinal="1"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable></ConfigurationTables><PropertyBindings/><RemotePropertyBindings/><RemoteServiceBindings/><RemoteEventBindings/><AlertConfigurations/><ThingShape><PropertyDefinitions/><ServiceDefinitions><ServiceDefinition aspect.isAsync="false" category="" description="Calls the GetEventDurations DB function to retrieve the total event durations." isAllowOverride="true" isLocalOnly="false" isOpen="false" isPrivate="false" name="CallGetEventDurationsForWorkUnit"><ResultType baseType="INFOTABLE" description="" name="result" ordinal="0"/><ParameterDefinitions><FieldDefinition baseType="DATETIME" description="End datetime range" name="endDateTime" ordinal="2"/><FieldDefinition baseType="STRING" description="Unique Identifier of the Material Master" name="materialMasterUid" ordinal="6"/><FieldDefinition aspect.defaultValue="14" baseType="INTEGER" description="Maximum age for an availability event to calculate its duration" name="minEventAgeInDays" ordinal="7"/><FieldDefinition aspect.isRequired="true" baseType="STRING" description="Unique Identifier for the model" name="modelUid" ordinal="4"/><FieldDefinition baseType="STRING" description="Unique Identifier of the Shift Instance" name="shiftInstanceUid" ordinal="5"/><FieldDefinition baseType="DATETIME" description="Start datetime range" name="startDateTime" ordinal="1"/></ParameterDefinitions></ServiceDefinition><ServiceDefinition aspect.isAsync="false" category="" description="" isAllowOverride="false" isLocalOnly="false" isOpen="false" isPrivate="false" name="CallGetTargetQuantityMultiplier"><ResultType baseType="INFOTABLE" description="" name="result" ordinal="0"/><ParameterDefinitions><FieldDefinition baseType="STRING" description="" name="jobOrderUid" ordinal="1"/><FieldDefinition baseType="STRING" description="" name="modelUid" ordinal="2"/></ParameterDefinitions></ServiceDefinition><ServiceDefinition aspect.isAsync="false" category="" description="" isAllowOverride="false" isLocalOnly="false" isOpen="false" isPrivate="false" name="CreateGetParallelPacemakerDivisor"><ResultType baseType="NUMBER" description="" name="result" ordinal="0"/><ParameterDefinitions/></ServiceDefinition><ServiceDefinition aspect.isAsync="false" category="" description="" isAllowOverride="false" isLocalOnly="false" isOpen="false" isPrivate="false" name="CreateGetTargetQuantityMultiplier"><ResultType baseType="NUMBER" description="" name="result" ordinal="0"/><ParameterDefinitions/></ServiceDefinition><ServiceDefinition aspect.isAsync="false" category="" description="" isAllowOverride="false" isLocalOnly="false" isOpen="false" isPrivate="false" name="GetTargetQuantityMultiplier"><ResultType baseType="NOTHING" description="" name="result" ordinal="0"/><ParameterDefinitions><FieldDefinition baseType="STRING" description="" name="jobOrderUid" ordinal="1"/><FieldDefinition baseType="STRING" description="" name="modelUid" ordinal="2"/></ParameterDefinitions></ServiceDefinition></ServiceDefinitions><EventDefinitions/><ServiceMappings/><ServiceImplementations><ServiceImplementation description="" handlerName="SQLQuery" name="CallGetEventDurations"><ConfigurationTables><ConfigurationTable dataShapeName="" description="SQLQuery" isMultiRow="false" name="Query" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="NUMBER" description="maxItems" name="maxItems" ordinal="0"/><FieldDefinition baseType="STRING" description="sql" name="sql" ordinal="0"/><FieldDefinition baseType="NUMBER" description="timeout" name="timeout" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><maxItems>0.0</maxItems><sql><![CDATA[DECLARE @equipmentinfo equipmentinfotype
INSERT INTO @equipmentinfo(equipmentuid)
SELECT childuid
FROM GetTreeModels([[modelUid]], 1)

DECLARE @timeperiods timeperiodtype
INSERT INTO @timeperiods(id, starttime, endtime)
VALUES (1, [[startDateTime]], [[endDateTime]])

EXEC GetEventDurations @timeperiods, @equipmentinfo, [[shiftInstanceUid]], [[materialMasterUid]], [[minEventAgeInDays]]]]></sql></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="SQLQuery" name="CallGetEventDurationsForWorkUnit"><ConfigurationTables><ConfigurationTable dataShapeName="" description="SQLQuery" isMultiRow="false" name="Query" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="NUMBER" description="maxItems" name="maxItems" ordinal="0"/><FieldDefinition baseType="STRING" description="sql" name="sql" ordinal="0"/><FieldDefinition baseType="NUMBER" description="timeout" name="timeout" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><maxItems>0.0</maxItems><sql><![CDATA[DECLARE @equipmentinfo equipmentinfotype
INSERT INTO @equipmentinfo(equipmentuid)
SELECT childuid
FROM GetTreeModels([[modelUid]], 0)

DECLARE @timeperiods timeperiodtype
INSERT INTO @timeperiods(id, starttime, endtime)
VALUES (1, [[startDateTime]], [[endDateTime]])

EXEC GetEventDurations @timeperiods, @equipmentinfo, [[shiftInstanceUid]], [[materialMasterUid]], [[minEventAgeInDays]]]]></sql></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="SQLQuery" name="CallGetNextLevelPareto"><ConfigurationTables><ConfigurationTable dataShapeName="" description="SQLQuery" isMultiRow="false" name="Query" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="NUMBER" description="maxItems" name="maxItems" ordinal="0"/><FieldDefinition baseType="STRING" description="sql" name="sql" ordinal="0"/><FieldDefinition baseType="NUMBER" description="timeout" name="timeout" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><maxItems>0.0</maxItems><sql><![CDATA[DECLARE @equipmentinfo equipmentinfotype
INSERT INTO @equipmentinfo(equipmentuid)
SELECT childuid
FROM GetTreeModels([[modelUid]], 1)

EXEC GetNextLevelPareto [[startDateTime]], [[endDateTime]], @equipmentinfo, [[eventCategoryUid]], [[reasonCategoryUid]], [[reasonTreeNodeId]],[[shiftInstanceUid]],[[materialMasterUid]], [[reasonModelUid]]]]></sql></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="SQLQuery" name="CallGetTargetQuantityMultiplier"><ConfigurationTables><ConfigurationTable dataShapeName="" description="SQLQuery" isMultiRow="false" name="Query" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="NUMBER" description="maxItems" name="maxItems" ordinal="0"/><FieldDefinition baseType="STRING" description="sql" name="sql" ordinal="0"/><FieldDefinition baseType="NUMBER" description="timeout" name="timeout" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><maxItems>500.0</maxItems><sql><![CDATA[EXEC GetTargetQuantityMultiplier [[modelUid]],[[jobOrderUid]]]]></sql><timeout>60.0</timeout></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="SQLQuery" name="CallGetUnplannedProductionDuration"><ConfigurationTables><ConfigurationTable dataShapeName="" description="SQLQuery" isMultiRow="false" name="Query" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="NUMBER" description="maxItems" name="maxItems" ordinal="0"/><FieldDefinition baseType="STRING" description="sql" name="sql" ordinal="0"/><FieldDefinition baseType="NUMBER" description="timeout" name="timeout" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><sql><![CDATA[DECLARE @modeluids uidlist;
INSERT INTO @modeluids(uid)
    SELECT value
    FROM STRING_SPLIT([[modelUid]], ',');

DECLARE @flag BIT 
SELECT @flag = CASE WHEN 6 NOT IN (SELECT m.modeltypeuid FROM @modeluids ids JOIN model m ON m.uid = ids.uid) THEN 1 ELSE 0 END

DECLARE @parent_children uidmap;
INSERT INTO @parent_children(touid, fromuid)
    SELECT treemodels.childuid, models.uid
    FROM @modeluids models
    CROSS APPLY GetTreeModels(models.uid, @flag) treemodels
    WHERE treemodels.childtype = 'Workunit';

-- DECLARE @parent_children uidmap;
-- INSERT INTO @parent_children(touid, fromuid)
--     SELECT treemodels.childuid, uid
--     FROM @modeluids
--     CROSS APPLY GetTreeModels(uid, 0) treemodels
--     WHERE treemodels.childtype = 'WorkCenter';
-- 
-- INSERT INTO @parent_children(touid, fromuid)
--     SELECT parentuid, childuid 
--     FROM modellink ml
--     INNER JOIN model m ON ml.childuid = m.uid
--     INNER JOIN modeltype mt ON m.modeltypeuid = mt.uid
--     WHERE mt.name = 'Workunit' AND m.uid IN (SELECT uid FROM @modeluids)

DECLARE @timeperiods timeperiodtype
INSERT INTO @timeperiods(id, starttime, endtime)
VALUES (1, [[startDateTime]],[[endDateTime]])

EXEC GetTotalUnplannedProductionDuration @parent_children, @timeperiods, 14]]></sql></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="CreateDBFunctions"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[//execution of those services need to respect that order for dependecy and avoid failing
let services = [
	"CreateGetRunningJobOrderPeriods",
	"CreateGetLossValue",
	"CreateGetProductionQuantity",
	"CreateGetAvailabilityEventDuration",
	"CreateGetEventDurations",
	"CreateGetProductionBlockInfo",
	"CreateGetPacemakerModelsForExpiredProductionBlock",
	"CreateGetLastExpiredModelShiftInstances",
	"CreateGetParallelPacemakerDivisor",
    "CreateGetTargetQuantityMultiplier",
    "CreateGetTrend2",
    "CreateGetRunningJobOrdersForModel",
    "CreateGetNextLevelPareto",
    "CreateGetUnRunningJobOrderPeriods",
    "CreateGetCurrentAndPreviousShiftInstances",
    "CreateGetProductionEventDurations",
    "CreateGetJobOrderSummary"
];

services.forEach(service => {
	try {
		me[service]();
	} catch (err) {
		logger.error("Thing [{}] Service [{}] error at line [{}] : {}", me.name, err.fileName, err.lineNumber, err);
		logger.error("Error running service : [{}]", service);
	}
});]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="SQLCommand" name="CreateGetAvailabilityEventDuration"><ConfigurationTables><ConfigurationTable dataShapeName="" description="SQLCommand" isMultiRow="false" name="Query" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="NUMBER" description="maxItems" name="maxItems" ordinal="0"/><FieldDefinition baseType="STRING" description="sql" name="sql" ordinal="0"/><FieldDefinition baseType="NUMBER" description="timeout" name="timeout" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><maxItems>500.0</maxItems><sql><![CDATA[CREATE OR ALTER PROCEDURE GetAvailabilityEventDuration(
    @equipmentinfo AS equipmentinfotype READONLY,
    @minEventAgeInDays INT = 14,
    @timeperiods AS timeperiodtype READONLY,
    @shiftinstanceuid BIGINT = NULL,
    @materialmasteruid BIGINT = NULL
)
AS

DECLARE @lastAggregatedAvailabilityEventHour DATETIMEOFFSET;
SELECT @lastAggregatedAvailabilityEventHour = DATEADD(HOUR, 1, MAX(eventdatetime)) FROM aggregatedavailabilityevent

DECLARE @lastAggregatedAvailabilityEventHours timeperiodtype;
INSERT INTO @lastAggregatedAvailabilityEventHours(id, starttime, endtime)
    SELECT
        tp.id,
        IIF(@lastAggregatedAvailabilityEventHour IS NULL OR tp.starttime > @lastAggregatedAvailabilityEventHour, tp.starttime, @lastAggregatedAvailabilityEventHour),
        tp.endtime
    FROM
        @timeperiods AS tp;

DECLARE	@lastAggregatedDays timeperiodtype
INSERT @lastAggregatedDays
    SELECT id, starttime, endtime
    FROM @lastAggregatedAvailabilityEventHours

DECLARE @starttime DATETIMEOFFSET, @endtime DATETIMEOFFSET
SELECT @starttime = MIN(starttime), @endtime = MAX(endtime)
FROM @lastAggregatedDays

DECLARE @deadzoneevents TABLE(
    modeluid BIGINT,
    eventtypeuid BIGINT,
    eventcategoryuid BIGINT,
    reasontypeuid BIGINT,
    reasoncategoryuid BIGINT,
    reasontreenodeuid BIGINT,
    reasonmodeluid BIGINT,
    materialmasteruid BIGINT,
    shiftinstanceuid BIGINT,
    eventtime DATETIMEOFFSET,
    zoneid BIGINT,
	joborderuid BIGINT
)
INSERT @deadzoneevents
    SELECT
        modeluid,
        eventtypeuid,
        eventcategoryuid,
        reasontypeuid,
        reasoncategoryuid,
        reasontreenodeuid,
        reasonmodeluid,
        materialmasteruid,
        shiftinstanceuid,
        eventtime,
        zoneid,
		joborderuid
    FROM
        GetDeadZoneEvents(@starttime, @endtime, @equipmentinfo, @minEventAgeInDays)

DROP TABLE IF EXISTS #events
CREATE TABLE #events(
    modeluid BIGINT,
    eventtypeuid BIGINT,
    eventcategoryuid BIGINT,
    timeperiodid BIGINT,
    duration INT,
    unknowntime INT,
	joborderuid BIGINT
)

INSERT #events
    SELECT
        modeluid,
        eventtypeuid,
        eventcategoryuid,
        lads.id AS timeperiodid,
        SUM(DATEDIFF(SECOND, IIF(B.eventtime < lads.starttime, lads.starttime, B.eventtime), B.endtime)) AS timediff,
        SUM(IIF(preveventtime IS NULL, DATEDIFF(SECOND, lads.starttime, IIF(B.eventtime < lads.starttime, lads.starttime, B.eventtime)), 0)) AS unknowntime,
		joborderuid
    FROM (
        SELECT
            A.modeluid,
            A.eventtypeuid,
            A.eventcategoryuid,
            A.materialmasteruid,
            A.shiftinstanceuid,
            A.eventtime,
            LEAD(A.eventtime, 1, @endtime) OVER (PARTITION BY A.modeluid ORDER BY A.eventtime ASC) AS endtime,
            LAG(A.eventtime, 1) OVER (PARTITION BY A.modeluid ORDER BY A.eventtime ASC) AS preveventtime,
			joborderuid
        FROM (
            SELECT
                ae.modeluid,
                ae.eventtypeuid,
                ae.eventcategoryuid,
                ae.materialmasteruid,
                ae.shiftinstanceuid,
                ae.eventtime AS eventtime,
				ae.joborderuid
            FROM
                availabilityevent ae
                JOIN @equipmentinfo ei ON ae.modeluid = ei.equipmentuid
            WHERE
                eventtime >= DATEADD(DAY, -@minEventAgeInDays, @starttime) AND
                eventtime < @endtime

                UNION ALL

            SELECT
                modeluid,
                eventtypeuid,
                eventcategoryuid,
                materialmasteruid,
                shiftinstanceuid,
                eventtime,
				joborderuid
            FROM @deadzoneevents
            
            ) A
        ) B
        JOIN @lastAggregatedDays AS lads ON B.eventtime < lads.endtime AND B.endtime > lads.starttime
    WHERE eventcategoryuid != -1 AND
    ((@shiftinstanceuid IS NOT NULL AND shiftinstanceuid = @shiftinstanceuid) OR (@shiftinstanceuid IS NULL)) AND
    ((@materialmasteruid IS NOT NULL AND materialmasteruid = @materialmasteruid) OR (@materialmasteruid IS NULL))
    AND NOT EXISTS (
        SELECT 1
        FROM @deadzoneevents dze
        GROUP BY dze.modeluid, dze.zoneid
        HAVING
            B.modeluid = dze.modeluid AND
            B.eventtime >= MIN(dze.eventtime) AND
            B.eventtime < MAX(dze.eventtime)
    )
    GROUP BY
        modeluid,
        lads.id,
        eventtypeuid,
        eventcategoryuid,
		joborderuid

INSERT #events(
    modeluid,
    eventtypeuid,
    eventcategoryuid,
    timeperiodid,
    duration,
    unknowntime,
	joborderuid
)
    SELECT
        ae.modeluid AS modeluid,
        ae.eventtypeuid,
        ae.eventcategoryuid,
        tp.id AS timeperiodid,
        SUM(duration) AS duration,
        0 AS unknowntime,
		ae.joborderuid
    FROM
        aggregatedavailabilityevent ae
        INNER JOIN @equipmentinfo eq ON ae.modeluid = eq.equipmentuid
        INNER JOIN @timeperiods tp ON (ae.eventdatetime >= FORMAT(tp.starttime, 'yyyy-MM-dd HH:00:00') AND ae.eventdatetime < FORMAT(tp.endtime, 'yyyy-MM-dd HH:00:00'))
    WHERE
        ((@shiftinstanceuid IS NOT NULL AND ae.shiftinstanceuid = @shiftinstanceuid) OR (@shiftinstanceuid IS NULL)) AND
        ((@materialmasteruid IS NOT NULL AND ae.materialmasteruid = @materialmasteruid) OR (@materialmasteruid IS NULL))
    GROUP BY
        ae.modeluid,
        tp.id,
        eventtypeuid,
        eventcategoryuid,
		ae.joborderuid

SELECT
    modeluid AS equipmentuid,
    timeperiodid,
    eventtypeuid,
    eventcategoryuid,
    SUM(duration) AS duration,
    SUM(unknowntime) AS unknowntime,
	joborderuid
FROM
    #events
GROUP BY
    modeluid,
    timeperiodid,
    eventtypeuid,
    eventcategoryuid,
    joborderuid
ORDER BY
    modeluid,
    timeperiodid]]></sql><timeout>60.0</timeout></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="SQLCommand" name="CreateGetCurrentAndPreviousShiftInstances"><ConfigurationTables><ConfigurationTable dataShapeName="" description="SQLCommand" isMultiRow="false" name="Query" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="NUMBER" description="maxItems" name="maxItems" ordinal="0"/><FieldDefinition baseType="STRING" description="sql" name="sql" ordinal="0"/><FieldDefinition baseType="NUMBER" description="timeout" name="timeout" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><maxItems>500.0</maxItems><sql><![CDATA[CREATE OR ALTER FUNCTION GetCurrentAndPreviousShiftInstances()
RETURNS TABLE
AS RETURN

SELECT
    currentShiftInstance.modeluid AS modelUid,
    currentShiftInstance.workcentermodeluid AS workcenterModelUid,
    currentShiftInstance.uid AS shiftInstanceUid,
    CAST (currentShiftInstance.actualstarttime AS DATETIME2) AS actualStartTime,
    CAST (currentShiftInstance.actualendtime AS DATETIME2) AS actualEndTime,
    currentShiftInstance.thingname AS thingName,
	cast(1 AS Bit) As isCurrentShift
FROM (
    SELECT
        pacemaker.uid AS modeluid,
        si.modeluid AS workcentermodeluid,
        si.uid,
        si.actualstarttime,
        si.actualendtime,
        pacemaker.thingname AS thingname,
        ROW_NUMBER() OVER (PARTITION BY si.modeluid ORDER BY si.actualendtime ASC) AS rn
    FROM
        shiftinstance si
        INNER JOIN model ON model.uid = si.modeluid
        INNER JOIN modeltype ON modeltype.uid = model.modeltypeuid
        INNER JOIN modellink wcl on wcl.parentuid = model.uid
        INNER JOIN model as pacemaker ON pacemaker.uid = wcl.childuid
    WHERE
		actualendtime > SYSUTCDATETIME() AND
        SYSUTCDATETIME() > actualstarttime AND
        modeltype.name = 'Workcenter'
) AS currentShiftInstance
 UNION ALL
  SELECT
    lastExpiredShiftInstance.modeluid AS modelUid,
    lastExpiredShiftInstance.workcentermodeluid AS workcenterModelUid,
    lastExpiredShiftInstance.uid AS shiftInstanceUid,
    CAST (lastExpiredShiftInstance.actualstarttime AS DATETIME2) AS actualStartTime,
    CAST (lastExpiredShiftInstance.actualendtime AS DATETIME2) AS actualEndTime,
    lastExpiredShiftInstance.thingname AS thingName,
	cast(0 AS Bit) As isCurrentShift
FROM (
    SELECT
        pacemaker.uid AS modeluid,
        si.modeluid AS workcentermodeluid,
        si.uid,
        si.actualstarttime,
        si.actualendtime,
        pacemaker.thingname AS thingname,
        ROW_NUMBER() OVER (PARTITION BY si.modeluid ORDER BY si.actualendtime DESC) AS rn
    FROM
        shiftinstance si
        INNER JOIN model ON model.uid = si.modeluid
        INNER JOIN modeltype ON modeltype.uid = model.modeltypeuid
        INNER JOIN modellink wcl on wcl.parentuid = model.uid
        INNER JOIN model as pacemaker ON pacemaker.uid = wcl.childuid
    WHERE
		actualendtime < SYSUTCDATETIME() AND
        modeltype.name = 'Workcenter'
) AS lastExpiredShiftInstance]]></sql><timeout>60.0</timeout></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="SQLCommand" name="CreateGetEventDurations"><ConfigurationTables><ConfigurationTable dataShapeName="" description="SQLCommand" isMultiRow="false" name="Query" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="NUMBER" description="maxItems" name="maxItems" ordinal="0"/><FieldDefinition baseType="STRING" description="sql" name="sql" ordinal="0"/><FieldDefinition baseType="NUMBER" description="timeout" name="timeout" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><maxItems>500.0</maxItems><sql><![CDATA[CREATE OR ALTER PROCEDURE GetEventDurations(
    @timeperiods timeperiodtype READONLY,
    @equipmentinfo equipmentinfotype READONLY,
    @shiftinstanceuid BIGINT,
    @materialmasteruid BIGINT,
    @minEventAgeInDays INT = 14)
AS
DECLARE @isWorkUnitOnly BIT = CASE WHEN (SELECT COUNT(*) FROM @equipmentinfo) = 1 THEN 1 ELSE 0 END

DROP TABLE IF EXISTS #availabilityDuration
CREATE TABLE #availabilityDuration(equipmentuid BIGINT, timeperiodid BIGINT, eventtypeuid BIGINT, eventcategoryuid BIGINT, joborderuid BIGINT, duration NUMERIC(38, 5), unknowntime NUMERIC(38, 5))

DECLARE @lastAggregatedAvailabilityEventHour DATETIMEOFFSET;
SELECT 
    @lastAggregatedAvailabilityEventHour =  DATEADD(HOUR, 1, MAX(eventdatetime))
FROM 
    aggregatedavailabilityevent

DECLARE @lastAggregatedAvailabilityEventHours timeperiodtype;
INSERT INTO @lastAggregatedAvailabilityEventHours(id, starttime, endtime)
SELECT tp.id,
       IIF(@lastAggregatedAvailabilityEventHour IS NULL OR tp.starttime > @lastAggregatedAvailabilityEventHour, tp.starttime, @lastAggregatedAvailabilityEventHour),
       tp.endtime
FROM @timeperiods AS tp;
                                        
INSERT INTO #availabilityDuration(equipmentuid, timeperiodid, eventtypeuid, eventcategoryuid, duration, unknowntime, joborderuid)
EXEC GetAvailabilityEventDuration
    @equipmentinfo = @equipmentinfo,
    @minEventAgeInDays  = @minEventAgeInDays,
    @timeperiods = @timeperiods,
    @shiftinstanceuid = @shiftinstanceuid,
    @materialmasteruid = @materialmasteruid

DECLARE @lastAggregatedLossEventHour DATETIMEOFFSET;
SELECT 
    @lastAggregatedLossEventHour =  DATEADD(HOUR, 1, MAX(eventdatetime)) 
FROM 
    aggregatedlossevent
    
DECLARE @lastAggregatedLossEventHours timeperiodtype;
INSERT INTO @lastAggregatedLossEventHours(id, starttime, endtime)
SELECT tp.id,
       IIF(@lastAggregatedLossEventHour IS NULL OR tp.startTime > @lastAggregatedLossEventHour, tp.starttime, @lastAggregatedLossEventHour),
       tp.endtime
FROM @timeperiods AS tp;


DROP TABLE IF EXISTS #eventCategoryDuration
CREATE TABLE #eventCategoryDuration(equipmentuid BIGINT, timeperiodid BIGINT, eventtypeuid BIGINT, eventcategoryuid BIGINT, joborderuid BIGINT, duration NUMERIC(38, 5), unknowntime NUMERIC(38, 5))

INSERT INTO #eventCategoryDuration(equipmentuid, timeperiodid, eventtypeuid, eventcategoryuid, joborderuid, duration, unknowntime)
    SELECT 
        equipmentuid,
        timeperiodid,
        eventtypeuid,
        eventcategoryuid,
    	joborderuid,
        SUM(duration),
        SUM(unknowntime)
    FROM 
        #availabilityDuration
	GROUP BY
    equipmentuid,
    timeperiodid, 
    eventtypeuid, 
    eventcategoryuid,
    joborderuid

    UNION ALL

    SELECT 
        equipmentuid,
        timeperiodid,
        eventtypeuid, 
        eventcategoryuid, 
    	joborderuid,
        SUM(lossvalue),
        0
    FROM 
        GetLossValue(@timeperiods, @equipmentinfo, @shiftinstanceuid, @materialmasteruid, @lastAggregatedLossEventHours)
	GROUP BY
    equipmentuid,
    timeperiodid, 
    eventtypeuid, 
    eventcategoryuid,
    joborderuid

UPDATE ecd
SET duration = duration/ppd.divisor,
unknowntime = unknowntime/ppd.divisor
FROM #eventCategoryDuration ecd
CROSS APPLY GetParallelPacemakerDivisor(ecd.equipmentuid,ecd.joborderuid,@isWorkUnitOnly) AS ppd

DECLARE @totalEventCategoryDuration TABLE (equipmentuid BIGINT, timeperiodid BIGINT, eventtypeuid BIGINT, eventcategoryuid BIGINT, joborderuid BIGINT, duration NUMERIC(38, 5), unknowntime NUMERIC(38, 5))

INSERT INTO @totalEventCategoryDuration(timeperiodid, eventtypeuid, eventcategoryuid, duration, unknowntime)
SELECT 
    timeperiodid, 
    eventtypeuid, 
    eventcategoryuid, 
    SUM(duration),
    SUM(unknowntime)
FROM 
    #eventCategoryDuration
GROUP BY
    timeperiodid, 
    eventtypeuid, 
    eventcategoryuid
    
DECLARE @lastAggregatedProductionEventHour DATETIMEOFFSET;
SELECT 
    @lastAggregatedProductionEventHour =  DATEADD(HOUR, 1, MAX(eventdatetime)) 
FROM 
    aggregatedproductionevent
    
DECLARE @lastAggregatedProductionEventHours timeperiodtype;
INSERT INTO @lastAggregatedProductionEventHours(id, starttime, endtime)
SELECT tp.id,
       IIF(@lastAggregatedProductionEventHour IS NULL OR tp.startTime > @lastAggregatedProductionEventHour, tp.starttime, @lastAggregatedProductionEventHour),
       tp.endtime
FROM @timeperiods AS tp;
    

DROP TABLE IF EXISTS #productionQty
CREATE TABLE #productionQty(equipmentuid BIGINT, timeperiodid BIGINT,eventtypeuid BIGINT, eventcategoryuid BIGINT, joborderuid BIGINT, quantity NUMERIC(38, 5), quantitytime NUMERIC(38, 5))

INSERT INTO #productionQty(equipmentuid, timeperiodid, eventtypeuid, eventcategoryuid, joborderuid, quantity, quantitytime)
SELECT 
    equipmentuid,
    timeperiodid, 
    eventtypeuid, 
    eventcategoryuid, 
    joborderuid,
    quantity, 
    quantitytime 
FROM 
    GetProductionQuantity(@timeperiods, @equipmentinfo, @shiftinstanceuid, @materialmasteruid, @lastAggregatedProductionEventHours)

UPDATE pq
SET quantitytime = quantitytime/ppd.divisor
FROM #productionQty pq
CROSS APPLY GetParallelPacemakerDivisor(pq.equipmentuid,pq.joborderuid,@isWorkUnitOnly) AS ppd

DECLARE @totalProductionQty TABLE(equipmentuid BIGINT, timeperiodid BIGINT, eventtypeuid BIGINT, eventcategoryuid BIGINT, quantitytime NUMERIC(38, 5), quantity NUMERIC(38, 5))

INSERT INTO @totalProductionQty(timeperiodid, eventtypeuid, eventcategoryuid, quantitytime, quantity)
SELECT 
    timeperiodid,
    eventtypeuid, 
    eventcategoryuid, 
    SUM(quantitytime),
    SUM(quantity)
FROM 
    #productionQty 
GROUP BY 
    timeperiodid,
    eventtypeuid, 
    eventcategoryuid

DECLARE @result TABLE(
    equipmentuid BIGINT,
    timeperiodid BIGINT,
    eventcategoryname NVARCHAR(255) COLLATE DATABASE_DEFAULT,
    eventtypename NVARCHAR(255) COLLATE DATABASE_DEFAULT,
    eventtypeuid BIGINT,
    eventcategoryuid  BIGINT,
    duration NUMERIC(38, 5),
    quantity NUMERIC(38, 5),
    unknowntime NUMERIC(38, 5)
)
INSERT INTO @result(equipmentuid, timeperiodid, eventtypename, eventcategoryname, eventtypeuid, eventcategoryuid, duration, quantity, unknowntime) 
SELECT
    ect.equipmentuid,
    ect.timeperiodid, 
    rt.name, 
    rc.name, 
    ect.eventtypeuid, 
    ect.eventcategoryuid, 
    ect.duration,
    0,
    ect.unknowntime
FROM 
    @totalEventCategoryDuration ect, 
    reasoncategory rc, 
    reasontype rt 
WHERE 
    rc.uid = ect.eventcategoryuid AND 
    rt.uid = rc.reasontypeuid


INSERT INTO @result(equipmentuid, timeperiodid, eventtypename, eventcategoryname, eventtypeuid, eventcategoryuid, duration, quantity, unknowntime) 
SELECT 
    tpq.equipmentuid,
    tpq.timeperiodid,
    rt.name,
    rc.name, 
    tpq.eventtypeuid, 
    tpq.eventcategoryuid, 
    tpq.quantitytime,
    tpq.quantity,
    0
FROM 
    @totalProductionQty tpq, 
    reasoncategory rc, 
    reasontype rt 
WHERE 
    rc.uid = tpq.eventcategoryuid AND
    rt.uid = rc.reasontypeuid

SELECT 
    equipmentuid,
    timeperiodid,
    eventtypename,
    eventcategoryname,
    eventtypeuid,
    eventcategoryuid,
    duration,
    quantity,
    unknowntime
FROM
    @result]]></sql><timeout>60.0</timeout></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="SQLCommand" name="CreateGetJobOrderSummary"><ConfigurationTables><ConfigurationTable dataShapeName="" description="SQLCommand" isMultiRow="false" name="Query" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="NUMBER" description="maxItems" name="maxItems" ordinal="0"/><FieldDefinition baseType="STRING" description="sql" name="sql" ordinal="0"/><FieldDefinition baseType="NUMBER" description="timeout" name="timeout" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><maxItems>500.0</maxItems><sql><![CDATA[CREATE OR ALTER FUNCTION GetJobOrderSummary(
    @modeltimeperiods modeltimeperiodtype READONLY
)
RETURNS @result TABLE(
    workcenteruid BIGINT,
    timeperiodid BIGINT,
    producedquantity NUMERIC(38, 5),
    shiftinstanceduration INT,
    unplannedduration INT,
    overtimeduration INT
)
AS BEGIN                                          
                                        
DECLARE @jobruntime TABLE(
    workcenteruid BIGINT,
    joborderuid BIGINT,
    timeperiodid BIGINT,
    durationid BIGINT,
    jostarttime DATETIMEOFFSET,
    joendtime DATETIMEOFFSET,    
    duration NUMERIC(18, 5),
                                        
    INDEX jobruntime_idx (workcenteruid, timeperiodid, jostarttime, joendtime) INCLUDE (joborderuid, durationid)
)
                                        
INSERT INTO @jobruntime(
    workcenteruid,
    joborderuid,
    timeperiodid,
    durationid,
    jostarttime,
    joendtime,
    duration
)
SELECT
    A.modeluid,
    A.joborderuid,
    timeperiodid,
    durationid,
    jostarttime,
    joendtime,
    DATEDIFF(MINUTE, jostarttime, joendtime) AS duration

FROM GetJobOrderStatusPeriods(@modeltimeperiods) A
INNER JOIN joborderexecutionresponse joer ON A.joborderuid = joer.joborderuid
INNER JOIN dispatchstatus ds ON joer.status = ds.uid
WHERE ds.name = 'Completed' AND A.status = 'Running'

DECLARE @shiftperiods TABLE(
    workcenteruid BIGINT,
    shiftstarttime DATETIMEOFFSET,
    shiftendtime DATETIMEOFFSET,
    duration NUMERIC(18, 5),
    timeperiodid BIGINT,
    isovertime BIT
                                        
    INDEX shiftdurations_workcenteruid_timeperiodid_idx CLUSTERED (workcenteruid, timeperiodid)
)
INSERT INTO @shiftperiods(
    workcenteruid,
    timeperiodid,
    isovertime,
    shiftstarttime,
    shiftendtime,
    duration
)
SELECT
    modeluid,
    timeperiodid,
    COALESCE(isovertime, 0),
    shiftstarttime,
    shiftendtime,
    DATEDIFF(MINUTE, shiftstarttime, shiftendtime)
FROM GetShiftPeriods(@modeltimeperiods)
                                            
DECLARE @shiftinstanceduration TABLE(
    workcenteruid BIGINT,
    timeperiodid BIGINT,
    duration INT
)
INSERT INTO @shiftinstanceduration(
    workcenteruid,
    timeperiodid,
    duration
)
SELECT
    workcenteruid,
    timeperiodid,
    SUM(duration)
FROM @shiftperiods
GROUP BY
    workcenteruid,
    timeperiodid
                                            
DECLARE @plannedproduction TABLE(
    workcenteruid BIGINT,
    joborderuid BIGINT,
    durationid INT,
    duration NUMERIC(18, 5),
    overtimeduration NUMERIC(18, 5),
    timeperiodid BIGINT,
    INDEX plannedproduction_joborderuid_durationid_idx NONCLUSTERED (joborderuid, durationid) INCLUDE (workcenteruid, duration)
)
INSERT INTO @plannedproduction(
    workcenteruid,
    joborderuid,
    durationid,
    timeperiodid,
    duration,
    overtimeduration
)
SELECT
    A.workcenteruid,
    A.joborderuid,
    A.durationid,
    A.timeperiodid,
    SUM(DATEDIFF(MINUTE, A.starttime, A.endtime)),
    SUM(IIF(A.isovertime = 1, DATEDIFF(MINUTE, A.starttime, A.endtime), 0))
FROM (
    SELECT
        jr.workcenteruid,
        jr.joborderuid,
        jr.durationid,
        IIF(jr.jostarttime < sp.shiftstarttime, sp.shiftstarttime, jr.jostarttime) AS starttime,
        IIF(jr.joendtime > sp.shiftendtime, sp.shiftendtime, jr.joendtime) AS endtime,
        jr.timeperiodid,
        sp.isovertime
    FROM @jobruntime jr
    INNER JOIN @shiftperiods sp ON sp.workcenteruid = jr.workcenteruid AND sp.timeperiodid = jr.timeperiodid AND (sp.shiftstarttime < jr.joendtime AND sp.shiftendtime > jr.jostarttime)
) A
GROUP BY
    A.workcenteruid,
    A.joborderuid,
    A.durationid,
    A.timeperiodid
                                            
DECLARE @unplannedproduction TABLE(
    workcenteruid BIGINT,
    timeperiodid BIGINT,
    duration NUMERIC(18, 5),
    overtimeduration NUMERIC(18, 5)
)
INSERT INTO @unplannedproduction(
    workcenteruid,
    timeperiodid,
    duration,
    overtimeduration
)
SELECT
    jr.workcenteruid,
    jr.timeperiodid,
    SUM(jr.duration - COALESCE(pp.duration, 0)) AS duration,
    SUM(COALESCE(pp.overtimeduration, 0)) AS overtimeduration
FROM @jobruntime jr
LEFT JOIN @plannedproduction pp ON jr.joborderuid = pp.joborderuid AND jr.durationid = pp.durationid
GROUP BY
    jr.workcenteruid,
    jr.timeperiodid
                                            
DECLARE @joproduction TABLE(
    timeperiodid BIGINT,
    joborderuid BIGINT,
    durationid BIGINT,
    quantity NUMERIC(38, 5),
                                        
    INDEX joproduction_idx (timeperiodid, joborderuid, durationid) INCLUDE (quantity)
)
INSERT INTO @joproduction(
    timeperiodid,
    joborderuid,
    durationid,
    quantity
)
SELECT
    jr.timeperiodid,
    jr.joborderuid,
    jr.durationid,
    SUM(quantity) AS quantity
FROM @jobruntime jr
INNER JOIN productionevent pe ON jr.joborderuid = pe.joborderuid AND (pe.eventtime >= jr.jostarttime AND pe.eventtime < jr.joendtime)
INNER JOIN reasontype rt ON pe.eventtypeuid = rt.uid
INNER JOIN model m ON m.uid = pe.modeluid
WHERE rt.name = 'Production' AND m.ispacemaker = 1
GROUP BY
    jr.workcenteruid,
    jr.timeperiodid,
    jr.joborderuid,
    jr.durationid
                                        
INSERT INTO @result(
    workcenteruid,
    timeperiodid,
    producedquantity,
    shiftinstanceduration,    
    unplannedduration,
    overtimeduration
)
SELECT
    A.workcenteruid,
    A.timeperiodid,
    A.producedquantity,
    COALESCE(sd.duration, 0) AS shiftinstanceduration,    
    COALESCE(unp.duration, 0) AS unplannedduration,
    COALESCE(unp.overtimeduration, 0) AS overtimeduration
FROM (
    SELECT
        jr.workcenteruid,
        jr.timeperiodid,
        COALESCE(SUM(jp.quantity), 0) AS producedquantity
    FROM  @jobruntime jr
    LEFT JOIN @joproduction jp ON jr.joborderuid = jp.joborderuid AND jr.timeperiodid = jp.timeperiodid AND jr.durationid = jp.durationid
    GROUP BY
        jr.workcenteruid,
        jr.timeperiodid
) A
    LEFT JOIN @shiftinstanceduration sd ON A.workcenteruid = sd.workcenteruid AND A.timeperiodid = sd.timeperiodid
    LEFT JOIN @unplannedproduction unp ON A.workcenteruid = unp.workcenteruid AND A.timeperiodid = unp.timeperiodid
                                        
RETURN
END]]></sql><timeout>0.0</timeout></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="SQLCommand" name="CreateGetLastExpiredModelShiftInstances"><ConfigurationTables><ConfigurationTable dataShapeName="" description="SQLCommand" isMultiRow="false" name="Query" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="NUMBER" description="maxItems" name="maxItems" ordinal="0"/><FieldDefinition baseType="STRING" description="sql" name="sql" ordinal="0"/><FieldDefinition baseType="NUMBER" description="timeout" name="timeout" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><maxItems>500.0</maxItems><sql><![CDATA[CREATE OR ALTER FUNCTION GetLastExpiredModelShiftInstances()
RETURNS TABLE
AS RETURN

SELECT
    lastShift.modeluid AS modelUid,
    lastShift.workcentermodeluid AS workcenterModelUid,
    lastShift.uid AS shiftInstanceUid,
    CAST (lastShift.actualstarttime AS DATETIME2) AS actualStartTime,
    CAST (lastShift.actualendtime AS DATETIME2) AS actualEndTime,
    lastShift.thingname AS thingName
FROM (
    SELECT
        pacemaker.uid AS modeluid,
        si.modeluid AS workcentermodeluid,
        si.uid,
        si.actualstarttime,
        si.actualendtime,
        pacemaker.thingname AS thingname,
        ROW_NUMBER() OVER (PARTITION BY si.modeluid ORDER BY si.actualendtime DESC) AS rn
    FROM
        shiftinstance si
        INNER JOIN model ON model.uid = si.modeluid
        INNER JOIN modeltype ON modeltype.uid = model.modeltypeuid
        INNER JOIN modellink wcl on wcl.parentuid = model.uid
        INNER JOIN model as pacemaker ON pacemaker.uid = wcl.childuid
    WHERE
        actualendtime < SYSUTCDATETIME() AND
        SYSUTCDATETIME() > actualstarttime AND
        modeltype.name = 'Workcenter'	
) AS lastShift
WHERE
lastShift.rn = 1]]></sql><timeout>60.0</timeout></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="SQLCommand" name="CreateGetLossValue"><ConfigurationTables><ConfigurationTable dataShapeName="" description="SQLCommand" isMultiRow="false" name="Query" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="NUMBER" description="maxItems" name="maxItems" ordinal="0"/><FieldDefinition baseType="STRING" description="sql" name="sql" ordinal="0"/><FieldDefinition baseType="NUMBER" description="timeout" name="timeout" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><maxItems>500.0</maxItems><sql><![CDATA[CREATE OR ALTER FUNCTION GetLossValue(
    @timeperiods timeperiodtype READONLY,
    @equipmentinfo AS equipmentinfotype READONLY,
    @shiftinstanceuid BIGINT,
    @materialmasteruid BIGINT,
    @lastAggregatedDays timeperiodtype READONLY)
RETURNS TABLE
AS RETURN
    SELECT
        A.modeluid AS equipmentuid,
        A.timeperiodid,
        A.eventtypeuid,
        A.eventcategoryuid,
        SUM(A.lossvalue) AS lossvalue,
		A.joborderuid
    FROM (
        SELECT
            le.modeluid,
            tp.id AS timeperiodid,
            le.eventtypeuid,
            le.eventcategoryuid,
            le.lossvalue,
			le.joborderuid
        FROM 
            aggregatedlossevent le
            INNER JOIN @equipmentinfo ei ON le.modeluid = ei.equipmentuid
            INNER JOIN @timeperiods tp ON (le.eventdatetime >= FORMAT(tp.starttime, 'yyyy-MM-dd HH:00:00') AND le.eventdatetime < FORMAT(tp.endtime, 'yyyy-MM-dd HH:00:00'))
        WHERE
            (@shiftinstanceuid IS NULL OR le.shiftinstanceuid = @shiftinstanceuid) AND
            (@materialmasteruid IS NULL OR le.materialmasteruid = @materialmasteruid)

            UNION ALL

        SELECT
            le.modeluid,
            lads.id AS timeperiodid,
            le.eventtypeuid,
            le.eventcategoryuid,
            IIF(le.lossvalue > 0, le.lossvalue, 0) AS lossvalue,
			le.joborderuid
        FROM 
            lossevent le
            INNER JOIN @equipmentinfo ei ON le.modeluid = ei.equipmentuid
            INNER JOIN @lastAggregatedDays lads ON (le.eventtime >= lads.starttime AND le.eventtime < lads.endtime)
        WHERE
            lads.starttime < lads.endtime AND
            (le.shiftinstanceuid IS NOT NULL OR le.joborderuid IS NOT NULL) AND
            (@shiftinstanceuid IS NULL OR le.shiftinstanceuid = @shiftinstanceuid) AND
            (@materialmasteruid IS NULL OR le.materialmasteruid = @materialmasteruid)
    ) A
    GROUP BY
        A.modeluid,
        A.timeperiodid,
        A.eventtypeuid,
        A.eventcategoryuid,
		A.joborderuid]]></sql><timeout>60.0</timeout></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="SQLCommand" name="CreateGetNextLevelPareto"><ConfigurationTables><ConfigurationTable dataShapeName="" description="SQLCommand" isMultiRow="false" name="Query" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="NUMBER" description="maxItems" name="maxItems" ordinal="0"/><FieldDefinition baseType="STRING" description="sql" name="sql" ordinal="0"/><FieldDefinition baseType="NUMBER" description="timeout" name="timeout" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><maxItems>500.0</maxItems><sql><![CDATA[CREATE OR ALTER PROCEDURE GetNextLevelPareto(
    @starttime DATETIMEOFFSET,
    @endtime DATETIMEOFFSET,
    @equipmentinfo AS equipmentinfotype READONLY,
    @eventcategoryuid BIGINT,
    @reasoncategoryuid BIGINT,
    @reasontreenodeuid BIGINT,
    @shiftinstanceuid BIGINT,
    @materialmasteruid BIGINT,
    @reasonmodeluid BIGINT)
AS

DECLARE @isWorkUnitOnly BIT = CASE WHEN (SELECT COUNT(*) FROM @equipmentinfo) = 1 THEN 1 ELSE 0 END

DROP TABLE IF EXISTS #lossRecords
CREATE TABLE #lossRecords(
	lossvalue NUMERIC(38, 5), 
	reasontreenodeuid BIGINT, 
	reasonmodeluid BIGINT, 
	eventcategoryuid BIGINT,
	reasoncategoryuid BIGINT,
    joborderuid BIGINT,
	equipmentuid BIGINT
)

CREATE NONCLUSTERED INDEX reasontypeuid_idx ON #lossRecords (reasontreenodeuid)

INSERT INTO #lossRecords
	SELECT 
		SUM(lossvalue) AS lossvalue,
		reasontreenodeuid,
		reasonmodeluid,
		eventcategoryuid, 
		reasoncategoryuid,
		joborderuid,
		equipmentuid
	FROM 
		GetLossValueRows(@starttime, @endtime, @equipmentinfo, @eventcategoryuid, @reasoncategoryuid, @shiftinstanceuid, @materialmasteruid, @reasonmodeluid) 
	GROUP BY
		reasontreenodeuid,
		reasonmodeluid,
		eventcategoryuid, 
		reasoncategoryuid,
		joborderuid,
		equipmentuid

	UNION ALL

	SELECT
		SUM(quantitytime) AS lossvalue,
		reasontreenodeuid,
		reasonmodeluid,
		eventcategoryuid, 
		reasoncategoryuid,
		joborderuid,
		equipmentuid
	FROM
		GetProductionQuantityRows(@starttime, @endtime, @equipmentinfo, @eventcategoryuid, @reasoncategoryuid, @shiftinstanceuid, @materialmasteruid, @reasonmodeluid)
	GROUP BY
		reasontreenodeuid,
		reasonmodeluid,
		eventcategoryuid, 
		reasoncategoryuid,
		joborderuid,
		equipmentuid

	UNION ALL

	SELECT 
		SUM(timediff) AS lossvalue,
		reasontreenodeuid, 
		reasonmodeluid,
		eventcategoryuid, 
		reasoncategoryuid,
		joborderuid,
		equipmentuid
	FROM 
		GetAvailabilityEventDurationRows(@starttime, @endtime, @equipmentinfo, DEFAULT)
	WHERE
		(@shiftinstanceuid IS NULL OR shiftinstanceuid = @shiftinstanceuid) AND
		(@materialmasteruid IS NULL OR materialmasteruid = @materialmasteruid) AND
		(@reasonmodeluid IS NULL OR reasonmodeluid = @reasonmodeluid) AND
		(@reasoncategoryuid IS NULL OR reasoncategoryuid = @reasoncategoryuid) AND
		(@eventcategoryuid IS NULL OR eventcategoryuid = @eventcategoryuid)
	GROUP BY 
		reasontreenodeuid, 
		reasonmodeluid,
		eventcategoryuid, 
		reasoncategoryuid,
		joborderuid,
		equipmentuid
        
UPDATE lr
SET lossvalue = lossvalue/ppd.divisor
FROM #lossRecords lr
CROSS APPLY GetParallelPacemakerDivisor(lr.equipmentuid,lr.joborderuid, @isWorkUnitOnly) AS ppd

;WITH childNodes(reasonuid, uid, parentreasontreenodeuid, rootid) AS (	
    SELECT 
        reasonuid,
        uid,
        parentreasontreenodeuid,
        uid
    FROM 
        reasontreenode
    WHERE (
        (@reasontreenodeuid IS NOT NULL AND parentreasontreenodeuid = @reasontreenodeuid) OR
        (@reasoncategoryuid IS NOT NULL AND @reasontreenodeuid IS NULL AND parentreasontreenodeuid IS NULL)
    )

    UNION ALL
        
    SELECT
        childNodes.reasonuid,
        t.uid,
        t.parentreasontreenodeuid,
        childNodes.rootid
    FROM
        reasontreenode t
        INNER JOIN childNodes ON childNodes.uid = t.parentreasontreenodeuid

), totalReasonNodes(reasonuid, uid, parentreasontreenodeuid, rootid) AS (
    SELECT
        reasonuid,
        uid,
        parentreasontreenodeuid,
        uid
    FROM
        reasontreenode
    WHERE
        @reasontreenodeuid IS NOT NULL AND uid = @reasontreenodeuid    

    UNION ALL
        
    SELECT
        childNodes.reasonuid,
        childNodes.uid,
        childNodes.parentreasontreenodeuid,
        childNodes.rootid
    FROM
        childNodes
)
SELECT
    SUM(#lossRecords.lossvalue) AS losseventvalue,
    totalReasonNodes.rootid AS nodeid,
    a.name AS reasonname,
    CONCAT(IIF(totalReasonNodes.rootid IS NOT NULL, a.name, rc.name), ' - ', m.name) AS description,
    #lossRecords.reasonmodeluid,
    m.name AS reasonmodelname,
    #lossRecords.eventcategoryuid,
    rc.uid AS reasoncategoryuid,
    rc.name AS reasoncategoryname
FROM 
    #lossRecords
    LEFT JOIN totalReasonNodes ON totalReasonNodes.uid = #lossRecords.reasontreenodeuid
    LEFT JOIN reason a ON a.uid = totalReasonNodes.reasonuid
    LEFT JOIN reasoncategory rc ON rc.uid = #lossRecords.reasoncategoryuid
    INNER JOIN model m ON #lossRecords.reasonmodeluid = m.uid
WHERE 
    #lossRecords.lossvalue > 0 
	AND (
		(@reasontreenodeuid IS NOT NULL AND totalReasonNodes.rootid IS NOT NULL) OR 
		(@reasontreenodeuid IS NULL AND (totalReasonNodes.rootid IS NOT NULL OR totalReasonNodes.rootid IS NULL))
	)
GROUP BY 
    totalReasonNodes.rootid,
    a.name,
    m.name,
    #lossRecords.reasonmodeluid,
    #lossRecords.eventcategoryuid,
    rc.uid,
    rc.name
ORDER BY 
	losseventvalue DESC]]></sql><timeout>60.0</timeout></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="SQLCommand" name="CreateGetPacemakerModelsForExpiredProductionBlock"><ConfigurationTables><ConfigurationTable dataShapeName="" description="SQLCommand" isMultiRow="false" name="Query" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="NUMBER" description="maxItems" name="maxItems" ordinal="0"/><FieldDefinition baseType="STRING" description="sql" name="sql" ordinal="0"/><FieldDefinition baseType="NUMBER" description="timeout" name="timeout" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><maxItems>500.0</maxItems><sql><![CDATA[CREATE OR ALTER FUNCTION GetPacemakerModelsForExpiredProductionBlock()
RETURNS TABLE
AS RETURN
    SELECT
    	a.modeluid AS modelUid,
    	a.thingname AS thingName,
        a.productionblockuid AS productionBlockUid,
        a.joborderuid AS jobOrderUid,
        a.enddatetime AS enddatetime
    FROM (
        SELECT
        	pb.modeluid as modeluid,
        	m.thingname as thingname,
        	pb.enddatetime as enddatetime,
        	pb.joborderuid as joborderuid,
        	pb.uid as productionblockuid,
        	ROW_NUMBER() OVER (PARTITION BY pb.modeluid ORDER BY pb.enddatetime DESC) AS rn
    	FROM
        	productionblock pb INNER JOIN model m ON pb.modeluid = m.uid
    	WHERE
            pb.enddatetime < SYSUTCDATETIME()
    ) AS a
    WHERE
    	a.rn = 1]]></sql><timeout>60.0</timeout></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="SQLCommand" name="CreateGetParallelPacemakerDivisor"><ConfigurationTables><ConfigurationTable dataShapeName="" description="SQLCommand" isMultiRow="false" name="Query" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="NUMBER" description="maxItems" name="maxItems" ordinal="0"/><FieldDefinition baseType="STRING" description="sql" name="sql" ordinal="0"/><FieldDefinition baseType="NUMBER" description="timeout" name="timeout" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><maxItems>500.0</maxItems><sql><![CDATA[CREATE OR ALTER FUNCTION GetParallelPacemakerDivisor
(
	@equipmentuid BIGINT,
	@joborderuid BIGINT,
    @isWorkUnitOnly BIT
)
RETURNS TABLE
AS
RETURN
	WITH totalduration AS (
		SELECT POWER(SUM(POWER(A.duration,-1)),-1) as duration, @equipmentuid as modeluid FROM (
			SELECT 
				wd.uid,
				wmms.modeluid,
				wd.duration	
			FROM workdefinition wd
			JOIN workmastermodelspecification wmms ON wd.workmasteruid = wmms.workmasteruid
			JOIN model m ON wmms.modeluid = m.uid
			WHERE m.ispacemaker = 1
			AND wd.uid IN 
			(
				SELECT childuid 
				FROM workdefinitionlink 
				WHERE parentuid IN 
				(
					SELECT workdefinitionuid
					FROM joborderworkdefinitionlink
					WHERE joborderuid = @joborderuid
				)
			)
		) A
	), 
	pacemakerduration AS (
		SELECT A.duration as duration, @equipmentuid as modeluid FROM (
			SELECT 
				wd.uid,
				wmms.modeluid,
				wd.duration	
			FROM workdefinition wd
			JOIN workmastermodelspecification wmms ON wd.workmasteruid = wmms.workmasteruid
			JOIN model m ON wmms.modeluid = m.uid
			WHERE wd.uid IN 
			(
				SELECT childuid 
				FROM workdefinitionlink 
				WHERE parentuid IN 
				(
					SELECT workdefinitionuid
					FROM joborderworkdefinitionlink
					WHERE joborderuid = @joborderuid
				)
			)
		) A
		WHERE A.modeluid = @equipmentuid
	),
    pacemakers AS (
		SELECT COUNT(ml2.childuid) as pacemakercount, @equipmentuid as modeluid FROM modellink ml2
		JOIN model m ON ml2.childuid = m.uid
		WHERE parentuid IN (SELECT parentuid FROM modellink ml WHERE ml.childuid = @equipmentuid)
		AND m.ispacemaker = 1
		
	)

	SELECT (CASE WHEN @isWorkUnitOnly = 1 THEN @isWorkUnitOnly ELSE IIF(@joborderuid IS NOT NULL, pd.duration/td.duration, pm.pacemakercount) END) AS divisor FROM pacemakers pm 
	LEFT JOIN pacemakerduration pd ON pd.modeluid = pm.modeluid
	LEFT JOIN totalduration td ON pm.modeluid = td.modeluid]]></sql><timeout>60.0</timeout></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="SQLCommand" name="CreateGetProductionBlockInfo"><ConfigurationTables><ConfigurationTable dataShapeName="" description="SQLCommand" isMultiRow="false" name="Query" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="NUMBER" description="maxItems" name="maxItems" ordinal="0"/><FieldDefinition baseType="STRING" description="sql" name="sql" ordinal="0"/><FieldDefinition baseType="NUMBER" description="timeout" name="timeout" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><maxItems>500.0</maxItems><sql><![CDATA[CREATE OR ALTER PROCEDURE GetProductionBlockInfo (
    @productionblocks productionblocktype READONLY,
    @timeratio NUMERIC(18, 5) = 60)
AS 
    DECLARE @totaltime_table TABLE(uid BIGINT, totaltime NUMERIC(38, 5))

    INSERT INTO @totaltime_table(uid, totaltime)
    SELECT 
        productionblockuid, 
        DATEDIFF(SECOND, starttime, endtime)
    FROM
        @productionblocks
            
    DROP TABLE IF EXISTS #downtime_table
    CREATE TABLE #downtime_table (uid BIGINT, downtime NUMERIC(38, 5))
   
    INSERT INTO #downtime_table(uid, downtime)
    SELECT 
        rcbpb.productionblockuid,
        SUM(rcbpb.duration)
    FROM
        @productionblocks pbs INNER JOIN 
        GetAvailabilityByProductionBlock(@productionblocks) rcbpb ON(rcbpb.productionblockuid = pbs.productionblockuid) INNER JOIN
        reasontype rt ON(rcbpb.eventtypeuid = rt.uid)
    WHERE
        rt.name = 'Down'
    GROUP BY
        rcbpb.productionblockuid

            
    DECLARE @edgedowntime_table TABLE(uid BIGINT, edgedowntime NUMERIC(38, 5))

    INSERT INTO @edgedowntime_table(uid, edgedowntime)
    SELECT
        pbs.productionblockuid,
        duration
    FROM
        @productionblocks pbs CROSS APPLY
        GetAvailabilityEventEdgeValue(pbs.starttime, pbs.endtime, pbs.modeluid) aeev INNER JOIN
        reasontype rt ON(aeev.eventtypeuid = rt.uid)
    WHERE
        rt.name = 'Down'


    MERGE #downtime_table AS dt
    USING @edgedowntime_table AS edt ON(dt.uid = edt.uid)
    WHEN MATCHED THEN 
        UPDATE SET downtime = downtime + IIF(edgedowntime > 0, edgedowntime, 0)
    WHEN NOT MATCHED THEN
        INSERT(uid, downtime) VALUES(edt.uid, IIF(edgedowntime > 0, edgedowntime, 0));

    
    DROP TABLE IF EXISTS #speedloss_table
    CREATE TABLE #speedloss_table (uid BIGINT, loss NUMERIC(38, 5))

    INSERT INTO #speedloss_table(uid, loss)
    SELECT 
        pbs.productionblockuid,
        COALESCE(SUM(lvbpb.lossvalue), 0)
    FROM
        @productionblocks pbs INNER JOIN
        GetLossValueByProductionBlock(@productionblocks) lvbpb ON(pbs.productionblockuid = lvbpb.productionblockuid) INNER JOIN
        reasontype rt ON(lvbpb.eventtypeuid = rt.uid)
    WHERE
        rt.name = 'SpeedLoss'
    GROUP BY
        pbs.productionblockuid


    DROP TABLE IF EXISTS #lossdowntime_table
    CREATE TABLE #lossdowntime_table (uid BIGINT, downtimeloss NUMERIC(38, 5))

    INSERT INTO #lossdowntime_table(uid, downtimeloss)
    SELECT
        pbs.productionblockuid,
        SUM(lvbpb.lossvalue)
    FROM 
        @productionblocks pbs INNER JOIN
        GetLossValueByProductionBlock(@productionblocks) lvbpb ON(pbs.productionblockuid = lvbpb.productionblockuid) INNER JOIN
        reasontype rt ON(lvbpb.eventtypeuid = rt.uid)
    WHERE
        rt.name = 'Down'
    GROUP BY
        pbs.productionblockuid

    
    MERGE #downtime_table AS dt
    USING #lossdowntime_table AS ldt ON(dt.uid = ldt.uid)
    WHEN MATCHED THEN 
        UPDATE SET downtime = downtime + IIF(downtimeloss > 0, downtimeloss, 0)
    WHEN NOT MATCHED THEN
        INSERT(uid, downtime) VALUES(ldt.uid, IIF(downtimeloss > 0, downtimeloss, 0));

    
    DECLARE @shiftduration TABLE(uid BIGINT, regular NUMERIC(38, 5), overtime NUMERIC(38, 5))
    
    INSERT INTO @shiftduration(uid, regular, overtime)
    SELECT
        productionblockuid,
        IIF(regularshiftduration > 0, regularshiftduration, 0),
        IIF(overtimeshiftduration > 0, overtimeshiftduration, 0)
    FROM
        GetShiftDuration(@productionblocks)
               

    DECLARE @unscheduledtime_table TABLE(uid BIGINT, unscheduledtime NUMERIC(38, 5))

    INSERT INTO @unscheduledtime_table(uid, unscheduledtime)
    SELECT
        tt.uid,
        tt.totaltime - COALESCE(shd.regular, 0)
    FROM 
        @totaltime_table tt LEFT JOIN
        @shiftduration shd ON(tt.uid = shd.uid)
    
    DECLARE @overtime_table TABLE(uid BIGINT, overtime NUMERIC(38, 5))

    INSERT INTO @overtime_table(uid, overtime)
    SELECT 
        pbs.productionblockuid,
        IIF(unp.duration > 0, unp.duration, 0) + COALESCE(shd.overtime, 0)
    FROM
        @productionblocks pbs LEFT JOIN
        GetUnplannedProductionDuration(@productionblocks, 'Running') unp ON(pbs.productionblockuid = unp.productionblockuid) LEFT JOIN
        @shiftduration shd ON(pbs.productionblockuid = shd.uid)


    DECLARE @plannedproduction_table TABLE(uid BIGINT, plannedproduction NUMERIC(38, 5))

    INSERT INTO @plannedproduction_table(uid, plannedproduction)
    SELECT
        tt.uid,
        tt.totaltime - COALESCE(unsht.unscheduledtime, 0)
    FROM
        @totaltime_table tt LEFT JOIN
        @unscheduledtime_table unsht ON(tt.uid = unsht.uid)


    DECLARE @availabletime_table TABLE(uid BIGINT, availabletime NUMERIC(38, 5))

    INSERT INTO @availabletime_table(uid, availabletime)
    SELECT
        pp.uid,
        pp.plannedproduction - COALESCE(dt.downtime, 0) + COALESCE(ot.overtime, 0)
    FROM
        @plannedproduction_table pp LEFT JOIN
        #downtime_table dt ON(pp.uid = dt.uid) LEFT JOIN
        @overtime_table ot ON(pp.uid = ot.uid)


    DECLARE @operationaltime_table TABLE(uid BIGINT, operationaltime NUMERIC(38, 5))
    
    INSERT INTO @operationaltime_table(uid, operationaltime)
    SELECT
        att.uid,
        att.availabletime - COALESCE(sl.loss, 0)
    FROM
        @availabletime_table att LEFT JOIN 
        #speedloss_table sl ON(att.uid = sl.uid)

    
    DECLARE @accountedtime_table TABLE(uid BIGINT, accountedtime NUMERIC(38, 5))

    INSERT INTO @accountedtime_table(uid, accountedtime)
    SELECT
        unsch.uid,
        COALESCE(dt.downtime, 0) + COALESCE(sl.loss, 0)
    FROM
        @unscheduledtime_table unsch LEFT JOIN
        #downtime_table dt ON(unsch.uid = dt.uid) LEFT JOIN
        #speedloss_table sl ON(unsch.uid = sl.uid)


    DECLARE @idealcycletime_table TABLE(uid BIGINT, idealcycletime NUMERIC(18, 5), modeluid BIGINT)
    
   -- MMM Updated retrieval of ideal cycle time to account for multiple work units active on a single job order.
    INSERT INTO @idealcycletime_table(uid, idealcycletime, modeluid)
    SELECT
        pbs.productionblockuid,
        wdc.duration,
        pr.modeluid
    FROM
        @productionblocks pbs LEFT JOIN
		workdefinitionexecutionresponse wder ON (pbs.modeluid = wder.modeluid AND pbs.joborderuid = wder.joborderuid) LEFT JOIN
		workdefinition wdc ON (wdc.uid = wder.workdefinitionuid) LEFT JOIN
        workdefinitionprocessingresourcespecification wdprs ON(wdc.uid = wdprs.workdefinitionuid) LEFT JOIN
        processingresource pr ON(wdprs.processingresourceuid = pr.uid)
	WHERE wder.status = 9
    
    DROP TABLE IF EXISTS #production_quantity
    CREATE TABLE #production_quantity(
        uid BIGINT,
        producedquantity NUMERIC(38, 5),
        producedtime NUMERIC(38, 5),
        goodproducequantity NUMERIC(38, 5),
        goodproducetime NUMERIC(38, 5),
        scrapquantity NUMERIC(38, 5),
        scraptime NUMERIC(38, 5)
    )
    
    INSERT INTO #production_quantity(
        uid,
        producedquantity,
        producedtime,
        goodproducequantity,
        goodproducetime,
        scrapquantity,
        scraptime
    )
    SELECT
        pqbpb.productionblockuid,
        SUM(pqbpb.quantity),
        SUM(pqbpb.quantity * COALESCE(ict.idealcycletime, 0)),
        SUM(IIF(rt.name = 'Production', pqbpb.quantity, 0)),
        SUM(IIF(rt.name = 'Production', pqbpb.quantity * COALESCE(ict.idealcycletime, 0), 0)),
        SUM(IIF(rt.name = 'Scrap', pqbpb.quantity, 0)),
        SUM(IIF(rt.name = 'Scrap', pqbpb.quantity * COALESCE(ict.idealcycletime, 0), 0))
    FROM 
        GetProductionQuantityByProductionBlock(@productionblocks) pqbpb LEFT JOIN
        @idealcycletime_table ict ON(ict.uid = pqbpb.productionblockuid) LEFT JOIN
        reasontype rt ON(pqbpb.eventtypeuid = rt.uid)
    WHERE
        rt.name IN ('Production', 'Scrap')
    GROUP BY
        pqbpb.productionblockuid


    DECLARE @quantity_table TABLE(
        uid BIGINT,
        producedquantity NUMERIC(38, 5),
        expectedProduceQuantity NUMERIC(38, 5),
        goodproducequantity NUMERIC(38, 5),
        goodproducetime NUMERIC(38, 5),
        scrapquantity NUMERIC(38, 5),
        scraptime NUMERIC(38, 5),
        unaccountedtime NUMERIC(38, 5),
        totalLostTime NUMERIC(38, 5),
        effectivetime NUMERIC(38, 5)
    )

    INSERT INTO @quantity_table(
        uid,
        producedquantity,
        expectedProduceQuantity,
        goodproducequantity,
        goodproducetime,
        scrapquantity,
        scraptime,
        unaccountedtime,
        totalLostTime,
        effectivetime
    )
    SELECT
        pbs.productionblockuid,
        COALESCE(pq.producedquantity, 0),
        IIF(ict.idealcycletime IS NOT NULL, COALESCE(pp.plannedproduction, 0) / ict.idealcycletime, 0),
        COALESCE(pq.goodproducequantity, 0),
        COALESCE(pq.goodproducetime, 0),
        COALESCE(pq.scrapquantity, 0),
        COALESCE(pq.scraptime, 0),
        ot.operationaltime - COALESCE(pq.producedtime, 0),
        pp.plannedproduction - COALESCE(pq.goodproducetime, 0) + ovt.overtime,
        COALESCE(ot.operationaltime - COALESCE(pq.scraptime, 0), ot.operationaltime) - COALESCE(ot.operationaltime - COALESCE(pq.producedtime, 0), ot.operationaltime)
    FROM 
        @productionblocks pbs LEFT JOIN
        @idealcycletime_table ict ON(pbs.productionblockuid = ict.uid AND pbs.modeluid = ict.modeluid) LEFT JOIN
        #production_quantity pq ON(pbs.productionblockuid = pq.uid) LEFT JOIN
        @plannedproduction_table pp ON(pbs.productionblockuid = pp.uid) LEFT JOIN 
        @operationaltime_table ot ON(pbs.productionblockuid = ot.uid) LEFT JOIN
        @overtime_table ovt ON(pbs.productionblockuid = ovt.uid)

    
    -- Final result
    SELECT
        pbs.modeluid,
        pbs.productionblockuid AS productionBlockUid,
        pbs.joborderuid AS jobOrderUid,
        jo.id AS jobOrderId,
        shift.name AS shiftName,
        mdl.thingname AS modelName,
        pbs.materialmasteruid AS materialMasterUid,
        mm.id AS materialMasterId,
        CAST(pbs.starttime AS DATETIME2) AS startTime,
        CAST(pbs.endtime AS DATETIME2) AS endTime,
        tt.totaltime/@timeratio AS productionBlockDuration,
        qty.producedquantity AS actualProduceQuantity,
        COALESCE(qty.expectedProduceQuantity, 0) AS expectedProduceQuantity,
        IIF(ict.idealcycletime IS NOT NULL, tt.totaltime/ict.idealcycletime, 0) AS targetProduceQuantity,
        ict.idealcycletime AS idealCycleTime,
        pp.plannedproduction/@timeratio AS expectedProduceTime,
        qty.scrapquantity AS scrapQuantity,
        qty.scraptime/@timeratio AS scrapTime,
        qty.goodproducequantity AS goodProduceQuantity,
        qty.goodproducetime/@timeratio AS goodProduceTime,
        acc.accountedtime/@timeratio AS accountedTime,
        COALESCE(qty.unaccountedtime, ot.operationaltime)/@timeratio AS unaccountedTime, 
        IIF(COALESCE(qty.unaccountedtime, ot.operationaltime) > 0, 1, 0) AS hasUnaccountedTime,
        COALESCE(qty.totalLostTime, 0)/@timeratio AS totalLostTime,
        qty.effectivetime/@timeratio AS effectiveTime
    FROM 
        @productionblocks pbs LEFT JOIN
        @plannedproduction_table pp ON(pbs.productionblockuid = pp.uid) LEFT JOIN
        @accountedtime_table acc ON(pbs.productionblockuid = acc.uid) LEFT JOIN
        @quantity_table qty ON(pbs.productionblockuid = qty.uid) LEFT JOIN
        @totaltime_table tt ON(pbs.productionblockuid = tt.uid) LEFT JOIN
        @operationaltime_table ot ON(pbs.productionblockuid = ot.uid) LEFT JOIN
        @idealcycletime_table ict ON(pbs.productionblockuid = ict.uid AND pbs.modeluid = ict.modeluid) LEFT JOIN
        joborder jo ON(pbs.joborderuid = jo.uid) LEFT JOIN
        materialmaster mm ON(pbs.materialmasteruid = mm.uid) LEFT JOIN 
        shiftinstance si ON (pbs.modeluid = si.modeluid AND (pbs.starttime >= si.actualstarttime AND pbs.endtime <= si.actualendtime))  LEFT JOIN
        shift ON shift.uid = si.shiftuid LEFT JOIN
        model mdl ON mdl.uid = pbs.modeluid]]></sql><timeout>60.0</timeout></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="SQLCommand" name="CreateGetProductionEventDurations"><ConfigurationTables><ConfigurationTable dataShapeName="" description="SQLCommand" isMultiRow="false" name="Query" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="NUMBER" description="maxItems" name="maxItems" ordinal="0"/><FieldDefinition baseType="STRING" description="sql" name="sql" ordinal="0"/><FieldDefinition baseType="NUMBER" description="timeout" name="timeout" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><maxItems>500.0</maxItems><sql><![CDATA[CREATE OR ALTER PROCEDURE GetProductionEventDurations(
    @timeperiods timeperiodtype READONLY,
    @parent_children uidmap READONLY,
    @shiftinstanceuid BIGINT,
    @materialmasteruid BIGINT)
AS
DECLARE @isWorkUnitOnly BIT = CASE WHEN 6 IN (SELECT m.modeltypeuid FROM @parent_children ids JOIN model m ON m.uid = ids.fromuid) THEN 1 ELSE 0 END
DECLARE @lastAggregatedTime DATETIMEOFFSET;
SELECT
    @lastAggregatedTime = DATEADD(HOUR, 1, MAX(eventdatetime))
FROM
    aggregatedproductionevent;

DECLARE @historicaltimeperiods timeperiodtype;
DECLARE @recenttimeperiods timeperiodtype;

IF @lastAggregatedTime IS NOT NULL
BEGIN
    INSERT INTO @historicaltimeperiods(id, starttime, endtime)
        SELECT
            tp.id,
            tp.starttime,
            IIF(tp.endtime < @lastAggregatedTime, tp.endtime, @lastAggregatedTime)
        FROM
            @timeperiods AS tp
        WHERE
            tp.starttime <= @lastAggregatedTime;

    INSERT INTO @recenttimeperiods(id, starttime, endtime)
        SELECT
            tp.id,
            IIF(tp.starttime < @lastAggregatedTime, @lastAggregatedTime, tp.starttime),
            tp.endtime
        FROM
            @timeperiods AS tp
        WHERE
            @lastAggregatedTime < tp.endtime;
END
ELSE
    INSERT INTO @recenttimeperiods(id, starttime, endtime)
        SELECT
            tp.id,
            tp.starttime,
            tp.endtime
        FROM
            @timeperiods AS tp;

DROP TABLE IF EXISTS #totalProductionQty
CREATE TABLE #totalProductionQty(
    modeluid BIGINT INDEX IX1 CLUSTERED,
    timeperiodid BIGINT INDEX IX2 NONCLUSTERED,
    eventtypeuid BIGINT,
    eventcategoryuid BIGINT INDEX IX3 NONCLUSTERED,
    duration NUMERIC(38, 5),
    quantity NUMERIC(38, 5)
)

IF EXISTS (SELECT TOP(1) id FROM @historicaltimeperiods)
BEGIN
    INSERT INTO #totalProductionQty(modeluid, timeperiodid, eventtypeuid, eventcategoryuid, duration, quantity)
        SELECT
            pc.fromuid,
            tp.id AS timeperiodid,
            ape.eventtypeuid,
            ape.eventcategoryuid,
            SUM(quantitytime/ppd.divisor) AS duration,
            SUM(quantity) AS quantity
        FROM
            aggregatedproductionevent ape
            INNER JOIN @parent_children pc ON ape.modeluid = pc.touid
            INNER JOIN @historicaltimeperiods tp ON (ape.eventdatetime >= FORMAT(tp.starttime, 'yyyy-MM-dd HH:00:00') AND ape.eventdatetime < FORMAT(tp.endtime, 'yyyy-MM-dd HH:00:00'))
            CROSS APPLY GetParallelPacemakerDivisor(ape.modeluid, ape.joborderuid, @isWorkUnitOnly) AS ppd
        WHERE
            ((@shiftinstanceuid IS NULL) OR (@shiftinstanceuid = ape.shiftinstanceuid)) AND
            ((@materialmasteruid IS NULL) OR (@materialmasteruid = ape.materialmasteruid))
        GROUP BY
            pc.fromuid,
            tp.id,
            ape.eventtypeuid,
            ape.eventcategoryuid
END

IF EXISTS (SELECT TOP(1) id FROM @recenttimeperiods)
BEGIN
    INSERT INTO #totalProductionQty(modeluid, timeperiodid, eventtypeuid, eventcategoryuid, duration, quantity)
        SELECT
            pc.fromuid,
            tp.id AS timeperiodid,
            pe.eventtypeuid,
            pe.eventcategoryuid,
            SUM(COALESCE(pe.quantity * pe.idealcycletime, 0)/ppd.divisor) AS duration,
            SUM(COALESCE(pe.quantity, 0)) AS quantity
        FROM
            productionevent pe
            INNER JOIN @parent_children pc ON pe.modeluid = pc.touid
            INNER JOIN @recenttimeperiods tp ON (tp.starttime <= pe.eventtime AND pe.eventtime < tp.endtime)
            CROSS APPLY GetParallelPacemakerDivisor(pe.modeluid, pe.joborderuid, @isWorkUnitOnly) AS ppd
        WHERE
            (pe.shiftinstanceuid IS NOT NULL OR	pe.joborderuid IS NOT NULL) AND
            ((@shiftinstanceuid IS NULL) OR (@shiftinstanceuid = pe.shiftinstanceuid)) AND
            ((@materialmasteruid IS NULL) OR (@materialmasteruid = pe.materialmasteruid))
        GROUP BY
            pc.fromuid,
            tp.id,
            pe.eventtypeuid,
            pe.eventcategoryuid
END

SELECT
    tpq.modeluid AS modeluid,
    tpq.timeperiodid AS timeperiodid,
    rt.name AS eventtypename,
    rc.name AS eventcategoryname,
    tpq.eventtypeuid AS eventtypeuid,
    tpq.eventcategoryuid AS eventcategoryuid,
    SUM(tpq.duration) AS duration,
    SUM(tpq.quantity) AS quantity
FROM
    #totalProductionQty tpq,
    reasoncategory rc,
    reasontype rt
WHERE
    rc.uid = tpq.eventcategoryuid AND
    rt.uid = rc.reasontypeuid
GROUP BY
    tpq.modeluid,
    tpq.timeperiodid,
    rt.name,
    rc.name,
    tpq.eventtypeuid,
    tpq.eventcategoryuid;]]></sql><timeout>0.0</timeout></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="SQLCommand" name="CreateGetProductionQuantity"><ConfigurationTables><ConfigurationTable dataShapeName="" description="SQLCommand" isMultiRow="false" name="Query" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="NUMBER" description="maxItems" name="maxItems" ordinal="0"/><FieldDefinition baseType="STRING" description="sql" name="sql" ordinal="0"/><FieldDefinition baseType="NUMBER" description="timeout" name="timeout" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><maxItems>500.0</maxItems><sql><![CDATA[CREATE OR ALTER FUNCTION GetProductionQuantity(
    @timeperiods timeperiodtype READONLY,
    @equipmentinfo equipmentinfotype READONLY,
    @shiftinstanceuid BIGINT,
    @materialmasteruid BIGINT,
    @lastAggregatedDays timeperiodtype READONLY)
RETURNS TABLE
AS RETURN
    SELECT
        A.modeluid AS equipmentuid,
        A.timeperiodid,
        A.eventtypeuid,
        A.eventcategoryuid,
        SUM(quantity) AS quantity,
        SUM(quantitytime) AS quantitytime,
		A.joborderuid
    FROM (
        SELECT
            pe.modeluid,
            tp.id AS timeperiodid,
            pe.eventtypeuid,
            pe.eventcategoryuid,
            quantity,
            quantitytime,
			pe.joborderuid
        FROM
            aggregatedproductionevent pe
            INNER JOIN @equipmentinfo ei ON pe.modeluid = ei.equipmentuid
            INNER JOIN @timeperiods tp ON (pe.eventdatetime >= FORMAT(tp.starttime, 'yyyy-MM-dd HH:00:00') AND pe.eventdatetime < FORMAT(tp.endtime, 'yyyy-MM-dd HH:00:00'))
        WHERE
            (@shiftinstanceuid IS NULL OR pe.shiftinstanceuid = @shiftinstanceuid) AND
            (@materialmasteruid IS NULL OR pe.materialmasteruid = @materialmasteruid)

            UNION ALL

        SELECT
            pe.modeluid,
            lads.id AS timeperiodid,
            pe.eventtypeuid,
            pe.eventcategoryuid,
            COALESCE(pe.quantity, 0) AS quantity,
            COALESCE(pe.quantity * pe.idealcycletime, 0) AS quantitytime,
			pe.joborderuid
        FROM
            productionevent pe
            INNER JOIN @equipmentinfo ei ON pe.modeluid = ei.equipmentuid
            INNER JOIN @lastAggregatedDays lads ON (lads.starttime <= pe.eventtime AND pe.eventtime < lads.endtime)
        WHERE
            lads.starttime < lads.endtime AND
            (pe.shiftinstanceuid IS NOT NULL OR pe.joborderuid IS NOT NULL) AND
            (@shiftinstanceuid IS NULL OR pe.shiftinstanceuid = @shiftinstanceuid) AND
            (@materialmasteruid IS NULL OR pe.materialmasteruid = @materialmasteruid)
    ) A
    GROUP BY
        A.modeluid,
        A.timeperiodid,
        A.eventtypeuid,
        A.eventcategoryuid,
		A.joborderuid]]></sql><timeout>60.0</timeout></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="SQLCommand" name="CreateGetRunningJobOrderPeriods"><ConfigurationTables><ConfigurationTable dataShapeName="" description="SQLCommand" isMultiRow="false" name="Query" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="NUMBER" description="maxItems" name="maxItems" ordinal="0"/><FieldDefinition baseType="STRING" description="sql" name="sql" ordinal="0"/><FieldDefinition baseType="NUMBER" description="timeout" name="timeout" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><maxItems>500.0</maxItems><sql><![CDATA[CREATE OR ALTER FUNCTION GetRunningJobOrderPeriods(
    @starttime DATETIMEOFFSET,
    @endtime DATETIMEOFFSET,
    @equipmentinfo AS equipmentinfotype READONLY)
RETURNS TABLE
AS RETURN
    WITH workunits AS (
        SELECT ml2.childuid FROM modellink ml2
        JOIN model m ON ml2.childuid = m.uid
        WHERE parentuid IN (SELECT parentuid FROM modellink ml JOIN @equipmentinfo ei ON ml.childuid = ei.equipmentuid)
        AND m.ispacemaker = 1
    )
    SELECT 
        B.modeluid,
        B.joborderuid,
        B.starttime,
        B.endtime
    FROM (
        SELECT          
            A.modeluid,
            A.joborderuid,
            A.status,
            A.eventtime AS starttime,
            LEAD(A.eventtime, 1, @endtime) OVER (PARTITION BY A.modeluid, A.joborderuid ORDER BY A.eventtime ASC, A.inserttimestamp ASC) AS endtime
        FROM (
            SELECT
                joer.modeluid,
                joer.joborderuid,
                ds.name AS status,
                joer.timestamp AS eventtime,
                joer.inserttimestamp
            FROM
                joborderexecutionresponse AS joer 
                INNER JOIN @equipmentinfo ei ON joer.modeluid IN (SELECT * FROM workunits)
                INNER JOIN dispatchstatus AS ds ON joer.status = ds.uid
        ) A
    ) B
    WHERE B.starttime <= @endtime AND B.endtime >= @starttime AND status = 'Running']]></sql><timeout>60.0</timeout></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="SQLCommand" name="CreateGetRunningJobOrdersForModel"><ConfigurationTables><ConfigurationTable dataShapeName="" description="SQLCommand" isMultiRow="false" name="Query" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="NUMBER" description="maxItems" name="maxItems" ordinal="0"/><FieldDefinition baseType="STRING" description="sql" name="sql" ordinal="0"/><FieldDefinition baseType="NUMBER" description="timeout" name="timeout" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><maxItems>500.0</maxItems><sql><![CDATA[CREATE OR ALTER FUNCTION GetRunningJobOrdersForModel (
    @modeluid BIGINT,
    @timestamp DATETIMEOFFSET,
    @jobOrderLookBackRange INT = -1)
RETURNS TABLE
AS RETURN
SELECT joborderuid, materialdefinitionuid, materialmasteruid, modeluid, status, timestamp, inserttimestamp, A.uid
	FROM (
		SELECT wder.joborderuid, joer.materialdefinitionuid, joer.materialmasteruid, wder.modeluid, wder.status, wder.timestamp, wder.inserttimestamp, wder.uid,
		       ROW_NUMBER() OVER(PARTITION BY wder.joborderuid ORDER BY wder.timestamp DESC, wder.inserttimestamp DESC) AS rownum
		FROM workdefinitionexecutionresponse wder
		LEFT JOIN joborderexecutionresponse joer ON joer.joborderuid = wder.joborderuid
		WHERE wder.modeluid = @modeluid AND (@jobOrderLookBackRange < 0 OR wder.timestamp >= DATEADD(DAY, -@jobOrderLookBackRange, @timestamp)) AND wder.timestamp < @timestamp AND joer.materialdefinitionuid IS NOT NULL
	) A
	LEFT JOIN dispatchstatus ds ON (A.status = ds.uid)
	WHERE rownum = 1 AND ds.name = 'Running']]></sql><timeout>60.0</timeout></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="SQLCommand" name="CreateGetTargetQuantityMultiplier"><ConfigurationTables><ConfigurationTable dataShapeName="" description="SQLCommand" isMultiRow="false" name="Query" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="NUMBER" description="maxItems" name="maxItems" ordinal="0"/><FieldDefinition baseType="STRING" description="sql" name="sql" ordinal="0"/><FieldDefinition baseType="NUMBER" description="timeout" name="timeout" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><maxItems>500.0</maxItems><sql><![CDATA[CREATE OR ALTER PROCEDURE GetTargetQuantityMultiplier
(
    @equipmentuid BIGINT,
    @joborderuid BIGINT
)
AS

	DECLARE @result FLOAT = 1;
	DECLARE @equipmentquantity NUMERIC(18,5);
	DECLARE @initialequipmentquantity NUMERIC(18,5);
	DECLARE @parentworkdefinitionuid BIGINT;

	-- Get work Defintion uid
	SELECT @parentworkdefinitionuid = workdefinitionuid FROM joborderworkdefinitionlink WHERE joborderuid = @joborderuid

	-- Get the [workdefinitionmaterialspecification] of the initial and parameter work units
	SELECT @equipmentquantity = wdms.quantity 
		FROM workdefinitionprocessingresourcespecification wdprs
		JOIN processingresource pr ON pr.uid = wdprs.processingresourceuid
		JOIN workdefinitionmaterialspecification wdms ON wdprs.workdefinitionuid = wdms.workdefinitionuid 
		WHERE wdprs.workdefinitionuid IN (SELECT childuid FROM workdefinitionlink WHERE parentuid = @parentworkdefinitionuid)
		AND pr.modeluid = @equipmentuid


	SELECT @initialequipmentquantity = wdms.quantity 
		FROM workdefinitionmaterialspecification wdms
		WHERE wdms.workdefinitionuid =  @parentworkdefinitionuid

	-- Divide
	SELECT  @equipmentquantity/@initialequipmentquantity AS multiplier]]></sql><timeout>60.0</timeout></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="SQLCommand" name="CreateGetTrend2"><ConfigurationTables><ConfigurationTable dataShapeName="" description="SQLCommand" isMultiRow="false" name="Query" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="NUMBER" description="maxItems" name="maxItems" ordinal="0"/><FieldDefinition baseType="STRING" description="sql" name="sql" ordinal="0"/><FieldDefinition baseType="NUMBER" description="timeout" name="timeout" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><maxItems>500.0</maxItems><sql><![CDATA[CREATE OR ALTER PROCEDURE GetTrend2(
    @starttime DATETIMEOFFSET,
    @endtime DATETIMEOFFSET,
    @modeluid BIGINT,
    @adjustingtimeoffset INT = 0,
    @reasoncategoryuid BIGINT,
    @reasontreenodeuid BIGINT,
    @shiftinstanceuid BIGINT,
    @materialmasteruid BIGINT,
    @reasonmodeluid BIGINT,
    @reasontypeuid BIGINT,
    @eventcategoryuid BIGINT,
    @eventtypeuids AS uidlist READONLY,
    @excludeaggregatedata AS BIT = 'FALSE',
    @minEventAgeInDays INT = 14
)
AS
DECLARE @isWorkUnitOnly BIT = CASE WHEN (SELECT modeltypeuid FROM model WHERE uid = @modeluid) = 6 THEN 1 ELSE 0 END

SET @adjustingtimeoffset = COALESCE(@adjustingtimeoffset, 0)
DECLARE @currenttime DATETIMEOFFSET = GETDATE()
SET @endtime = IIF(@endtime < @currenttime, @endtime, @currenttime) 

DECLARE @aggregatedstarttime DATETIMEOFFSET, @aggregatedendtime DATETIMEOFFSET, @aggregatedendtimemax DATETIMEOFFSET;
SELECT @aggregatedendtimemax = DATEADD(HOUR, 1, MAX(eventdatetimemax))
FROM 
    (
        SELECT MAX(eventdatetime) AS eventdatetimemax 
        FROM aggregatedavailabilityevent WHERE eventdatetime >= @starttime AND eventdatetime < @endtime 
        UNION ALL
        SELECT MAX(eventdatetime) AS eventdatetimemax
        FROM aggregatedlossevent WHERE eventdatetime >= @starttime AND eventdatetime < @endtime
        UNION ALL
        SELECT MAX(eventdatetime) AS eventdatetimemax
        FROM aggregatedproductionevent WHERE eventdatetime >= @starttime AND eventdatetime < @endtime
    ) ae

IF (@excludeaggregatedata = 'FALSE') AND (@aggregatedendtimemax IS NOT NULL) AND (@reasonmodeluid IS NULL) AND (@reasontreenodeuid IS NULL)
BEGIN
    -- to align with waterfall
    -- shift to the beginning of the hour when we want to query aggregated data
    -- starttime needs to be updated to start the time periods on the correct date
    SET @starttime = FORMAT(@starttime, 'yyyy-MM-dd HH:00:00');
    SET @aggregatedstarttime = @starttime;
    SET @aggregatedendtime = FORMAT(@endtime, 'yyyy-MM-dd HH:00:00');
END

-- startdate and enddate for time periods
DECLARE @startdate DATETIMEOFFSET = SWITCHOFFSET(@starttime, @adjustingtimeoffset);
DECLARE @enddate DATETIMEOFFSET = SWITCHOFFSET(@endtime, @adjustingtimeoffset);

DECLARE @timeperiods timeperiodtype
DECLARE @formattedinitialendtime DATETIMEOFFSET = FORMAT(DATEADD(DAY, 1, @startdate), 'yyyy-MM-dd 00:00:00 zzz');

WITH dateTable(starttime, endtime) AS (
    SELECT 
        CAST(@startdate AS DATETIMEOFFSET),
        CAST(IIF(@formattedinitialendtime > @enddate, @enddate, @formattedinitialendtime) AS DATETIMEOFFSET)
    UNION ALL
    SELECT
        endtime,
        IIF(DATEADD(DAY, 1, endtime) > @enddate, @enddate, DATEADD(DAY, 1, endtime))
    FROM dateTable
    WHERE endtime < @enddate
)
INSERT INTO @timeperiods
SELECT
    ROW_NUMBER() OVER(ORDER BY starttime ASC) AS id,
    starttime,
    endtime
FROM 
    dateTable
OPTION (MAXRECURSION 0)

DECLARE @haseventtypeuids BIT = IIF((NOT EXISTS (SELECT TOP 1 1 FROM @eventtypeuids)), 0, 1)

DECLARE @downeventtypeuid BIGINT, @speedlosseventtypeuid BIGINT, @scrapeventtypeuid BIGINT, @productioneventtypeuid BIGINT
SELECT TOP 1 @downeventtypeuid = uid FROM reasontype WHERE name = 'Down'
SELECT TOP 1 @speedlosseventtypeuid = uid FROM reasontype WHERE name = 'SpeedLoss'
SELECT TOP 1 @scrapeventtypeuid = uid FROM reasontype WHERE name = 'Scrap'
SELECT TOP 1 @productioneventtypeuid = uid FROM reasontype WHERE name = 'Production'

-- Setup uidmap for calling GetTotalUnplannedProductionDuration
DECLARE @parent_children uidmap;
INSERT INTO @parent_children(touid, fromuid)
    SELECT treemodels.childuid, @modelUid
    FROM GetTreeModels(@modelUid, 0) treemodels
    WHERE treemodels.childtype = 'WorkCenter';

DECLARE @equipmentinfo equipmentinfotype
INSERT INTO @equipmentinfo(equipmentuid)
SELECT childuid
FROM GetTreeModels(@modelUid, CASE WHEN @isWorkUnitOnly = 1 THEN 0 ELSE 1 END)
WHERE childtype = 'Workunit';

DECLARE @pacemakers AS equipmentinfotype
INSERT @pacemakers(equipmentuid)
SELECT childuid AS modeluid
FROM GetTreeModels(@modelUid, CASE WHEN @isWorkUnitOnly = 1 THEN 0 ELSE 1 END) treemodels

/* RETRIEVE additional filter information */
DECLARE @reasonName NVARCHAR(MAX) = '' COLLATE DATABASE_DEFAULT
SELECT 
    @reasonName = reason.name 
FROM 
    reason, reasontreenode 
WHERE 
    reason.uid = reasontreenode.reasonuid AND 
    reasontreenode.uid = @reasontreenodeuid

DROP TABLE IF EXISTS #reasonNodes
CREATE TABLE #reasonNodes(uid BIGINT)

;WITH childNodes(uid) AS (
    SELECT 
        uid
    FROM 
        reasontreenode
    WHERE (
        (@reasontreenodeuid IS NOT NULL AND parentreasontreenodeuid = @reasontreenodeuid) OR
        (@reasontreenodeuid IS NULL AND parentreasontreenodeuid IS NULL)
    )

    UNION ALL

    SELECT
        t.uid
    FROM  
        reasontreenode t
        INNER JOIN childNodes ON childNodes.uid = t.parentreasontreenodeuid
)
INSERT INTO #reasonNodes(uid)
SELECT
    r.uid
FROM
    reasontreenode r
WHERE      
    @reasontreenodeuid IS NOT NULL AND uid = @reasontreenodeuid
      
UNION ALL

SELECT
    childNodes.uid
FROM
    childNodes

DECLARE @totaltime BIGINT
-- Total time per day: 24h X number of pacemakers in the filter
SET @totaltime =  ROUND((SELECT COUNT(1) FROM @pacemakers) * DATEDIFF_BIG(SECOND, @startdate, DATEADD(DAY, 1, @startdate)), 0)

DROP TABLE IF EXISTS #aggregatemetric
CREATE TABLE #aggregatemetric(
    eventcategoryuid BIGINT,
    eventtime DATETIMEOFFSET,
    lasteventtime DATETIMEOFFSET,
    eventtypeuid BIGINT,
    unplannedduration BIGINT,
    availabilityeventduration BIGINT,
    losseventduration BIGINT,
    productiontime BIGINT,
    scraptime BIGINT,
    totaltime BIGINT,
    eventcount BIGINT
)
DROP TABLE IF EXISTS #aggregatecount
CREATE TABLE #aggregatecount(
    eventcount BIGINT,
    eventtime DATETIMEOFFSET
)

INSERT #aggregatecount(
    eventcount,
    eventtime
)
SELECT
    SUM(b.eventcount) AS eventcount,
    b.eventtime AS eventtime
FROM (
    SELECT
        SUM(a.eventcount) AS eventcount,
        a.eventtime AS eventtime
    FROM (
        SELECT
            COUNT(*) as eventcount,
            FORMAT(SWITCHOFFSET(ae.eventtime, @adjustingtimeoffset), 'yyyy-MM-dd 00:00:00 zzz') AS eventtime
        FROM
            availabilityevent ae
            INNER JOIN @equipmentinfo ei ON ae.modeluid = ei.equipmentuid
        WHERE
            eventtime >= @starttime AND  eventtime < @endtime
            AND ((@eventcategoryuid IS NULL) OR (ae.eventcategoryuid = @eventcategoryuid))
            AND ((@shiftinstanceuid IS NULL) OR (ae.shiftinstanceuid = @shiftinstanceuid))
            AND ((@materialmasteruid IS NULL) OR (ae.materialmasteruid = @materialmasteruid))
            AND ((@reasoncategoryuid IS NULL) OR (ae.reasoncategoryuid = @reasoncategoryuid))
            AND ((@reasontypeuid IS NULL) OR (ae.reasontypeuid = @reasontypeuid))
            AND ((@reasonmodeluid IS NULL) OR (ae.reasonmodeluid = @reasonmodeluid))
            AND ((@reasontreenodeuid IS NULL) OR (ae.reasontreenodeuid IN (SELECT uid FROM #reasonNodes)))
        GROUP BY
            FORMAT(SWITCHOFFSET(ae.eventtime, @adjustingtimeoffset), 'yyyy-MM-dd 00:00:00 zzz')
        ) a
    GROUP BY
        a.eventtime

    UNION ALL

    SELECT
        SUM(a.eventcount) AS eventcount,
        a.eventtime AS eventtime
    FROM (
        SELECT
            COUNT(*) as eventcount,
            FORMAT(SWITCHOFFSET(ae.eventtime, @adjustingtimeoffset), 'yyyy-MM-dd 00:00:00 zzz') AS eventtime
        FROM
            lossevent ae INNER JOIN @equipmentinfo ei ON ae.modeluid = ei.equipmentuid
        WHERE
            eventtime >= @starttime AND  eventtime < @endtime
            AND ((@eventcategoryuid IS NULL) OR (ae.eventcategoryuid = @eventcategoryuid))
            AND ((@shiftinstanceuid IS NULL) OR (ae.shiftinstanceuid = @shiftinstanceuid))
            AND ((@materialmasteruid IS NULL) OR (ae.materialmasteruid = @materialmasteruid))
            AND ((@reasoncategoryuid IS NULL) OR (ae.reasoncategoryuid = @reasoncategoryuid))
            AND ((@reasontypeuid IS NULL) OR (ae.reasontypeuid = @reasontypeuid))
            AND ((@reasonmodeluid IS NULL) OR (ae.reasonmodeluid = @reasonmodeluid))
            AND ((@reasontreenodeuid IS NULL) OR (ae.reasontreenodeuid IN (SELECT uid FROM #reasonNodes)))
        GROUP BY
            FORMAT(SWITCHOFFSET(ae.eventtime, @adjustingtimeoffset), 'yyyy-MM-dd 00:00:00 zzz')
        ) a
    GROUP BY
        a.eventtime

    UNION ALL

    SELECT
        SUM(a.eventcount) AS eventcount,
        a.eventtime AS eventtime
    FROM (
        SELECT
            COUNT(*) as eventcount,
            FORMAT(SWITCHOFFSET(ae.eventtime, @adjustingtimeoffset), 'yyyy-MM-dd 00:00:00 zzz') AS eventtime
        FROM
            productionevent ae INNER JOIN @equipmentinfo ei ON ae.modeluid = ei.equipmentuid
        WHERE
            eventtime >= @starttime AND  eventtime < @endtime
            AND ((@eventcategoryuid IS NULL) OR (ae.eventcategoryuid = @eventcategoryuid))
            AND ((@shiftinstanceuid IS NULL) OR (ae.shiftinstanceuid = @shiftinstanceuid))
            AND ((@materialmasteruid IS NULL) OR (ae.materialmasteruid = @materialmasteruid))
            AND ((@reasoncategoryuid IS NULL) OR (ae.reasoncategoryuid = @reasoncategoryuid))
            AND ((@reasontypeuid IS NULL) OR (ae.reasontypeuid = @reasontypeuid))
            AND ((@reasonmodeluid IS NULL) OR (ae.reasonmodeluid = @reasonmodeluid))
            AND ((@reasontreenodeuid IS NULL) OR (ae.reasontreenodeuid IN (SELECT uid FROM #reasonNodes)))
        GROUP BY
            FORMAT(SWITCHOFFSET(ae.eventtime, @adjustingtimeoffset), 'yyyy-MM-dd 00:00:00 zzz')
        ) a
    GROUP BY
        a.eventtime
    ) b
GROUP BY b.eventtime


DECLARE @postaggregatedstarttime DATETIMEOFFSET, @postaggregatedendtime DATETIMEOFFSET

IF (@aggregatedstarttime IS NOT NULL) AND (@aggregatedendtime IS NOT NULL) AND (@reasonmodeluid IS NULL) AND (@reasontreenodeuid IS NULL)
    BEGIN
    IF (@aggregatedendtimemax < @endtime)
        BEGIN
        SET @postaggregatedstarttime =  @aggregatedendtimemax
        SET @postaggregatedendtime = @endtime
        END
    END
ELSE
    BEGIN
    SET @postaggregatedstarttime = @starttime
    SET @postaggregatedendtime = @endtime
    END

-- Use aggregate data if all the extra filter is null
IF (@reasontreenodeuid IS NULL) AND (@reasonmodeluid IS NULL)
BEGIN
    INSERT #aggregatemetric(
        eventcategoryuid,
        eventtime,
        lasteventtime,
        eventtypeuid,
        unplannedduration,
        availabilityeventduration,
        losseventduration,
        productiontime,
        scraptime,
        totaltime,
        eventcount
    )
    SELECT
            eventcategoryuid,
            eventtime,
            MAX(lasteventtime) AS lasteventtime,
            eventtypeuid,
            SUM(unplannedduration) AS unplannedduration,
            SUM(availabilityeventduration) AS availabilityeventduration,
            SUM(losseventduration) AS losseventduration,
            SUM(productiontime) AS productiontime,
            SUM(scraptime) AS scraptime,
            0 AS totaltime,
            0 AS eventcount
    FROM(
        SELECT
            FORMAT(SWITCHOFFSET(aae.eventdatetime, @adjustingtimeoffset), 'yyyy-MM-dd 00:00:00 zzz') as eventtime,
            MAX(aae.eventdatetime) AS lasteventtime,
            0 AS unplannedduration,
            sum(aae.duration/ppd.divisor) AS availabilityeventduration,
            0 AS losseventduration,
            0 AS productiontime,
            0 AS scraptime,
            eventtypeuid,
            eventcategoryuid,
            0 AS eventcount
        FROM
            aggregatedavailabilityevent aae
            INNER JOIN @equipmentinfo ei ON aae.modeluid = ei.equipmentuid
	    CROSS APPLY GetParallelPacemakerDivisor(aae.modeluid, aae.joborderuid,@isWorkUnitOnly) AS ppd
        WHERE
            aae.eventdatetime >= @aggregatedstarttime AND aae.eventdatetime < @aggregatedendtime
            AND ((@shiftinstanceuid IS NULL) OR (aae.shiftinstanceuid = @shiftinstanceuid))
            AND ((@materialmasteruid IS NULL) OR (aae.materialmasteruid = @materialmasteruid))
            AND ((@reasoncategoryuid IS NULL) OR (aae.reasoncategoryuid = @reasoncategoryuid))
            AND ((@reasontypeuid IS NULL) OR (aae.reasontypeuid = @reasontypeuid))
        GROUP BY
            FORMAT(SWITCHOFFSET(aae.eventdatetime, @adjustingtimeoffset), 'yyyy-MM-dd 00:00:00 zzz'),
            eventtypeuid,
            eventcategoryuid

        UNION ALL

        SELECT
            FORMAT(SWITCHOFFSET(ale.eventdatetime, @adjustingtimeoffset), 'yyyy-MM-dd 00:00:00 zzz') as eventtime,
            MAX(ale.eventdatetime) AS lasteventtime,
            0 AS unplannedduration,
            0 AS availabilityeventduration,
            sum(ale.lossvalue/ppd.divisor) AS losseventduration,
            0 AS productiontime,
            0 AS scraptime,
            eventtypeuid,
            eventcategoryuid,
            0 AS eventcount 
        FROM 
            aggregatedlossevent ale 
            INNER JOIN @equipmentinfo ei ON ale.modeluid = ei.equipmentuid
	    CROSS APPLY GetParallelPacemakerDivisor(ale.modeluid, ale.joborderuid,@isWorkUnitOnly) AS ppd
        WHERE
            ale.eventdatetime >= @aggregatedstarttime AND ale.eventdatetime < @aggregatedendtime
            AND ((@shiftinstanceuid IS NULL) OR (ale.shiftinstanceuid = @shiftinstanceuid))
            AND ((@materialmasteruid IS NULL) OR (ale.materialmasteruid = @materialmasteruid))
            AND ((@reasoncategoryuid IS NULL) OR (ale.reasoncategoryuid = @reasoncategoryuid))
            AND ((@reasontypeuid IS NULL) OR (ale.reasontypeuid = @reasontypeuid))
        GROUP BY
            FORMAT(SWITCHOFFSET(ale.eventdatetime, @adjustingtimeoffset), 'yyyy-MM-dd 00:00:00 zzz'),
            eventtypeuid,
            eventcategoryuid

        UNION ALL

        SELECT
            FORMAT(SWITCHOFFSET(ape.eventdatetime, @adjustingtimeoffset), 'yyyy-MM-dd 00:00:00 zzz') as eventtime,
            MAX(ape.eventdatetime) AS lasteventtime,
            0 AS unplannedduration,
            0 AS availabilityeventduration,
            0 AS losseventduration,
            IIF(eventtypeuid = @productioneventtypeuid, SUM(ape.quantitytime/ppd.divisor), 0) AS productiontime,
            IIF(eventtypeuid = @scrapeventtypeuid, SUM(ape.quantitytime/ppd.divisor), 0) AS scraptime,
            eventtypeuid,
            eventcategoryuid,
            0 AS eventcount
        FROM
            aggregatedproductionevent ape
            INNER JOIN @equipmentinfo ei ON ape.modeluid = ei.equipmentuid
	    CROSS APPLY GetParallelPacemakerDivisor(ape.modeluid, ape.joborderuid,@isWorkUnitOnly) AS ppd
        WHERE
            ape.eventdatetime >= @aggregatedstarttime AND ape.eventdatetime < @aggregatedendtime
            AND ((@shiftinstanceuid IS NULL) OR (ape.shiftinstanceuid = @shiftinstanceuid))
            AND ((@materialmasteruid IS NULL) OR (ape.materialmasteruid = @materialmasteruid))
            AND ((@reasoncategoryuid IS NULL) OR (ape.reasoncategoryuid = @reasoncategoryuid))
            AND ((@reasontypeuid IS NULL) OR (ape.reasontypeuid = @reasontypeuid))
        GROUP BY
            FORMAT(SWITCHOFFSET(ape.eventdatetime, @adjustingtimeoffset), 'yyyy-MM-dd 00:00:00 zzz'),
            eventtypeuid,
            eventcategoryuid
    )A
    GROUP BY eventtime, eventcategoryuid, eventtypeuid
    OPTION (MAXDOP 0)
END

-- Deadzone information
DROP TABLE IF EXISTS #deadZoneEvents
CREATE TABLE #deadZoneEvents (
    modeluid BIGINT,
    eventtypeuid BIGINT,
    eventcategoryuid BIGINT,
    reasontypeuid BIGINT,
    reasoncategoryuid BIGINT,
    reasontreenodeuid BIGINT,
    reasonmodeluid BIGINT,
    materialmasteruid BIGINT,
    shiftinstanceuid BIGINT,
    eventtime DATETIMEOFFSET,
    zoneid BIGINT,
    starttime DATETIMEOFFSET,
    endtime DATETIMEOFFSET
)
INSERT INTO #deadZoneEvents
SELECT
    de.modeluid,
    de.eventtypeuid,
    de.eventcategoryuid,
    de.reasontypeuid,
    de.reasoncategoryuid,
    de.reasontreenodeuid,
    de.reasonmodeluid,
    de.materialmasteruid,
    de.shiftinstanceuid,
    de.eventtime,
    de.zoneid,
    @postaggregatedstarttime,
    @postaggregatedendtime
FROM 
    GetDeadZoneEvents(@postaggregatedstarttime, @postaggregatedendtime, @equipmentinfo, @minEventAgeInDays) de

-- Getting live data
DROP TABLE IF EXISTS #livemetric
CREATE TABLE #livemetric
(
    eventcategoryuid BIGINT,
    eventtime DATETIMEOFFSET,
    eventtypeuid BIGINT,
    unplannedduration BIGINT,
    availabilityeventduration BIGINT,
    losseventduration BIGINT,
    productiontime BIGINT,
    scraptime BIGINT,
    totaltime BIGINT,
    eventcount BIGINT
)
INSERT #livemetric
SELECT
    eventcategoryuid,
    eventtime,
    eventtypeuid,
    SUM(unplannedduration) AS unplannedduration,
    SUM(availabilityeventduration) AS availabilityeventduration,
    SUM(losseventduration) AS losseventduration,
    SUM(productiontime) AS productiontime,
    SUM(scraptime) AS scraptime,
    0 AS totaltime,
    0 AS eventcount
FROM (
    SELECT
        FORMAT(SWITCHOFFSET(eventtime, @adjustingtimeoffset), 'yyyy-MM-dd 00:00:00 zzz') AS eventtime,
        0 AS unplannedduration,
        SUM(DATEDIFF(SECOND, eventtime, endtime)/ppd.divisor) AS availabilityeventduration,
        0 AS losseventduration,
        0 AS productiontime,
        0 AS scraptime,
        eventtypeuid,
        eventcategoryuid
    FROM (
        SELECT
            eventtypeuid,
            eventcategoryuid,
            IIF(tp.starttime < C.eventtime, C.eventtime, tp.starttime) AS eventtime,
            IIF(tp.endtime < C.endtime, tp.endtime, C.endtime) AS endtime,
	    C.modeluid,
	    C.joborderuid
        FROM (
            SELECT
                B.modeluid,
                B.eventtypeuid,
                B.eventcategoryuid,
                B.reasontypeuid,
                B.reasoncategoryuid,
                B.reasontreenodeuid,
                B.reasonmodeluid,
                B.materialmasteruid,
                B.shiftinstanceuid,
                IIF(B.eventtime < B.starttime, B.starttime, B.eventtime) AS eventtime,
                nexteventtime AS endtime,
		B.joborderuid
            FROM (
                SELECT
                    A.eventtime,
                    A.modeluid,
                    A.eventtypeuid,
                    A.eventcategoryuid,
                    A.reasontypeuid,
                    A.reasoncategoryuid,
                    A.reasontreenodeuid,
                    A.reasonmodeluid,
                    A.materialmasteruid,
                    A.shiftinstanceuid,
                    LEAD(A.eventtime, 1, A.endtime) OVER (PARTITION BY A.modeluid ORDER BY A.eventtime ASC) AS nexteventtime,
                    LAG(A.eventtime, 1) OVER (PARTITION BY A.modeluid ORDER BY A.eventtime ASC) AS preveventtime,
                    A.starttime,
                    A.endtime,
		    A.joborderuid
                FROM (
                    SELECT
                        ae.eventtime,
                        ae.modeluid,
                        ae.eventtypeuid,
                        ae.eventcategoryuid,
                        ae.reasontypeuid,
                        ae.reasoncategoryuid,
                        ae.reasontreenodeuid,
                        ae.reasonmodeluid,
                        ae.materialmasteruid,
                        ae.shiftinstanceuid,
                        @postaggregatedstarttime AS starttime,
                        @postaggregatedendtime AS endtime,
			ae.joborderuid
                    FROM
                        availabilityevent ae 
                        INNER JOIN @equipmentinfo ei ON ae.modeluid = ei.equipmentuid
                    WHERE
                        (eventtime >= DATEADD(DAY, -@minEventAgeInDays, @postaggregatedstarttime) AND eventtime < @postaggregatedendtime)

                    UNION ALL

                    SELECT
                        eventtime,
                        modeluid,
                        eventtypeuid,
                        eventcategoryuid,
                        reasontypeuid,
                        reasoncategoryuid,
                        reasontreenodeuid,
                        reasonmodeluid,
                        materialmasteruid,
                        shiftinstanceuid,
                        starttime,
                        endtime,
			0 as joborderuid
                    FROM
                        #deadZoneEvents
                ) A
            ) B
            WHERE
                B.eventtime < B.endtime AND B.nexteventtime > B.starttime
        ) C INNER JOIN @timeperiods tp ON tp.starttime < C.endtime AND tp.endtime > C.eventtime
        WHERE
            ((@eventcategoryuid IS NULL) OR (C.eventcategoryuid = @eventcategoryuid)) AND C.eventcategoryuid != -1
            AND ((@shiftinstanceuid IS NULL) OR (C.shiftinstanceuid = @shiftinstanceuid))
            AND ((@materialmasteruid IS NULL) OR (C.materialmasteruid = @materialmasteruid))
            AND ((@reasoncategoryuid IS NULL) OR (C.reasoncategoryuid = @reasoncategoryuid))
            AND ((@reasonmodeluid IS NULL) OR (C.reasonmodeluid = @reasonmodeluid))
            AND ((@reasontypeuid IS NULL) OR (C.reasontypeuid = @reasontypeuid))
            AND ((@reasontreenodeuid IS NULL) OR (C.reasontreenodeuid IN (SELECT uid FROM #reasonNodes)))
            AND NOT EXISTS (
                SELECT 1
                FROM #deadZoneEvents dze
                GROUP BY dze.modeluid, dze.zoneid
                HAVING
                    C.modeluid = dze.modeluid AND
                    C.eventtime >= MIN(eventtime) AND
                    C.eventtime < MAX(eventtime)
            )
        ) D
    	CROSS APPLY GetParallelPacemakerDivisor(D.modeluid, D.joborderuid,@isWorkUnitOnly) AS ppd 
    GROUP BY
        FORMAT(SWITCHOFFSET(eventtime, @adjustingtimeoffset), 'yyyy-MM-dd 00:00:00 zzz'),
        eventtypeuid,
        eventcategoryuid

    UNION ALL

    SELECT
        FORMAT(SWITCHOFFSET(le.eventtime, @adjustingtimeoffset), 'yyyy-MM-dd 00:00:00 zzz') as eventtime,
        0 AS unplannedduration,
        0 AS availabilityeventduration,
        sum(le.lossvalue/ppd.divisor) AS losseventduration,
        0 AS productiontime,
        0 AS scraptime,
        eventtypeuid,
        eventcategoryuid
    FROM 
        lossevent le 
        INNER JOIN @equipmentinfo ei ON le.modeluid = ei.equipmentuid
        CROSS APPLY GetParallelPacemakerDivisor(le.modeluid, le.joborderuid,@isWorkUnitOnly) AS ppd 
    WHERE
        (le.eventtime >= @postaggregatedstarttime AND le.eventtime < @postaggregatedendtime)
        AND ((@eventcategoryuid IS NULL) OR (le.eventcategoryuid = @eventcategoryuid))
        AND ((@shiftinstanceuid IS NULL) OR (le.shiftinstanceuid = @shiftinstanceuid))
        AND ((@materialmasteruid IS NULL) OR (le.materialmasteruid = @materialmasteruid))
        AND ((@reasoncategoryuid IS NULL) OR (le.reasoncategoryuid = @reasoncategoryuid))
        AND ((@reasonmodeluid IS NULL) OR (le.reasonmodeluid = @reasonmodeluid))
        AND ((@reasontypeuid IS NULL) OR (le.reasontypeuid = @reasontypeuid))
        AND ((@reasontreenodeuid IS NULL) OR (le.reasontreenodeuid IN (SELECT uid FROM #reasonNodes)))
        AND (le.shiftinstanceuid IS NOT NULL OR le.joborderuid IS NOT NULL)
    GROUP BY
        FORMAT(SWITCHOFFSET(le.eventtime, @adjustingtimeoffset), 'yyyy-MM-dd 00:00:00 zzz'),
        le.eventtypeuid,
        le.eventcategoryuid
            
    UNION ALL

    SELECT
        FORMAT(SWITCHOFFSET(pe.eventtime, @adjustingtimeoffset), 'yyyy-MM-dd 00:00:00 zzz') as eventtime,
        0 AS unplannedduration,
        0 AS availabilityeventduration,
        0 AS losseventduration,
        IIF(eventtypeuid = @productioneventtypeuid ,sum(COALESCE(pe.quantity * pe.idealcycletime, 0)/ppd.divisor), 0) AS productiontime,
        IIF(eventtypeuid = @scrapeventtypeuid ,sum(COALESCE(pe.quantity * pe.idealcycletime, 0)/ppd.divisor), 0) AS scraptime,
        eventtypeuid,
        pe.eventcategoryuid
    FROM 
        productionevent pe 
        INNER JOIN @equipmentinfo ei ON pe.modeluid = ei.equipmentuid
        CROSS APPLY GetParallelPacemakerDivisor(pe.modeluid, pe.joborderuid,@isWorkUnitOnly) AS ppd 
    WHERE
        (pe.eventtime >= @postaggregatedstarttime AND pe.eventtime < @postaggregatedendtime)
        AND ((@eventcategoryuid IS NULL) OR (pe.eventcategoryuid = @eventcategoryuid))
        AND ((@shiftinstanceuid IS NULL) OR (pe.shiftinstanceuid = @shiftinstanceuid))
        AND ((@materialmasteruid IS NULL) OR (pe.materialmasteruid = @materialmasteruid))
        AND ((@reasoncategoryuid IS NULL) OR (pe.reasoncategoryuid = @reasoncategoryuid))
        AND ((@reasonmodeluid IS NULL) OR (pe.reasonmodeluid = @reasonmodeluid))
        AND ((@reasontypeuid IS NULL) OR (pe.reasontypeuid = @reasontypeuid))
        AND ((@reasontreenodeuid IS NULL) OR (pe.reasontreenodeuid IN (SELECT uid FROM #reasonNodes)))
        AND (pe.shiftinstanceuid IS NOT NULL OR pe.joborderuid IS NOT NULL)
    GROUP BY
        FORMAT(SWITCHOFFSET(pe.eventtime, @adjustingtimeoffset), 'yyyy-MM-dd 00:00:00 zzz'),
        pe.eventtypeuid,
        pe.eventcategoryuid
    ) e
GROUP BY
    eventtime, eventcategoryuid, eventtypeuid
OPTION (MAXDOP 0)

-- Merge of the live data and aggregated
DROP TABLE IF EXISTS #mergedmetric
CREATE TABLE #mergedmetric
(
    eventcategoryuid BIGINT,
    eventtime DATETIMEOFFSET,
    eventtypeuid BIGINT,
    unplannedduration BIGINT,
    availabilityeventduration BIGINT,
    losseventduration BIGINT,
    productiontime BIGINT,
    scraptime BIGINT,
    totaltime BIGINT,
    eventcount BIGINT
)
INSERT #mergedmetric
SELECT
    eventcategoryuid AS eventcategoryuid,
    eventtime AS eventtime,
    eventtypeuid AS eventtypeuid,
    unplannedduration AS unplannedduration,
    availabilityeventduration AS availabilityeventduration,
    losseventduration AS losseventduration,
    productiontime AS productiontime,
    scraptime AS scraptime,
    totaltime AS totaltime,
    eventcount AS eventcount
FROM 
    #aggregatemetric
UNION ALL
SELECT 
    eventcategoryuid AS eventcategoryuid,
    eventtime AS eventtime,
    eventtypeuid AS eventtypeuid,
    unplannedduration AS unplannedduration,
    availabilityeventduration AS availabilityeventduration,
    losseventduration AS losseventduration,
    productiontime AS productiontime,
    scraptime AS scraptime,
    totaltime AS totaltime,
    eventcount AS eventcount
FROM 
    #livemetric

-- filtered results
DROP TABLE IF EXISTS #filtereddailymetric
CREATE TABLE #filtereddailymetric(
    eventtime DATETIMEOFFSET,
    unplannedduration BIGINT,
    availabilityeventduration BIGINT,
    losseventduration BIGINT,
    productiontime BIGINT,
    scraptime BIGINT,
    eventcount BIGINT
)
INSERT #filtereddailymetric
SELECT
    eventtime AS eventtime,
    SUM(unplannedduration) AS unplannedduration,
    SUM(availabilityeventduration) AS availabilityeventduration,
    SUM(losseventduration) AS losseventduration,
    SUM(productiontime) AS productiontime,
    SUM(scraptime) AS scraptime,
    SUM(eventcount) AS eventcount
FROM #mergedmetric
WHERE  
    ((@eventcategoryuid IS NULL) OR (eventcategoryuid = @eventcategoryuid))
    AND ((@haseventtypeuids = 0) OR (eventtypeuid IN (SELECT uid FROM @eventtypeuids)))
GROUP BY eventtime

DROP TABLE IF EXISTS #unaccountedtime
CREATE TABLE #unaccountedtime
(
    eventtime DATETIMEOFFSET,
    unplannedduration BIGINT,
    availabilityeventduration BIGINT,
    losseventduration BIGINT,
    productiontime BIGINT,
    scraptime BIGINT,
    totaltime BIGINT,
    unaccountedtime BIGINT,
    regularshiftduration DECIMAL(38, 5),
    overtimeshiftduration DECIMAL(38, 5)
)

IF (@eventcategoryuid IS NULL)
    AND (@reasontypeuid IS NULL)
    AND (@reasoncategoryuid IS NULL)
    AND (@reasontreenodeuid IS NULL)
    AND (@reasonmodeluid IS NULL)
BEGIN
    -- filtered results for unaccounted time calculations
    DROP TABLE IF EXISTS #unaccounteddailymetric
    CREATE TABLE #unaccounteddailymetric
    (
        eventtime DATETIMEOFFSET,
        unplannedduration BIGINT,
        availabilityeventduration BIGINT,
        losseventduration BIGINT,
        productiontime BIGINT,
        scraptime BIGINT
    )
    ;WITH dateTable(eventtime) AS (
        SELECT CAST(FORMAT(@startdate, 'yyyy-MM-dd 00:00:00 zzz') AS DATETIMEOFFSET)

        UNION ALL

        SELECT 
            DATEADD(DAY, 1, CAST(FORMAT(eventtime, 'yyyy-MM-dd 00:00:00 zzz') AS DATETIMEOFFSET))
        FROM 
            dateTable
        WHERE 
            DATEADD(DAY, 1, CAST(FORMAT(eventtime, 'yyyy-MM-dd 00:00:00 zzz') AS DATETIMEOFFSET)) < @enddate
    )
    INSERT #unaccounteddailymetric
    SELECT
        dt.eventtime AS eventtime,
        COALESCE(e.unplannedduration, 0) AS unplannedduration,
        COALESCE(e.availabilityeventduration, 0) AS availabilityeventduration,
        COALESCE(e.losseventduration, 0) AS losseventduration,
        COALESCE(e.productiontime, 0) AS productiontime,
        COALESCE(e.scraptime, 0) AS scraptime
    FROM (
        SELECT 
            eventtime 
        FROM 
            dateTable
        ) dt
        OUTER APPLY (           
            SELECT
                a.eventtime,
                COALESCE(SUM(a.unplannedduration), 0) AS unplannedduration,
                COALESCE(SUM(a.availabilityeventduration), 0) AS availabilityeventduration, 
                COALESCE(SUM(a.losseventduration), 0) AS losseventduration, 
                COALESCE(SUM(a.productiontime), 0) AS productiontime, 
                COALESCE(SUM(a.scraptime), 0) AS scraptime 
            FROM (
                SELECT
                    mm.eventtime AS eventtime,
                    SUM(mm.unplannedduration) AS unplannedduration,
                    SUM(mm.availabilityeventduration) AS availabilityeventduration,
                    SUM(mm.losseventduration) AS losseventduration,
                    SUM(mm.productiontime) AS productiontime,
                    SUM(mm.scraptime) AS scraptime,
                    SUM(mm.eventcount) AS eventcount
                FROM #mergedmetric mm
                WHERE  
                    (mm.eventtypeuid IN (@downeventtypeuid, @speedlosseventtypeuid, @scrapeventtypeuid, @productioneventtypeuid))
                GROUP BY mm.eventtime
                ) a 
            WHERE 
                a.eventtime = dt.eventtime
            GROUP BY a.eventtime                
        ) e
    OPTION (MAXRECURSION 0)

    DROP TABLE IF EXISTS #gettotalunplannedproductionduration_result
    CREATE TABLE #gettotalunplannedproductionduration_result
    (
        modeluid BIGINT,
        timeperiodid BIGINT,
        duration NUMERIC(38, 5),
        overtimeduration NUMERIC(38, 5)
    )
    INSERT INTO #gettotalunplannedproductionduration_result
    EXEC GetTotalUnplannedProductionDuration @parent_children, @timeperiods, DEFAULT

    DROP TABLE IF EXISTS #unplanneddurations
    CREATE TABLE #unplanneddurations(
        unplannedduration NUMERIC(38, 5),
        eventtime DATETIMEOFFSET
    )
    INSERT INTO #unplanneddurations
    SELECT
        up.duration AS unplannedduration,
        tp.starttime AS eventtime
    FROM 
        #gettotalunplannedproductionduration_result up
        INNER JOIN @timeperiods tp ON up.timeperiodid = tp.id

    DROP TABLE IF EXISTS #shiftdurations
    CREATE TABLE #shiftdurations(
        eventtime DATETIMEOFFSET,
        regularshiftduration DECIMAL(38, 5),
        overtimeshiftduration DECIMAL(38, 5)
    )
    INSERT INTO #shiftdurations
    SELECT
        tp.starttime AS eventtime,
        B.regularshiftduration AS regularshiftduration,
        B.overtimeshiftduration AS overtimeshiftduration
    FROM (
        SELECT
            A.timeperiodid,
            SUM(CASE 
                    WHEN A.isovertime = 0 OR isovertime IS NULL 
                    THEN CAST (DATEDIFF_BIG(SECOND, A.shiftstarttime, A.shiftendtime) AS DECIMAL(38, 5))
                END
            ) AS regularshiftduration,
            SUM(CASE
                    WHEN A.isovertime = 1 
                    THEN CAST (DATEDIFF_BIG(SECOND, A.shiftstarttime, A.shiftendtime) AS DECIMAL(38, 5))
                END
            ) AS overtimeshiftduration
        FROM (
            SELECT
                si.modeluid,
                uid AS shiftuid,
                isovertime,
                IIF(tp.starttime < si.actualstarttime, si.actualstarttime, tp.starttime) AS shiftstarttime,
                IIF(tp.endtime > si.actualendtime, si.actualendtime, tp.endtime) AS shiftendtime,
                tp.id AS timeperiodid
            FROM
                shiftinstance si 
                INNER JOIN @timeperiods tp ON si.actualstarttime < tp.endtime AND si.actualendtime > tp.starttime
                INNER JOIN @pacemakers ei ON si.modeluid = ei.equipmentuid
        ) A
        GROUP BY
            A.timeperiodid
            ) B INNER JOIN @timeperiods tp ON B.timeperiodid = tp.id

    DECLARE @pacemakerCount BIGINT;
    SELECT @pacemakerCount = COUNT(equipmentuid) FROM @pacemakers
    UPDATE #shiftdurations
    SET regularshiftduration = regularshiftduration/@pacemakerCount
    
    INSERT INTO #unaccountedtime
    SELECT
        eventtime,
        unplannedduration,
        availabilityeventduration,
        losseventduration,
        productiontime,
        scraptime,
        totaltime,
        COALESCE(totaltime 
                - (totaltime - COALESCE(regularshiftduration, 0)) 
                + COALESCE(unplannedduration, 0)
                + COALESCE(overtimeshiftduration, 0) 
                - (availabilityeventduration + losseventduration + productiontime + scraptime), 0) AS unaccountedtime,
        regularshiftduration,
        overtimeshiftduration
    FROM 
        (SELECT
            eventtime AS eventtime,
            COALESCE(B.unplannedduration, 0) AS unplannedduration,
            availabilityeventduration AS availabilityeventduration,
            losseventduration AS losseventduration,
            productiontime AS productiontime,
            scraptime AS scraptime,
            CASE
                WHEN eventtime = FORMAT(@enddate, 'yyyy-MM-dd 00:00:00 zzz')
                THEN CAST (DATEDIFF_BIG(SECOND, CAST(FORMAT(@enddate, 'yyyy-MM-dd 00:00:00 zzz') AS DATETIMEOFFSET), @enddate) AS DECIMAL(38, 5))
                WHEN eventtime = FORMAT(@startdate, 'yyyy-MM-dd 00:00:00 zzz')
                THEN CAST (DATEDIFF_BIG(SECOND, @startdate, DATEADD(DAY, 1, CAST(FORMAT(@startdate, 'yyyy-MM-dd 00:00:00 zzz') AS DATETIMEOFFSET))) AS DECIMAL(38, 5))
                ELSE @totaltime
            END AS totaltime,
            COALESCE(C.regularshiftduration, 0) AS regularshiftduration,
            COALESCE(C.overtimeshiftduration, 0) AS overtimeshiftduration
        FROM #unaccounteddailymetric dm
        OUTER APPLY(
            SELECT 
                COALESCE(u.unplannedduration,0) AS unplannedduration
            FROM 
                #unplanneddurations u
            WHERE 
                FORMAT(u.eventtime, 'yyyy-MM-dd 00:00:00 zzz') = dm.eventtime
        ) B
        OUTER APPLY(
            SELECT 
                COALESCE(regularshiftduration, 0) AS regularshiftduration,
                COALESCE(overtimeshiftduration, 0) AS overtimeshiftduration
            FROM 
                #shiftdurations sd
            WHERE 
                sd.eventtime = dm.eventtime
        ) C
    )E
END

DROP TABLE IF EXISTS #trendresults
CREATE TABLE #trendresults
(
    eventtime DATETIMEOFFSET,
    unplannedduration BIGINT,
    availabilityeventduration BIGINT,
    losseventduration BIGINT,
    productiontime BIGINT,
    scraptime BIGINT,
    totaltime BIGINT,
    unaccountedtime BIGINT,
    eventcount BIGINT
)
INSERT #trendresults
SELECT 
    a.eventtime AS eventtime,
    SUM(a.unplannedduration) AS unplannedduration,
    SUM(a.availabilityeventduration) AS availabilityeventduration,
    SUM(a.losseventduration) AS losseventduration,
    SUM(a.productiontime) AS productiontime,
    SUM(a.scraptime) AS scraptime,
    SUM(a.totaltime) AS totaltime,
    SUM(a.unaccountedtime) AS unaccountedtime,
    SUM(a.eventcount) AS eventcount
FROM (
    SELECT
        eventtime AS eventtime,
        0 AS unplannedduration,
        availabilityeventduration AS availabilityeventduration,
        losseventduration AS losseventduration,
        productiontime AS productiontime,
        scraptime AS scraptime,
        0 AS totaltime,
        0 AS unaccountedtime,
        eventcount AS eventcount
    FROM #filtereddailymetric fm
    UNION ALL
    SELECT
        eventtime AS eventtime,
        COALESCE(unplannedduration, 0) AS unplannedduration,
        0 AS availabilityeventduration,
        0 AS losseventduration,
        0 AS productiontime,
        0 AS scraptime,
        0 AS totaltime,
        COALESCE(unaccountedtime, 0) AS unaccountedtime,
        0 AS eventcount
    FROM #unaccountedtime u
    UNION ALL
    SELECT
        eventtime AS eventtime,
        0 AS unplannedduration,
        0 AS availabilityeventduration,
        0 AS losseventduration,
        0 AS productiontime,
        0 AS scraptime,
        0 AS totaltime,
        0 AS unaccountedtime,
        eventcount AS eventcount
    FROM #aggregatecount ac
    ) a
GROUP BY 
    a.eventtime

 --fill the empty date inside result for the trend
DROP TABLE IF EXISTS #trend2results
CREATE TABLE #trend2results
(
    eventtime DATETIMEOFFSET,
    availabilityeventduration BIGINT,
    losseventduration BIGINT,
    productiontime BIGINT,
    scraptime BIGINT,
    unaccountedtime BIGINT, 
    unplannedduration BIGINT, 
    eventcount BIGINT, 
    nodeid BIGINT,
    reasonname NVARCHAR(255)
)
;WITH dateTable(eventtime) AS (
    SELECT CAST(FORMAT(@startdate, 'yyyy-MM-dd 00:00:00 zzz') AS DATETIMEOFFSET)

    UNION ALL

    SELECT 
        DATEADD(DAY, 1, CAST(FORMAT(eventtime, 'yyyy-MM-dd 00:00:00 zzz') AS DATETIMEOFFSET))
    FROM 
        dateTable
    WHERE 
        DATEADD(DAY, 1, CAST(FORMAT(eventtime, 'yyyy-MM-dd 00:00:00 zzz') AS DATETIMEOFFSET)) < @enddate 
)
INSERT INTO #trend2results
SELECT
    dt.eventtime,
    COALESCE(e.availabilityeventduration, 0) AS availabilityeventduration,
    COALESCE(e.losseventduration, 0) AS losseventduration,
    COALESCE(e.productiontime, 0) AS productiontime,
    COALESCE(e.scraptime, 0) AS scraptime,
    COALESCE(e.unaccountedtime, 0) AS unaccountedtime,
    COALESCE(e.unplannedduration, 0) AS unplannedduration,
    COALESCE(e.eventcount, 0) AS eventCount,
    @reasontreenodeuid AS nodeid,
    @reasonname AS reasonname
FROM (
    SELECT 
        eventtime
    FROM 
        dateTable
    ) dt
    OUTER APPLY (
        SELECT 
            COALESCE(r.availabilityeventduration, 0) AS availabilityeventduration,
            COALESCE(r.losseventduration, 0) AS losseventduration,
            COALESCE(r.productiontime, 0) AS productiontime,
            COALESCE(r.scraptime, 0) AS scraptime,
            COALESCE(r.unaccountedtime, 0) AS unaccountedtime,
            COALESCE(r.unplannedduration, 0) AS unplannedduration,
            COALESCE(r.eventcount, 0) AS eventcount
        FROM 
            #trendresults r
        WHERE
            r.eventtime = dt.eventtime
    ) e
ORDER BY
    nodeid, eventtime ASC
OPTION (MAXRECURSION 0)

SELECT
    CAST(availabilityeventduration + losseventduration + scraptime + productiontime AS NUMERIC(38,5)) AS losseventvalue,
    CAST(unaccountedtime AS NUMERIC(38,5)) AS unaccountedtime,
    nodeid AS nodeid,
    reasonname AS reasonname,
    eventtime AS eventtime,
    eventCount AS eventCount
FROM 
    #trend2results]]></sql><timeout>0.0</timeout></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="SQLCommand" name="CreateGetUnRunningJobOrderPeriods"><ConfigurationTables><ConfigurationTable dataShapeName="" description="SQLCommand" isMultiRow="false" name="Query" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="NUMBER" description="maxItems" name="maxItems" ordinal="0"/><FieldDefinition baseType="STRING" description="sql" name="sql" ordinal="0"/><FieldDefinition baseType="NUMBER" description="timeout" name="timeout" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><maxItems>500.0</maxItems><sql><![CDATA[CREATE OR ALTER FUNCTION GetUnRunningJobOrderPeriods(
    @starttime DATETIMEOFFSET,
    @endtime DATETIMEOFFSET,
    @equipmentinfo AS equipmentinfotype READONLY)
RETURNS TABLE
AS RETURN
    WITH periods AS (
        SELECT
            modeluid,
            starttime,
            endtime
        FROM (
            SELECT
                A.modeluid,
                A.joborderuid,
                A.status,
                A.eventtime AS starttime,
                LEAD(A.eventtime, 1, @endtime) OVER (PARTITION BY A.modeluid, A.joborderuid ORDER BY A.eventtime ASC, A.inserttimestamp ASC) AS endtime
            FROM (
                SELECT
                    ei.equipmentuid as modeluid,
                    joer.joborderuid,
                    ds.name AS status,
                    joer.timestamp AS eventtime,
                    joer.inserttimestamp
                FROM
                    @equipmentinfo ei 
                    LEFT JOIN workdefinitionexecutionresponse AS joer ON joer.modeluid = ei.equipmentuid
                    INNER JOIN dispatchstatus AS ds ON joer.status = ds.uid
                WHERE
                    timestamp between DATEADD(WEEK, -1, @starttime) AND DATEADD(WEEK, 1, @endtime)
                ) A
            ) B
            WHERE B.starttime <= @endtime AND B.endtime >= @starttime AND B.status = 'Running'
        )
    SELECT
        modeluid,
        @starttime AS starttime,
        minstarttime AS endtime
    FROM (
        SELECT
            modeluid, MIN(starttime) AS minstarttime
        FROM
            periods
        GROUP BY
            modeluid
        ) A
    WHERE minstarttime > @starttime

        UNION ALL

    SELECT
        modeluid,
        endtime AS starttime,
        nextstarttime AS endtime
    FROM (
        SELECT
            modeluid,
            starttime,
            endtime,
            LEAD(starttime, 1, @endtime) OVER (PARTITION BY modeluid ORDER BY starttime ASC) AS nextstarttime
        FROM
            periods
        ) A
    WHERE endtime <> nextstarttime

            UNION ALL

    SELECT
        equipmentuid,
        @starttime,
        @endtime
    FROM
        @equipmentinfo
    WHERE
        NOT EXISTS (
            SELECT 1 FROM periods i WHERE i.modeluid = equipmentuid
        )]]></sql><timeout>60.0</timeout></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="GetEventDurations"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[let operationKPIManager = Things["PTCDTS.OperationKPIImpl.Manager"];
// result: THINGNAME
let mfgModelManager = Things[operationKPIManager.GetConfiguredManagerForIdentifier({
	identifier: "PTC.MfgModel.Manager" /* STRING */
})];

// result: INFOTABLE dataShape: "PTC.ModelManagement.ModelType"
let modelType = mfgModelManager.GetModelType({
	modelUid: modelUid /* STRING [Required] */
}).name;
let result;

try{
    if(modelType != "Workunit"){
        result = me.CallGetEventDurations({
            startDateTime: startDateTime,
            endDateTime: endDateTime,
            modelUid: modelUid,
            shiftInstanceUid: shiftInstanceUid,
            materialMasterUid: materialMasterUid,
            minEventAgeInDays: me.minEventAgeInDays
        });
    }else{
        result = me.CallGetEventDurationsForWorkUnit({
            startDateTime: startDateTime,
            endDateTime: endDateTime,
            modelUid: modelUid,
            shiftInstanceUid: shiftInstanceUid,
            materialMasterUid: materialMasterUid,
            minEventAgeInDays: me.minEventAgeInDays
        });
    }
} catch (err) {
	logger.error("{} - {}:{} - {}", me.name, err.fileName, err.lineNumber, err);
	throw err;
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="GetTargetQuantityMultiplier"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[// CreateInfoTableFromDataShape(infoTableName:STRING("InfoTable"), dataShapeName:STRING):INFOTABLE(NumberArrayElement)
let result = me.CallGetTargetQuantityMultiplier({
	jobOrderUid: jobOrderUid /* STRING */,
	modelUid: modelUid /* STRING */
});]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="GetTrend2Infos"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[if (logger.debugEnabled) {
	logger.debug("Entering {}:GetTrend2Infos with parameter startDateTime:{} endDateTime:{} modelUid:{} reasonTreeNodeUid:{} eventCategoryUid:{} reasonCategoryUid:{} shiftInstanceUid:{} materialMasterUid:{} reasonModelUid:{} eventTypeUids:{} reasonTypeUid:{}",
		me.name, startDateTime, endDateTime, modelUid, reasonTreeNodeUid, eventCategoryUid, reasonCategoryUid, shiftInstanceUid, materialMasterUid, reasonModelUid, eventTypeUids, reasonTypeUid);
}
try {
	var result = me.CallGetTrend2({
		startDateTime: startDateTime,
		endDateTime: endDateTime,
		modelUid: modelUid,
		reasonTreeNodeUid: reasonTreeNodeUid,
		eventCategoryUid: eventCategoryUid,
		reasonCategoryUid: reasonCategoryUid,
		materialMasterUid: materialMasterUid,
		shiftInstanceUid: shiftInstanceUid,
		reasonModelUid: reasonModelUid,
		eventTypeUids: eventTypeUids,
		reasonTypeUid: reasonTypeUid,
		adjustingTimeOffset: adjustingTimeOffset
	});
} catch (err) {
	logger.error("{} - {}:{} - {}", me.name, err.fileName, err.lineNumber, err);
	throw err;
}
if (logger.debugEnabled) {
	logger.debug("Exiting {}:GetTrend2Infos", me.name);
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="SQLQuery" name="GetUnaccountedTimeInfosSql"><ConfigurationTables><ConfigurationTable dataShapeName="" description="SQLQuery" isMultiRow="false" name="Query" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="NUMBER" description="maxItems" name="maxItems" ordinal="0"/><FieldDefinition baseType="STRING" description="sql" name="sql" ordinal="0"/><FieldDefinition baseType="NUMBER" description="timeout" name="timeout" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><maxItems>0.0</maxItems><sql><![CDATA[DECLARE @equipmentinfo equipmentinfotype
DECLARE @productionblocks productionblocktype
DECLARE @isWorkUnitOnly BIT = CASE WHEN (SELECT modeltypeuid FROM model WHERE uid =  [[equipmentUid]]) = 6 THEN 1 ELSE 0 END
INSERT INTO @equipmentinfo(equipmentuid) 
SELECT childuid
FROM GetTreeModels([[equipmentUid]], @isWorkUnitOnly)

INSERT INTO @productionblocks(productionblockuid, modeluid, starttime, endtime, joborderuid, materialmasteruid)
SELECT productionblockuid, modeluid, starttime, endtime, joborderuid, materialmasteruid 
FROM GetProductionBlockByEquipment([[startDateTime]], [[endDateTime]], @equipmentinfo)

DECLARE @now DATETIMEOFFSET = GETDATE() 
UPDATE @productionblocks set endtime = @now where endtime > @now

DROP TABLE IF EXISTS #unaccountedtime
CREATE TABLE #unaccountedtime(
    modeluid BIGINT,
    productionBlockUid BIGINT,
    jobOrderUid BIGINT,
    jobOrderId NVARCHAR(255) COLLATE DATABASE_DEFAULT,
    shiftName NVARCHAR(255) COLLATE DATABASE_DEFAULT,
    modelName NVARCHAR(255) COLLATE DATABASE_DEFAULT,
    materialMasterUid BIGINT,
    materialMasterId NVARCHAR(255) COLLATE DATABASE_DEFAULT,
    startTime DATETIME2,
    endTime DATETIME2,
    productionBlockDuration NUMERIC(38, 5),
    actualProduceQuantity NUMERIC(38, 5),
    expectedProduceQuantity NUMERIC(38, 5),
    targetProduceQuantity NUMERIC(38, 5),
    idealCycleTime NUMERIC(38, 5),
    expectedProduceTime NUMERIC(38, 5),
    scrapQuantity NUMERIC(38, 5),
    scrapTime NUMERIC(38, 5),
    goodProduceQuantity NUMERIC(38, 5),
    goodProduceTime NUMERIC(38, 5),
    accountedTime NUMERIC(38, 5),
    unaccountedTime NUMERIC(38, 5), 
    hasUnaccountedTime BIT,
    totalLostTime NUMERIC(38, 5),
    effectiveTime NUMERIC(38, 5))
INSERT #unaccountedtime EXEC GetProductionBlockInfo @productionblocks, DEFAULT

SELECT
	modelUid,
	productionBlockUid,
	jobOrderUid,
	jobOrderId,
	shiftName,
	materialMasterUid,
	materialMasterId,
	startTime,
	endTime,
	unaccountedTime,
	hasUnaccountedTime,
	modelName
FROM
	#unaccountedtime
WHERE
	hasUnaccountedTime = 1]]></sql><timeout>0.0</timeout></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation></ServiceImplementations><Subscriptions/></ThingShape><ImplementedShapes/><SharedConfigurationTables/><InstanceDesignTimePermissions><Create/><Read/><Update/><Delete/><Metadata/></InstanceDesignTimePermissions><InstanceRunTimePermissions/><InstanceVisibilityPermissions><Visibility/></InstanceVisibilityPermissions><ConfigurationChanges><ConfigurationChange changeAction="CREATE" changeReason="Importing Extension Package Metadata" timestamp="2023-08-29T15:25:37.396Z" user="SuperUser"/></ConfigurationChanges></ThingTemplate><ThingTemplate aspect.isEditableExtensionObject="true" aspect.isExtension="true" baseThingTemplate="PTC.MfgModel.DefaultWorkcenter_TT" description="" documentationContent="" effectiveThingPackage="RemoteThingWithTunnelsAndFileTransfer" homeMashup="" inheritedValueStream="" lastModifiedDate="2023-08-29T15:25:37.374Z" name="PTCDTS.OperationKPIImpl.DefaultWorkCenter_TT" projectName="PTCDTS.OperationKPIImpl" tags="" thingPackage="" valueStream=""><Owner name="SuperUser" type="User"/><avatar/><DesignTimePermissions><Create/><Read/><Update/><Delete/><Metadata/></DesignTimePermissions><RunTimePermissions/><VisibilityPermissions><Visibility/></VisibilityPermissions><ConfigurationTableDefinitions/><ConfigurationTables><ConfigurationTable dataShapeName="" description="Configuration table used to identify managers that the building block should use" isMultiRow="true" name="ManagerConfiguration" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="true" baseType="STRING" description="unique identifier for the manager that needs to be configured" name="id" ordinal="1"/><FieldDefinition aspect.isPrimaryKey="false" aspect.thingShape="PTC.Base.CommonManagement_TS" baseType="THINGNAME" description="Name of the Manager Thing to be configured" name="managerThingName" ordinal="2"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable><ConfigurationTable dataShapeName="" description="" isMultiRow="true" name="MashupConfiguration" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="true" baseType="STRING" description="unique identifier used to identify the thing or mashup that is being configured" name="id" ordinal="1"/><FieldDefinition aspect.isPrimaryKey="false" baseType="MASHUPNAME" description="name of the mashup to configure" name="mashupName" ordinal="2"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable><ConfigurationTable dataShapeName="" description="Configuration table for dynamic menus. Menu Items can be specified here and they will show up for the given menu name. " isMultiRow="true" name="MenuConfiguration" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="" name="menuItemMashupName" ordinal="2"/><FieldDefinition aspect.isPrimaryKey="true" baseType="STRING" description="" name="menuName" ordinal="3"/><FieldDefinition aspect.isPrimaryKey="false" baseType="INTEGER" description="An optional field to indicate the ordering of the menu items" name="menuOrderPreference" ordinal="5"/><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="Localization table key for the optional section that groups like menus together" name="menuSectionKey" ordinal="4"/><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="Localization table key for the menu label" name="menuTitleKey" ordinal="1"/><FieldDefinition aspect.dataShape="PTC.Base.ComponentMenuConfiguration" aspect.isPrimaryKey="false" baseType="INFOTABLE" description="" name="submenu" ordinal="6"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable><ConfigurationTable dataShapeName="" description="Reporting Settings" isMultiRow="false" name="ReportingConfiguration" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.defaultValue="NotReporting" aspect.isPrimaryKey="true" aspect.isReadOnly="false" aspect.thingTemplate="ReportingStrategy" baseType="THINGNAME" description="Strategy to determine health" name="reportingStrategy" ordinal="1"/></FieldDefinitions></DataShape><Rows><Row><reportingStrategy><![CDATA[AlwaysOnReporting]]></reportingStrategy></Row></Rows></ConfigurationTable><ConfigurationTable dataShapeName="" description="Configuration table for any Things that need to be configured. This allows for OOTB things to be customized, and the new version that should be used can be configured here" isMultiRow="true" name="ThingConfiguration" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="true" baseType="STRING" description="unique identifier used to identify the thing or mashup that is being configured" name="id" ordinal="1"/><FieldDefinition aspect.isPrimaryKey="false" baseType="THINGNAME" description="Name of the Thing entity or Mashup entity that is to be configured" name="thingName" ordinal="2"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable><ConfigurationTable dataShapeName="" description="General Settings" isMultiRow="false" name="TunnelSettings" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.friendlyName="Enable Tunneling" aspect.isNullable="true" baseType="BOOLEAN" description="Enable tunneling" name="enableTunneling" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row/></Rows></ConfigurationTable><ConfigurationTable dataShapeName="" description="Tunneling Destinations" isMultiRow="true" name="Tunnels" ordinal="1"><DataShape><FieldDefinitions><FieldDefinition aspect.defaultValue="" aspect.friendlyName="Application Path" baseType="STRING" description="Location of the client app that will use this tunnel" name="appUri" ordinal="5"/><FieldDefinition aspect.defaultValue="" aspect.friendlyName="Description" baseType="STRING" description="A description of the tunnel" name="description" ordinal="3"/><FieldDefinition aspect.defaultValue="127.0.0.1" aspect.friendlyName="Host" baseType="STRING" description="Host or IP that this tunnel will connect to at the edge" name="host" ordinal="1"/><FieldDefinition aspect.defaultValue="vnc" aspect.friendlyName="Name" baseType="STRING" description="Name of the tunnel" name="name" ordinal="0"/><FieldDefinition aspect.defaultValue="1.0" aspect.friendlyName="Number of Connects" baseType="NUMBER" description="The number of connections required to establish this tunnel" name="numConnects" ordinal="4"/><FieldDefinition aspect.defaultValue="5900.0" aspect.friendlyName="Port" baseType="NUMBER" description="Port that this tunnel will connect to at the edge" name="port" ordinal="2"/><FieldDefinition aspect.defaultValue="tcp" aspect.friendlyName="Protocol" baseType="STRING" description="The protocol used over this tunnel" name="proto" ordinal="6"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable></ConfigurationTables><PropertyBindings/><RemotePropertyBindings/><RemoteServiceBindings/><RemoteEventBindings/><AlertConfigurations><AlertDefinitions name="PTCAutomationEventProcessingLock"/></AlertConfigurations><ThingShape><PropertyDefinitions><PropertyDefinition aspect.cacheTime="0.0" aspect.dataChangeType="VALUE" aspect.defaultValue="false" baseType="BOOLEAN" category="" description="" isLocalOnly="false" name="PTCAutomationEventProcessingLock" ordinal="2"/></PropertyDefinitions><ServiceDefinitions><ServiceDefinition aspect.isAsync="false" category="" description="" isAllowOverride="false" isLocalOnly="false" isOpen="false" isPrivate="false" name="ProcessPTCAutomationEventsForWorkCenter"><ResultType baseType="NOTHING" description="" name="result" ordinal="0"/><ParameterDefinitions/></ServiceDefinition><ServiceDefinition aspect.isAsync="true" category="" description="" isAllowOverride="false" isLocalOnly="false" isOpen="false" isPrivate="false" name="ProcessPTCAutomationEventsForWorkCenterAsync"><ResultType baseType="NOTHING" description="" name="result" ordinal="0"/><ParameterDefinitions/></ServiceDefinition><ServiceDefinition aspect.isAsync="true" category="" description="" isAllowOverride="false" isLocalOnly="false" isOpen="false" isPrivate="false" name="ProcessPTCAutomationEventsForWorkUnitAsync"><ResultType baseType="NOTHING" description="" name="result" ordinal="0"/><ParameterDefinitions><FieldDefinition aspect.dataShape="EntityList" baseType="INFOTABLE" description="" name="AutomationWorkUnits" ordinal="1"/><FieldDefinition baseType="INTEGER" description="" name="index" ordinal="2"/></ParameterDefinitions></ServiceDefinition></ServiceDefinitions><EventDefinitions/><ServiceMappings/><ServiceImplementations><ServiceImplementation description="" handlerName="Script" name="ProcessPTCAutomationEventsForWorkCenter"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[//////////////////////////////
var start;
if (logger.infoEnabled) {
	start = new Date().getTime();
	logger.info('[{}] Execution Start ', me.name);
}
if (!me.PTCAutomationEventProcessingLock) {
	me.PTCAutomationEventProcessingLock = true;
	try {
		process();
	} catch (err) {
		logger.error("Thing [{}] Service [{}] error at line [{}] : {}", me.name, err.fileName, err.lineNumber, err);
        me.PTCAutomationEventProcessingLock = false;
	}
}
if (logger.infoEnabled) {
	var end = new Date().getTime();
	var time = end - start;
	logger.info('[{}] Execution End time [{}] milliseconds ', me.name, time);
}

function process() {
	//Get all automation workunit children
    let automationChildren = Resources["InfoTableFunctions"].CreateInfoTableFromDataShape({
        infoTableName: "InfoTable",
        dataShapeName: "EntityList"
    });
    
    let children = me.GetPTCAllChildren();
    children.rows.toArray().forEach(row => {
        let child = Things[row.thingName];
        if(child){
            // result: BOOLEAN
            let isAutomation = child.ImplementsShape({
                thingShapeName: "PTC.OperationKPI.AutomationEventsModelLogic_TS" /* THINGSHAPENAME */
            });
			if(isAutomation){
                // EntityList entry object
                let newEntry = {
                    name: row.thingName // STRING [Primary Key]
                };
                automationChildren.AddRow(newEntry);
            }
        }
    });
	if(automationChildren.rows.length > 0){
        //Call Async service
        me.ProcessPTCAutomationEventsForWorkUnitAsync({
            AutomationWorkUnits: automationChildren /* INFOTABLE {"dataShape":"EntityList"} */,
            index: 0 /* INTEGER */
        });
    }else{
        me.PTCAutomationEventProcessingLock = false;
    }
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="ProcessPTCAutomationEventsForWorkCenterAsync"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[me.ProcessPTCAutomationEventsForWorkCenter();]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="ProcessPTCAutomationEventsForWorkUnitAsync"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[try{
    let workunitRow = AutomationWorkUnits.rows[index];
    let workUnitThing = Things[workunitRow.name];
    if(workUnitThing){
        workUnitThing.ProcessPTCAutomationEvents();
    }
    
    index = index +1;
    if(index < AutomationWorkUnits.rows.length){
        me.ProcessPTCAutomationEventsForWorkUnitAsync({
            AutomationWorkUnits: AutomationWorkUnits /* INFOTABLE */,
            index: index /* INTEGER */
        });
    }else{
        me.PTCAutomationEventProcessingLock = false;
    }
}catch(err){
    me.PTCAutomationEventProcessingLock = false;
    throw(err);
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation></ServiceImplementations><Subscriptions><Subscription description="" enabled="true" eventName="Timer" name="PTCAutomationEventProcessingTimerSubscription" source="PTC.OperationKPI.AutomationEventProcessor_TI" sourceProperty="" sourceType="Thing"><ServiceImplementation description="" handlerName="Script" name="PTCAutomationEventProcessingTimerSubscription"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[// Call Service
me.ProcessPTCAutomationEventsForWorkCenterAsync();]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation></Subscription></Subscriptions></ThingShape><ImplementedShapes><ImplementedShape name="PTC.WorkMaster.ModelLogic_TS" type="ThingShape"/><ImplementedShape name="PTC.JobOrder.ModelLogic_TS" type="ThingShape"/><ImplementedShape name="PTC.ReasonCode.ModelLogic_TS" type="ThingShape"/><ImplementedShape name="PTC.Status.ModelLogic_TS" type="ThingShape"/><ImplementedShape name="PTC.MaterialMaster.ModelLogic_TS" type="ThingShape"/><ImplementedShape name="PTC.Shift.ModelLogic_TS" type="ThingShape"/><ImplementedShape name="PTC.OperationKPI.ExecutionModelLogic_TS" type="ThingShape"/><ImplementedShape name="PTC.OperationKPI.AnalysisModelLogic_TS" type="ThingShape"/></ImplementedShapes><SharedConfigurationTables><ConfigurationTable dataShapeName="" description="Shared Remote Tunneling Settings" isMultiRow="false" name="SharedTunnelSettings" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.defaultValue="false" aspect.friendlyName="Enable Tunneling" baseType="BOOLEAN" description="Enable tunneling" name="enableTunneling" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><enableTunneling>false</enableTunneling></Row></Rows></ConfigurationTable><ConfigurationTable dataShapeName="" description="Shared Tunneling Destinations" isMultiRow="true" name="SharedTunnels" ordinal="1"><DataShape><FieldDefinitions><FieldDefinition aspect.friendlyName="Application Path" baseType="STRING" description="Location of the client app that will use this tunnel" name="appUri" ordinal="5"/><FieldDefinition aspect.friendlyName="Description" baseType="STRING" description="A description of the tunnel" name="description" ordinal="3"/><FieldDefinition aspect.friendlyName="Host" baseType="STRING" description="Host or IP that this tunnel will connect to at the edge" name="host" ordinal="1"/><FieldDefinition aspect.friendlyName="Name" baseType="STRING" description="Name of the tunnel" name="name" ordinal="0"/><FieldDefinition aspect.friendlyName="Number of Connects" baseType="NUMBER" description="The number of connections required to establish this tunnel" name="numConnects" ordinal="4"/><FieldDefinition aspect.friendlyName="Port" baseType="NUMBER" description="Port that this tunnel will connect to at the edge" name="port" ordinal="2"/><FieldDefinition aspect.friendlyName="Protocol" baseType="STRING" description="The protocol used over this tunnel" name="proto" ordinal="6"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable></SharedConfigurationTables><InstanceDesignTimePermissions><Create/><Read/><Update/><Delete/><Metadata/></InstanceDesignTimePermissions><InstanceRunTimePermissions/><InstanceVisibilityPermissions><Visibility/></InstanceVisibilityPermissions><ConfigurationChanges><ConfigurationChange changeAction="CREATE" changeReason="Importing Extension Package Metadata" timestamp="2023-08-29T15:25:37.374Z" user="SuperUser"/></ConfigurationChanges></ThingTemplate><ThingTemplate aspect.isEditableExtensionObject="true" aspect.isExtension="true" baseThingTemplate="PTC.MfgModel.DefaultWorkunit_TT" description="" documentationContent="" effectiveThingPackage="RemoteThingWithTunnelsAndFileTransfer" homeMashup="" inheritedValueStream="" lastModifiedDate="2023-08-29T15:25:37.394Z" name="PTCDTS.OperationKPIImpl.DefaultWorkUnit_TT" projectName="PTCDTS.OperationKPIImpl" tags="" thingPackage="" valueStream=""><Owner name="SuperUser" type="User"/><avatar/><DesignTimePermissions><Create/><Read/><Update/><Delete/><Metadata/></DesignTimePermissions><RunTimePermissions/><VisibilityPermissions><Visibility/></VisibilityPermissions><ConfigurationTableDefinitions/><ConfigurationTables><ConfigurationTable dataShapeName="" description="Configuration table used to identify managers that the building block should use" isMultiRow="true" name="ManagerConfiguration" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="true" baseType="STRING" description="unique identifier for the manager that needs to be configured" name="id" ordinal="1"/><FieldDefinition aspect.isPrimaryKey="false" aspect.thingShape="PTC.Base.CommonManagement_TS" baseType="THINGNAME" description="Name of the Manager Thing to be configured" name="managerThingName" ordinal="2"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable><ConfigurationTable dataShapeName="" description="" isMultiRow="true" name="MashupConfiguration" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="true" baseType="STRING" description="unique identifier used to identify the thing or mashup that is being configured" name="id" ordinal="1"/><FieldDefinition aspect.isPrimaryKey="false" baseType="MASHUPNAME" description="name of the mashup to configure" name="mashupName" ordinal="2"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable><ConfigurationTable dataShapeName="" description="Configuration table for dynamic menus. Menu Items can be specified here and they will show up for the given menu name. " isMultiRow="true" name="MenuConfiguration" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="" name="menuItemMashupName" ordinal="2"/><FieldDefinition aspect.isPrimaryKey="true" baseType="STRING" description="" name="menuName" ordinal="3"/><FieldDefinition aspect.isPrimaryKey="false" baseType="INTEGER" description="An optional field to indicate the ordering of the menu items" name="menuOrderPreference" ordinal="5"/><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="Localization table key for the optional section that groups like menus together" name="menuSectionKey" ordinal="4"/><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="Localization table key for the menu label" name="menuTitleKey" ordinal="1"/><FieldDefinition aspect.dataShape="PTC.Base.ComponentMenuConfiguration" aspect.isPrimaryKey="false" baseType="INFOTABLE" description="" name="submenu" ordinal="6"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable><ConfigurationTable dataShapeName="" description="Reporting Settings" isMultiRow="false" name="ReportingConfiguration" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.defaultValue="NotReporting" aspect.isPrimaryKey="true" aspect.isReadOnly="false" aspect.thingTemplate="ReportingStrategy" baseType="THINGNAME" description="Strategy to determine health" name="reportingStrategy" ordinal="1"/></FieldDefinitions></DataShape><Rows><Row><reportingStrategy><![CDATA[AlwaysOnReporting]]></reportingStrategy></Row></Rows></ConfigurationTable><ConfigurationTable dataShapeName="" description="Configuration table for any Things that need to be configured. This allows for OOTB things to be customized, and the new version that should be used can be configured here" isMultiRow="true" name="ThingConfiguration" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="true" baseType="STRING" description="unique identifier used to identify the thing or mashup that is being configured" name="id" ordinal="1"/><FieldDefinition aspect.isPrimaryKey="false" baseType="THINGNAME" description="Name of the Thing entity or Mashup entity that is to be configured" name="thingName" ordinal="2"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable><ConfigurationTable dataShapeName="" description="General Settings" isMultiRow="false" name="TunnelSettings" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.friendlyName="Enable Tunneling" aspect.isNullable="true" baseType="BOOLEAN" description="Enable tunneling" name="enableTunneling" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row/></Rows></ConfigurationTable><ConfigurationTable dataShapeName="" description="Tunneling Destinations" isMultiRow="true" name="Tunnels" ordinal="1"><DataShape><FieldDefinitions><FieldDefinition aspect.defaultValue="" aspect.friendlyName="Application Path" baseType="STRING" description="Location of the client app that will use this tunnel" name="appUri" ordinal="5"/><FieldDefinition aspect.defaultValue="" aspect.friendlyName="Description" baseType="STRING" description="A description of the tunnel" name="description" ordinal="3"/><FieldDefinition aspect.defaultValue="127.0.0.1" aspect.friendlyName="Host" baseType="STRING" description="Host or IP that this tunnel will connect to at the edge" name="host" ordinal="1"/><FieldDefinition aspect.defaultValue="vnc" aspect.friendlyName="Name" baseType="STRING" description="Name of the tunnel" name="name" ordinal="0"/><FieldDefinition aspect.defaultValue="1.0" aspect.friendlyName="Number of Connects" baseType="NUMBER" description="The number of connections required to establish this tunnel" name="numConnects" ordinal="4"/><FieldDefinition aspect.defaultValue="5900.0" aspect.friendlyName="Port" baseType="NUMBER" description="Port that this tunnel will connect to at the edge" name="port" ordinal="2"/><FieldDefinition aspect.defaultValue="tcp" aspect.friendlyName="Protocol" baseType="STRING" description="The protocol used over this tunnel" name="proto" ordinal="6"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable></ConfigurationTables><PropertyBindings/><RemotePropertyBindings/><RemoteServiceBindings/><RemoteEventBindings/><AlertConfigurations/><ThingShape><PropertyDefinitions/><ServiceDefinitions><ServiceDefinition aspect.isAsync="false" category="" description="" isAllowOverride="true" isLocalOnly="false" isOpen="false" isPrivate="false" name="StopPTCProductionWithForceOption"><ResultType aspect.dataShape="PTC.JobOrder.JobOrder" baseType="INFOTABLE" description="" name="result" ordinal="0"/><ParameterDefinitions><FieldDefinition aspect.isRequired="true" baseType="STRING" description="" name="dispatchStatusUid" ordinal="1"/><FieldDefinition baseType="BOOLEAN" description="" name="forceJobOrderStop" ordinal="3"/><FieldDefinition baseType="DATETIME" description="Timestamp for stop production." name="timestamp" ordinal="2"/></ParameterDefinitions></ServiceDefinition></ServiceDefinitions><EventDefinitions/><ServiceMappings/><ServiceImplementations><ServiceImplementation description="" handlerName="Script" name="GetPTCAllEvents"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[if (logger.debugEnabled){
        logger.debug("Entering {}:GetPTCAllEvents with parameter startDateTime:{} endDateTime:{}", me.name, startDateTime, endDateTime);
}
let modelUid = me.GetPTCModelUid();

const baseCommonHelper = Things[Things["PTCDTS.ProductionDashboard.Manager"].GetBaseCommonHelper()];
let locale = baseCommonHelper.GetCurrentUserLocale();

let result = Things[me.GetPTCOperationExecutionManager()].GetAllEvents({
    modelUid: modelUid,
    startDateTime: startDateTime,
    endDateTime: endDateTime,
    locale : locale
});
if (logger.debugEnabled){
        logger.debug("Exiting {}:GetPTCAllEvents", me.name);
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="StopPTCProductionWithForceOption"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[if (logger.debugEnabled) {
	logger.debug("Entering {}:StopPTCProduction with parameter dispatchStatusUid:{}", me.name, dispatchStatusUid);
}
try {
    let runningJobOrderUid = me.GetPTCRunningJobOrders({
			dateTime: new Date()
		}).jobOrderUid;
    
	var result = Things[me.GetPTCOperationExecutionManager()].StopProductionWithForceOption({
		dispatchStatusUid: dispatchStatusUid,
		modelUid: me.GetPTCModelUid(),
		jobOrderUid: runningJobOrderUid,
		timestamp: timestamp,
        forceJobOrderStop: forceJobOrderStop
	});
	if (result) {
		me.PTCLastProductionBlockEndTimestamp = result.PTC_OperationKPI_ProductionBlock_endDateTime;
		me.PTCJobOrderUidUpdateTimestamp = new Date();
		me.PTCLastExpiredProductionBlockUid = result.PTC_OperationKPI_ProductionBlock_uid;
	}
} catch (err) {
	logger.error("Thing [{}] Service [{}] error at line [{}] : {}", me.name, err.fileName, err.lineNumber, err);
	throw ("An error has occurred. Please check the script logs for more details.");
}
if (logger.debugEnabled) {
	logger.debug("Exiting {}:StopPTCProduction", me.name);
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation></ServiceImplementations><Subscriptions/></ThingShape><ImplementedShapes><ImplementedShape name="PTC.WorkMaster.ModelLogic_TS" type="ThingShape"/><ImplementedShape name="PTC.JobOrder.ModelLogic_TS" type="ThingShape"/><ImplementedShape name="PTC.ReasonCode.ModelLogic_TS" type="ThingShape"/><ImplementedShape name="PTC.Status.ModelLogic_TS" type="ThingShape"/><ImplementedShape name="PTC.MaterialMaster.ModelLogic_TS" type="ThingShape"/><ImplementedShape name="PTC.Shift.ModelLogic_TS" type="ThingShape"/><ImplementedShape name="PTC.OperationKPI.ExecutionModelLogic_TS" type="ThingShape"/><ImplementedShape name="PTC.OperationKPI.AnalysisModelLogic_TS" type="ThingShape"/><ImplementedShape name="PTC.MfgModel.AnalysisModelLogic_TS" type="ThingShape"/></ImplementedShapes><SharedConfigurationTables><ConfigurationTable dataShapeName="" description="Shared Remote Tunneling Settings" isMultiRow="false" name="SharedTunnelSettings" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.defaultValue="false" aspect.friendlyName="Enable Tunneling" baseType="BOOLEAN" description="Enable tunneling" name="enableTunneling" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><enableTunneling>false</enableTunneling></Row></Rows></ConfigurationTable><ConfigurationTable dataShapeName="" description="Shared Tunneling Destinations" isMultiRow="true" name="SharedTunnels" ordinal="1"><DataShape><FieldDefinitions><FieldDefinition aspect.friendlyName="Application Path" baseType="STRING" description="Location of the client app that will use this tunnel" name="appUri" ordinal="5"/><FieldDefinition aspect.friendlyName="Description" baseType="STRING" description="A description of the tunnel" name="description" ordinal="3"/><FieldDefinition aspect.friendlyName="Host" baseType="STRING" description="Host or IP that this tunnel will connect to at the edge" name="host" ordinal="1"/><FieldDefinition aspect.friendlyName="Name" baseType="STRING" description="Name of the tunnel" name="name" ordinal="0"/><FieldDefinition aspect.friendlyName="Number of Connects" baseType="NUMBER" description="The number of connections required to establish this tunnel" name="numConnects" ordinal="4"/><FieldDefinition aspect.friendlyName="Port" baseType="NUMBER" description="Port that this tunnel will connect to at the edge" name="port" ordinal="2"/><FieldDefinition aspect.friendlyName="Protocol" baseType="STRING" description="The protocol used over this tunnel" name="proto" ordinal="6"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable></SharedConfigurationTables><InstanceDesignTimePermissions><Create/><Read/><Update/><Delete/><Metadata/></InstanceDesignTimePermissions><InstanceRunTimePermissions/><InstanceVisibilityPermissions><Visibility/></InstanceVisibilityPermissions><ConfigurationChanges><ConfigurationChange changeAction="CREATE" changeReason="Importing Extension Package Metadata" timestamp="2023-08-29T15:25:37.393Z" user="SuperUser"/></ConfigurationChanges></ThingTemplate><ThingTemplate aspect.isEditableExtensionObject="true" aspect.isExtension="true" aspect.isSystemObject="false" baseThingTemplate="PTC.OperationKPIImpl.EntryPoint_TT" description="Impl for MMM testing" documentationContent="" effectiveThingPackage="ConfiguredThing" homeMashup="" inheritedValueStream="" lastModifiedDate="2023-08-29T15:25:37.371Z" name="PTCDTS.OperationKPIImpl.EntryPoint_TT" projectName="PTCDTS.OperationKPIImpl" tags="" thingPackage="" valueStream=""><Owner name="SuperUser" type="User"/><avatar/><DesignTimePermissions><Create/><Read/><Update/><Delete/><Metadata/></DesignTimePermissions><RunTimePermissions/><VisibilityPermissions><Visibility/></VisibilityPermissions><ConfigurationTableDefinitions/><ConfigurationTables><ConfigurationTable dataShapeName="" description="Configuration table to store the components core manager" isMultiRow="true" name="ComponentManager" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="true" baseType="STRING" description="unique identifier for the manager that needs to be configured" name="id" ordinal="1"/><FieldDefinition aspect.isPrimaryKey="false" aspect.thingShape="PTC.Base.CommonManagement_TS" baseType="THINGNAME" description="Name of the Manager Thing to be configured" name="managerThingName" ordinal="2"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable></ConfigurationTables><PropertyBindings/><RemotePropertyBindings/><RemoteServiceBindings/><RemoteEventBindings/><AlertConfigurations/><ThingShape><PropertyDefinitions/><ServiceDefinitions><ServiceDefinition aspect.isAsync="false" category="" description="" isAllowOverride="false" isLocalOnly="false" isOpen="false" isPrivate="false" name="EnableScheduler"><ResultType baseType="NOTHING" description="" name="result" ordinal="0"/><ParameterDefinitions/></ServiceDefinition><ServiceDefinition aspect.isAsync="false" category="" description="" isAllowOverride="false" isLocalOnly="false" isOpen="false" isPrivate="false" name="UpdateDBFunctions"><ResultType baseType="NOTHING" description="" name="result" ordinal="0"/><ParameterDefinitions/></ServiceDefinition><ServiceDefinition aspect.isAsync="false" category="" description="" isAllowOverride="false" isLocalOnly="false" isOpen="false" isPrivate="false" name="UpdateGlobalConfig"><ResultType baseType="NOTHING" description="" name="result" ordinal="0"/><ParameterDefinitions/></ServiceDefinition><ServiceDefinition aspect.isAsync="false" category="" description="" isAllowOverride="false" isLocalOnly="false" isOpen="false" isPrivate="false" name="UpdateOnActionProcessorConfig"><ResultType baseType="NOTHING" description="" name="result" ordinal="0"/><ParameterDefinitions/></ServiceDefinition><ServiceDefinition aspect.isAsync="false" category="" description="" isAllowOverride="false" isLocalOnly="false" isOpen="false" isPrivate="false" name="UpdateStateMachineConfiguration"><ResultType baseType="NOTHING" description="" name="result" ordinal="0"/><ParameterDefinitions/></ServiceDefinition><ServiceDefinition aspect.isAsync="false" category="" description="" isAllowOverride="false" isLocalOnly="false" isOpen="false" isPrivate="false" name="UpdateWorkDefinitionAP"><ResultType baseType="NOTHING" description="" name="result" ordinal="0"/><ParameterDefinitions/></ServiceDefinition></ServiceDefinitions><EventDefinitions/><ServiceMappings/><ServiceImplementations><ServiceImplementation description="" handlerName="Script" name="DeployComponent"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[logger.info("Entering {}:DeployComponent::Entry", me.name);                                        
let implementationProjectName = me.GetProjectName();
if (!implementationProjectName) {
	throw "Implementation building block project name is missing";
}
let manager = implementationProjectName + ".Manager";
if (!Things[manager]) {
	throw "Manager [" + manager + "] is missing";
}
try {
//    me.DatabaseConfiguration({
//        deploymentConfig: deploymentConfig
//    });
    me.UpdateGlobalConfig();
    me.UpdateWorkDefinitionAP();
    me.UpdateDBFunctions();
    me.EnableScheduler();
    me.UpdateStateMachineConfiguration();
    me.UpdateOnActionProcessorConfig();
    
} catch (err) {
	logger.error("Thing [{}] Service [{}] error at line [{}] : {}", me.name, err.fileName, err.lineNumber, err);
}

logger.info("Exiting {}:DeployComponent::Exit", me.name);

let result = true;]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="EnableScheduler"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[Things["PTC.OperationKPI.MonitoringScheduler"].DisableScheduler();
Things["PTCDTS.OperationKPI.MonitoringScheduler"].EnableScheduler();

// Set OOTB scheduler to not enable on start
// table: INFOTABLE dataShape: ""
result = Things["PTC.OperationKPI.MonitoringScheduler"].GetConfigurationTable({
	tableName: "Settings" /* STRING */
});

result.enabled = false;

Things["PTC.OperationKPI.MonitoringScheduler"].SetConfigurationTable({
	configurationTable: result /* INFOTABLE */,
	persistent: undefined /* BOOLEAN {"defaultValue":true} */,
	tableName: "Settings" /* STRING */
});]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="GetComponentDeployConfigurationParameters"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[var result = {};]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="UpdateDBFunctions"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[try{
    let dbUtil = me.GetDeployManagement();

    Things[dbUtil].CreateDBFunctions();
} catch (err) {
	logger.error("Thing [{}] Service [{}] error at line [{}] : {}", me.name, err.fileName, err.lineNumber, err);
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="UpdateGlobalConfig"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[try{
    // table: INFOTABLE dataShape: ""
    let table = Things["PTC.Base.Manager"].GetConfigurationTable({
        tableName: "DefaultGlobalManagerConfiguration" /* STRING */
    });

    table.rows.toArray().forEach(row => {
        if(row.id == "PTC.OperationKPI.Manager") {
            row.managerThingName = "PTCDTS.OperationKPIImpl.Manager";
        }
    });

    Things["PTC.Base.Manager"].SetMultiRowConfigurationTable({
        configurationTable: table /* INFOTABLE */,
        persistent: true /* BOOLEAN {"defaultValue":true} */,
        tableName: "DefaultGlobalManagerConfiguration" /* STRING */
    });
} catch (err) {
	logger.error("Thing [{}] Service [{}] error at line [{}] : {}", me.name, err.fileName, err.lineNumber, err);
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="UpdateOnActionProcessorConfig"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[try{
	// table: INFOTABLE dataShape: ""
    let table = Things["PTC.DBConnection.OnActionProcessor"].GetConfigurationTable({
        tableName: "ActionConfigurationSettings" /* STRING */
    });

    table.rows.toArray().forEach(row => {
        if(row.ServiceName == "UpdateActualCycleTimeForJobOrder"){
            row.ThingName = "PTCDTS.OperationKPIImpl.Manager";
        }
    });


    Things["PTC.DBConnection.OnActionProcessor"].SetMultiRowConfigurationTable({
        configurationTable: table /* INFOTABLE */,
        persistent: undefined /* BOOLEAN {"defaultValue":true} */,
        tableName: "ActionConfigurationSettings" /* STRING */
    });
} catch (err) {
	logger.error("Thing [{}] Service [{}] error at line [{}] : {}", me.name, err.fileName, err.lineNumber, err);
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="UpdateStateMachineConfiguration"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[try{   
	let managerThing = Things[me.GetConfiguredComponentManager()];

    let stateMachineManager = Things[managerThing.GetConfiguredManagerForIdentifier({
        identifier: "PTC.StateMachine.Manager" /* STRING */
    })];


    // table: INFOTABLE dataShape: ""
    let table = stateMachineManager.GetConfigurationTable({
        tableName: "StateMachineConfiguration" /* STRING */
    });

    table.stateMachineConfiguration.states.Running.transitions.Running = {"action": "EndProductionBlock", "event":"StartJobOrder"};

    stateMachineManager.SetMultiRowConfigurationTable({
        configurationTable: table /* INFOTABLE */,
        persistent: true /* BOOLEAN {"defaultValue":true} */,
        tableName: "StateMachineConfiguration" /* STRING */
    });
} catch (err) {
	logger.error("Thing [{}] Service [{}] error at line [{}] : {}", me.name, err.fileName, err.lineNumber, err);
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="UpdateWorkDefinitionAP"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[try{
    DataShapes["PTC.SCA.SCO.WorkDefinition_AP"].AddFieldDefinition({
        name: "dispatchStatus" /* STRING */,
        type: "STRING" /* BASETYPENAME */
    });

    // result: INFOTABLE dataShape: "PTC.DBConnection.DatabaseSchemaValidation"
    Things["PTC.DBConnection.Manager"].UpdateDBSchema();
} catch (err) {
	logger.error("Thing [{}] Service [{}] error at line [{}] : {}", me.name, err.fileName, err.lineNumber, err);
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="UpgradeComponent"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[//let managerName = me.GetConfiguredComponentManager();
//if (!managerName) {
//	throw new Error("Manager not found for project: " + me.GetProjectName());
//}
//let manager = Things[managerName];
//if (!manager) {
//	throw new Error("Manager thing not found for name: " + managerName);
//}
//
//let dbThingName = manager.GetAnalysisManagement();
//if (!dbThingName) {
//	throw new Error("Database thing name not configured for manager: " + managerName);
//}
//
//let dbThing = Things[dbThingName];
//if (!dbThing) {
//	throw new Error("Database thing not found for name: " + dbThingName);
//}
//
//dbThing.UpgradeComponent({
//	config: config
//});
//
result = me.upgradeComponentStatus;]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation></ServiceImplementations><Subscriptions/></ThingShape><ImplementedShapes/><SharedConfigurationTables/><InstanceDesignTimePermissions><Create/><Read/><Update/><Delete/><Metadata/></InstanceDesignTimePermissions><InstanceRunTimePermissions/><InstanceVisibilityPermissions><Visibility/></InstanceVisibilityPermissions><ConfigurationChanges><ConfigurationChange changeAction="CREATE" changeReason="Importing Extension Package Metadata" timestamp="2023-08-29T15:25:37.371Z" user="SuperUser"/></ConfigurationChanges></ThingTemplate><ThingTemplate aspect.isEditableExtensionObject="true" aspect.isExtension="true" aspect.isSystemObject="false" baseThingTemplate="PTC.OperationKPIImpl.Manager_TT" description="Impl for MMM testing" documentationContent="" effectiveThingPackage="ConfiguredThing" homeMashup="" inheritedValueStream="" lastModifiedDate="2023-08-29T15:25:37.378Z" name="PTCDTS.OperationKPIImpl.Manager_TT" projectName="PTCDTS.OperationKPIImpl" tags="" thingPackage="" valueStream=""><Owner name="SuperUser" type="User"/><avatar/><DesignTimePermissions><Create/><Read/><Update/><Delete/><Metadata/></DesignTimePermissions><RunTimePermissions/><VisibilityPermissions><Visibility/></VisibilityPermissions><ConfigurationTableDefinitions><ConfigurationTableDefinition category="" dataShapeName="PTCDTS.DisplayNonPacemakersConfiguration" description="" isHidden="false" isMultiRow="false" name="DisplayNonPacemakers" ordinal="0" source="REST"/></ConfigurationTableDefinitions><ConfigurationTables><ConfigurationTable dataShapeName="PTC.OperationKPI.AnalysisManagementConfiguration" description="" isMultiRow="false" name="AnalysisManagement" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="true" aspect.thingShape="PTC.OperationKPI.AnalysisManagement_TS" baseType="THINGNAME" description="" name="analysisManagement" ordinal="1"/></FieldDefinitions></DataShape><Rows><Row><analysisManagement><![CDATA[PTC.OperationKPIImpl.DatabaseUtility]]></analysisManagement></Row></Rows></ConfigurationTable><ConfigurationTable dataShapeName="PTCDTS.DisplayNonPacemakersConfiguration" description="" isMultiRow="false" name="DisplayNonPacemakers" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="false" baseType="BOOLEAN" description="If true, non pacemakers are displayed and accounted for in Production Dashboard screens." name="DisplayNonPacemakers" ordinal="1"/></FieldDefinitions></DataShape><Rows><Row><DisplayNonPacemakers>false</DisplayNonPacemakers></Row></Rows></ConfigurationTable><ConfigurationTable dataShapeName="" description="Configuration table used to identify managers that the building block should use" isMultiRow="true" name="ManagerConfiguration" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="true" baseType="STRING" description="unique identifier for the manager that needs to be configured" name="id" ordinal="1"/><FieldDefinition aspect.isPrimaryKey="false" aspect.thingShape="PTC.Base.CommonManagement_TS" baseType="THINGNAME" description="Name of the Manager Thing to be configured" name="managerThingName" ordinal="2"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable><ConfigurationTable dataShapeName="" description="" isMultiRow="true" name="MashupConfiguration" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="true" baseType="STRING" description="unique identifier used to identify the thing or mashup that is being configured" name="id" ordinal="1"/><FieldDefinition aspect.isPrimaryKey="false" baseType="MASHUPNAME" description="name of the mashup to configure" name="mashupName" ordinal="2"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable><ConfigurationTable dataShapeName="" description="Configuration table for dynamic menus. Menu Items can be specified here and they will show up for the given menu name. " isMultiRow="true" name="MenuConfiguration" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="" name="menuItemMashupName" ordinal="2"/><FieldDefinition aspect.isPrimaryKey="true" baseType="STRING" description="" name="menuName" ordinal="3"/><FieldDefinition aspect.isPrimaryKey="false" baseType="INTEGER" description="An optional field to indicate the ordering of the menu items" name="menuOrderPreference" ordinal="5"/><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="Localization table key for the optional section that groups like menus together" name="menuSectionKey" ordinal="4"/><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="Localization table key for the menu label" name="menuTitleKey" ordinal="1"/><FieldDefinition aspect.dataShape="PTC.Base.ComponentMenuConfiguration" aspect.isPrimaryKey="false" baseType="INFOTABLE" description="" name="submenu" ordinal="6"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable><ConfigurationTable dataShapeName="" description="Configuration table for any Things that need to be configured. This allows for OOTB things to be customized, and the new version that should be used can be configured here" isMultiRow="true" name="ThingConfiguration" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="true" baseType="STRING" description="unique identifier used to identify the thing or mashup that is being configured" name="id" ordinal="1"/><FieldDefinition aspect.isPrimaryKey="false" baseType="THINGNAME" description="Name of the Thing entity or Mashup entity that is to be configured" name="thingName" ordinal="2"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable></ConfigurationTables><PropertyBindings/><RemotePropertyBindings/><RemoteServiceBindings/><RemoteEventBindings/><AlertConfigurations/><ThingShape><PropertyDefinitions/><ServiceDefinitions><ServiceDefinition aspect.isAsync="false" category="" description="" isAllowOverride="false" isLocalOnly="false" isOpen="false" isPrivate="false" name="GetChildWorkDefinitionsForJobOrder"><ResultType baseType="INFOTABLE" description="" name="result" ordinal="0"/><ParameterDefinitions><FieldDefinition baseType="STRING" description="" name="jobOrderUid" ordinal="1"/></ParameterDefinitions></ServiceDefinition><ServiceDefinition aspect.isAsync="false" category="" description="" isAllowOverride="false" isLocalOnly="false" isOpen="false" isPrivate="false" name="GetModelFromWorkDefinition"><ResultType baseType="STRING" description="" name="result" ordinal="0"/><ParameterDefinitions><FieldDefinition baseType="STRING" description="" name="workDefinitionUid" ordinal="1"/></ParameterDefinitions></ServiceDefinition><ServiceDefinition aspect.isAsync="false" category="" description="Given a pacemaker unit, finds any other parallel pacemakers in the same work center" isAllowOverride="false" isLocalOnly="false" isOpen="false" isPrivate="false" name="GetPacemakerWorkUnitsForWorkCenter"><ResultType aspect.dataShape="PTC.MfgModel.Model" baseType="INFOTABLE" description="" name="result" ordinal="0"/><ParameterDefinitions><FieldDefinition baseType="STRING" description="" name="modelUid" ordinal="1"/></ParameterDefinitions></ServiceDefinition><ServiceDefinition aspect.isAsync="false" category="" description="Gets shift view details for the given job order" isAllowOverride="true" isLocalOnly="false" isOpen="false" isPrivate="false" name="GetShiftViewDetailsForWorkUnit"><ResultType aspect.dataShape="PTC.OperationKPI.CycleTime" baseType="INFOTABLE" description="" name="result" ordinal="0"/><ParameterDefinitions><FieldDefinition aspect.isRequired="true" baseType="STRING" description="UID of job order" name="jobOrderUid" ordinal="1"/><FieldDefinition baseType="STRING" description="" name="modelUid" ordinal="2"/></ParameterDefinitions></ServiceDefinition><ServiceDefinition aspect.isAsync="false" category="" description="" isAllowOverride="false" isLocalOnly="false" isOpen="false" isPrivate="false" name="GetWorkDefinition"><ResultType aspect.dataShape="PTC.SCA.SCO.WorkDefinition" baseType="INFOTABLE" description="" name="result" ordinal="0"/><ParameterDefinitions><FieldDefinition baseType="STRING" description="" name="workDefinitionUid" ordinal="1"/></ParameterDefinitions></ServiceDefinition><ServiceDefinition aspect.isAsync="false" category="" description="" isAllowOverride="false" isLocalOnly="false" isOpen="false" isPrivate="false" name="GetWorkDefinitionForModelAndJobOrder"><ResultType baseType="STRING" description="" name="result" ordinal="0"/><ParameterDefinitions><FieldDefinition baseType="STRING" description="" name="jobOrderUid" ordinal="2"/><FieldDefinition baseType="STRING" description="" name="modelUid" ordinal="1"/></ParameterDefinitions></ServiceDefinition><ServiceDefinition aspect.isAsync="false" category="" description="" isAllowOverride="false" isLocalOnly="false" isOpen="false" isPrivate="false" name="GetWorkUnitsFromWorkCenter"><ResultType aspect.dataShape="PTC.MfgModel.Model" baseType="INFOTABLE" description="" name="result" ordinal="0"/><ParameterDefinitions><FieldDefinition baseType="STRING" description="" name="WorkCenterThingName" ordinal="1"/></ParameterDefinitions></ServiceDefinition><ServiceDefinition aspect.isAsync="false" category="" description="" isAllowOverride="false" isLocalOnly="false" isOpen="false" isPrivate="false" name="isFinalWorkUnitForJobOrder"><ResultType baseType="BOOLEAN" description="" name="result" ordinal="0"/><ParameterDefinitions><FieldDefinition baseType="STRING" description="" name="dispatchStatusUid" ordinal="3"/><FieldDefinition baseType="STRING" description="" name="jobOrderUid" ordinal="2"/><FieldDefinition baseType="STRING" description="" name="modelUid" ordinal="3"/></ParameterDefinitions></ServiceDefinition><ServiceDefinition aspect.isAsync="false" category="" description="" isAllowOverride="true" isLocalOnly="false" isOpen="false" isPrivate="false" name="StopProductionInternalWithForceOption"><ResultType baseType="INFOTABLE" description="" name="result" ordinal="0"/><ParameterDefinitions><FieldDefinition aspect.isRequired="true" baseType="STRING" description="" name="dispatchStatusUid" ordinal="2"/><FieldDefinition baseType="BOOLEAN" description="" name="forceJobOrderStop" ordinal="5"/><FieldDefinition aspect.isRequired="true" baseType="STRING" description="The job order uid." name="jobOrderUid" ordinal="3"/><FieldDefinition aspect.isRequired="true" baseType="STRING" description="" name="modelUid" ordinal="1"/><FieldDefinition baseType="DATETIME" description="Timestamp for the stop production." name="timestamp" ordinal="4"/></ParameterDefinitions></ServiceDefinition><ServiceDefinition aspect.isAsync="false" category="" description="" isAllowOverride="true" isLocalOnly="false" isOpen="false" isPrivate="false" name="StopProductionWithForceOption"><ResultType baseType="INFOTABLE" description="" name="result" ordinal="0"/><ParameterDefinitions><FieldDefinition aspect.isRequired="true" baseType="STRING" description="" name="dispatchStatusUid" ordinal="2"/><FieldDefinition baseType="BOOLEAN" description="" name="forceJobOrderStop" ordinal="5"/><FieldDefinition aspect.isRequired="true" baseType="STRING" description="The job order uid." name="jobOrderUid" ordinal="3"/><FieldDefinition aspect.isRequired="true" baseType="STRING" description="" name="modelUid" ordinal="1"/><FieldDefinition baseType="DATETIME" description="Timestamp for stop production." name="timestamp" ordinal="4"/></ParameterDefinitions></ServiceDefinition><ServiceDefinition aspect.isAsync="false" category="" description="" isAllowOverride="false" isLocalOnly="false" isOpen="false" isPrivate="false" name="UpdateAllWorkDefinitionsForJobOrder"><ResultType baseType="NOTHING" description="" name="result" ordinal="0"/><ParameterDefinitions><FieldDefinition baseType="STRING" description="" name="dispatchStatusUid" ordinal="2"/><FieldDefinition baseType="STRING" description="" name="jobOrderUid" ordinal="1"/></ParameterDefinitions></ServiceDefinition><ServiceDefinition aspect.isAsync="false" category="" description="" isAllowOverride="false" isLocalOnly="false" isOpen="false" isPrivate="false" name="UpdateWorkDefinitionStatus"><ResultType aspect.dataShape="PTC.SCA.SCO.WorkDefinition" baseType="INFOTABLE" description="" name="result" ordinal="0"/><ParameterDefinitions><FieldDefinition baseType="STRING" description="" name="executionStatus" ordinal="2"/><FieldDefinition baseType="DATETIME" description="" name="timestamp" ordinal="3"/><FieldDefinition baseType="STRING" description="" name="workDefinitionUid" ordinal="1"/></ParameterDefinitions></ServiceDefinition></ServiceDefinitions><EventDefinitions/><ServiceMappings/><ServiceImplementations><ServiceImplementation description="" handlerName="Script" name="AutoCreateOrEndProductionBlock"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[if (logger.debugEnabled) {
	logger.debug("Entering {}:AutoCreateOrEndProductionBlock");
}

if (lastExpiredShiftInstance && lastExpiredShiftInstance.rows && lastExpiredShiftInstance.rows.length > 1) {
	throw new Error("Multiple rows found for last expired shift instance.");
}

if (currentShiftInstance && currentShiftInstance.rows && currentShiftInstance.rows.length > 1) {
	throw new Error("Multiple rows found for current shift instance.");
}

if (lastProductionBlock && lastProductionBlock.rows && lastProductionBlock.rows.length > 1) {
	throw new Error("Multiple rows found for last production block.");
}

if (lastProductionBlockForPacemaker && lastProductionBlock.rows && lastProductionBlock.rows.length > 1) {
	throw new Error("Multiple rows found for last production block for pacemaker.");
}

result = processAutoCreateOrEndProductionBlock();

if (logger.debugEnabled) {
	logger.debug("Exiting {}:AutoCreateOrEndProductionBlock");
}

function isEmptyInfoTable(infotable) {
	return !infotable || !infotable.rows || infotable.rows.length == 0;
}

function processAutoCreateOrEndProductionBlock() {
	var currentTimeStamp = new Date();
	let startTime, endTime;

	if (isJobOrderRunning(lastPBJobOrderDispatchStatus)) {
		if (needToSplitProductionBlockForShiftEnd(lastProductionBlockForPacemaker, lastExpiredShiftInstance)) {
			//shift ended and jo running
			//auto end current PB
			lastProductionBlockForPacemaker.endDateTime = lastExpiredShiftInstance.actualEndTime;
			me.UpdateProductionBlocks({
				productionBlocks: lastProductionBlockForPacemaker
			});
			return processProductionBlocks(lastProductionBlockForPacemaker.jobOrderUid);
		}
		if (needToSplitProductionBlockForShiftStart(lastProductionBlockForPacemaker, currentShiftInstance)) {
			//shift started and jo running
			//auto end current PB
			lastProductionBlockForPacemaker.endDateTime = currentShiftInstance.actualStartTime;
			me.UpdateProductionBlocks({
				productionBlocks: lastProductionBlockForPacemaker
			});
			return processProductionBlocks(lastProductionBlockForPacemaker.jobOrderUid);
		} else if (needToExpireProductionBlock(lastProductionBlockForPacemaker, currentTimeStamp)) {
			return processProductionBlocks(lastProductionBlockForPacemaker.jobOrderUid,modelUid);
		}
	} else {
		if (needToCreateShiftPBForEntireShift(lastProductionBlock, lastExpiredShiftInstance)) {
			startTime = lastExpiredShiftInstance.actualStartTime;
			endTime = lastExpiredShiftInstance.actualEndTime;
			return addProductionBlock(startTime, endTime);
		} else if (needToCreateShiftPBForPBEndToShiftEnd(lastProductionBlock, lastExpiredShiftInstance)) {
			endTime = lastExpiredShiftInstance.actualEndTime;
			startTime = lastProductionBlock.endDateTime;
			return addProductionBlock(startTime, endTime);
		}
		return DataShapes["PTC.OperationKPI.ProductionBlock"].CreateValues();
	}
}

function needToSplitProductionBlockForShiftEnd(lastProductionBlockForPacemaker, lastExpiredShiftInstance) {
	return (!isEmptyInfoTable(lastExpiredShiftInstance) && !isEmptyInfoTable(lastProductionBlockForPacemaker) &&
		lastProductionBlockForPacemaker.startDateTime < lastExpiredShiftInstance.actualEndTime &&
		lastProductionBlockForPacemaker.endDateTime > lastExpiredShiftInstance.actualEndTime);
}

function needToSplitProductionBlockForShiftStart(lastProductionBlockForPacemaker, currentShiftInstance) {
	return (!isEmptyInfoTable(currentShiftInstance) && !isEmptyInfoTable(lastProductionBlockForPacemaker) &&
		lastProductionBlockForPacemaker.startDateTime < currentShiftInstance.actualStartTime &&
		lastProductionBlockForPacemaker.endDateTime > currentShiftInstance.actualStartTime);
}

function needToExpireProductionBlock(lastProductionBlockForPacemaker, currentTimeStamp) {
	return (!isEmptyInfoTable(lastProductionBlockForPacemaker) && lastProductionBlockForPacemaker.endDateTime < currentTimeStamp);

}

function needToCreateShiftPBForEntireShift(lastProductionBlock, lastExpiredShiftInstance) {
	return (!isEmptyInfoTable(lastExpiredShiftInstance) && isEmptyInfoTable(lastProductionBlock)) ||
		(!isEmptyInfoTable(lastExpiredShiftInstance) && !isEmptyInfoTable(lastProductionBlock) &&
			lastProductionBlock.endDateTime <= lastExpiredShiftInstance.actualStartTime);
}

function needToCreateShiftPBForPBEndToShiftEnd(lastProductionBlock, lastExpiredShiftInstance) {
	return (!isEmptyInfoTable(lastExpiredShiftInstance) &&
		!isEmptyInfoTable(lastProductionBlock) &&
		lastProductionBlock.endDateTime >= lastExpiredShiftInstance.actualStartTime &&
		lastProductionBlock.endDateTime < lastExpiredShiftInstance.actualEndTime);

}

function addProductionBlock(startTime, endTime) {
	let productionBlock = DataShapes["PTC.OperationKPI.ProductionBlock"].CreateValues();
	productionBlock.AddRow({
		modelUid: modelUid,
		startDateTime: startTime,
		endDateTime: endTime,
		productionBlockTypeUid: getHourByHourPBTypeUid()
	});

	let uid = me.AddProductionBlocks({
		productionBlocks: productionBlock
	}).uid;
	productionBlock.uid = uid;
	return productionBlock;
}

function isJobOrderRunning(uid) {
	return getJobOrderStatus().Find({
		uid: uid
	}).statusName == 'Running';
}

function getJobOrderStatus() {
	if (!jobOrderStatus) {
		jobOrderStatus = Things[me.GetJobOrderManager()].GetJobOrderDispatchStatuses();
	}
	return jobOrderStatus;
}

function getHourByHourPBTypeUid() {
	if (!productionBlockTypeUid) {
		let filter = {
			filters: {
				dataShapeName: "PTC.WorkMaster.ProductionBlockType",
				fieldName: "name",
				type: "EQ",
				value: "HourByHour"
			}
		};

		let hourByHour = Things[me.GetWorkMasterManager()].GetProductionBlockTypes({
			filter: filter,
			limit: 1
		});
		productionBlockTypeUid = hourByHour.uid;
	}
	return productionBlockTypeUid;
}

function createStartStopJobOrderInfos(jobOrderManager, jobOrderUid) {
	let startStopJobOrderInfos = DataShapes["PTC.OperationKPI.StartStopJobOrderInfo"].CreateValues();
	startStopJobOrderInfos.AddRow({
		jobOrderUid: jobOrderUid,
		event: "CreateNextProductionBlock",
		action: "EndProductionBlock"
	});

	return startStopJobOrderInfos;
}

function processProductionBlocks(jobOrderUid,modelUid) {
	let jobOrderManager = Things[me.GetJobOrderManager()];
	let jobOrder = jobOrderManager.GetJobOrder({
		uid: jobOrderUid
	});
    
    jobOrder.AddField({
        name: "__workUnitUid",
        baseType: 'STRING'
    });
    jobOrder.__workUnitUid = modelUid;

	let startStopJobOrderInfos = createStartStopJobOrderInfos(jobOrderManager, jobOrderUid);
	let batchServices = me.ProcessProductionBlocks({
		jobOrders: jobOrder,
		shiftInstanceUid: undefined,
		startStopJobOrderInfos: startStopJobOrderInfos,
		jobOrderStatus: getJobOrderStatus(),
		productionBlockTypeUid: getHourByHourPBTypeUid()
	});

	let batchServiceResults = me.BatchServiceExecute({
		services: batchServices
	});

	return getLastAddedProductionBlock(batchServiceResults);
}

function addBatchAction(batchActions, serviceName, pb) {
	batchActions.AddRow({
		thingName: me.name,
		serviceName: serviceName,
		parameters: pb
	});
}

function getLastAddedProductionBlock(batchServiceResults) {
	let infotable = DataShapes["PTC.OperationKPI.ProductionBlock"].CreateValues();
	let productionBlocks = [];
	batchServiceResults.rows.toArray()
		.filter(row => row.serviceName === 'AddProductionBlocks')
		.forEach(row => {
			row.values.rows.forEach(pb => productionBlocks.push(pb));
		});

	infotable.AddRow(productionBlocks[productionBlocks.length - 1]);
	return infotable;
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="GetChildWorkDefinitionsForJobOrder"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[let jobOrderManager = Things[me.GetJobOrderManager()];

// result: INFOTABLE dataShape: ""
let parentWorkDefinitionUid = Things["PTC.JobOrderImpl.Manager"].GetJobOrderWorkDefinitions({
	filter: undefined /* JSON */,
	jobOrderUID: jobOrderUid /* STRING [Required] */
}).UID;

let filters = {
   "select":[
      {
         "fieldName":"ChildUID",
         "dataShapeName":"PTC.SCA.SCO.WorkDefinitionLink"
      },
      {
         "fieldName":"ParentUID",
         "dataShapeName":"PTC.SCA.SCO.WorkDefinitionLink"
      },
       {
         "fieldName":"modelUid",
         "dataShapeName":"PTC.WorkMaster.WorkMasterModelSpecification",
         "alias": "wmms"
      }
   ],
   "filters":{
               "fieldName":"ParentUID",
               "type":"EQ",
               "value":parentWorkDefinitionUid
            },
    "joins":[{
			"type": "LEFT",
			"sourceDataShapeName": "PTC.SCA.SCO.WorkDefinitionLink",
			"sourceFieldName": "ChildUID",
			"targetDataShapeName": "PTC.SCA.SCO.WorkDefinition",
			"targetAlias": "wd",
			"targetFieldName": "UID"
		},{
			"type": "LEFT",
			"sourceDataShapeName": "PTC.SCA.SCO.WorkDefinition",
            "sourceAlias": "wd",
			"sourceFieldName": "WorkMasterUID",
			"targetDataShapeName": "PTC.WorkMaster.WorkMaster",
			"targetAlias": "wm",
			"targetFieldName": "uid"
		},{
			"type": "LEFT",
			"sourceDataShapeName": "PTC.WorkMaster.WorkMaster",
			"sourceAlias": "wm",
			"sourceFieldName": "uid",
			"targetDataShapeName": "PTC.WorkMaster.WorkMasterModelSpecification",
			"targetAlias": "wmms",
			"targetFieldName": "workMasterUid"
		}]
};

let result = me.Query({
	dataShapeName: "PTC.SCA.SCO.WorkDefinitionLink" /* DATASHAPENAME */,
	filter: filters /* JSON */,
	offset: undefined /* LONG */,
	limit: undefined /* LONG */
});]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="GetEventData"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[result = getEventData(modelUid, eventTime, jobOrderUid, materialMasterUid);

function getEventData(modelUid, eventTime, jobOrderUid, materialMasterUid) {
	const mfgModelManager = me.GetMfgModelManager();
	let jobOrderExecutionData = jobOrderUid ? getJobOrderExecutionData(jobOrderUid,modelUid) : undefined;

	return DataShapes["PTC.OperationKPI.Event"].CreateValuesWithData({
		values: {
			modelUid: modelUid,
			shiftInstanceUid: getShiftInstanceUid(modelUid, eventTime),
			materialMasterUid: materialMasterUid,
			materialMasterClassUid: getValueFromJobOrderExecutionData(jobOrderExecutionData, "materialMasterClassUid"),
			jobOrderUid: jobOrderUid,
			workCenterUid: getWorkCenterUid(mfgModelManager, modelUid),
			siteUid: getSiteUid(mfgModelManager, modelUid),
			workDefinitionRootUid: getValueFromJobOrderExecutionData(jobOrderExecutionData, "workDefinitionRootUid"),
			workMasterRootUid: getValueFromJobOrderExecutionData(jobOrderExecutionData, "workMasterRootUid"),
			idealCycleTime: jobOrderExecutionData ? jobOrderExecutionData.idealCycleTime : 0
		}
	});
}

function getValueFromJobOrderExecutionData(jobOrderExecutionData, key) {
	return jobOrderExecutionData ? jobOrderExecutionData[key] : undefined;
}

function getSiteUid(mfgModelManager, modelUid) {
	let site = Things[mfgModelManager].GetSiteFromModel({
		modelUid: modelUid
	});
	if (site.rows.length) {
		return site.uid;
	}
}

function getShiftInstanceUid(modelUid, eventTime) {
	let shiftInstance = me.GetModelShiftInstancesByDateRange({
		startDateTime: eventTime,
		endDateTime: eventTime,
		modelUid: modelUid
	});

	let shiftInstanceSize = shiftInstance.length;
	if (shiftInstanceSize == 1) {
		return shiftInstance.uid;
	} else if (shiftInstanceSize > 1) {
		let eventTimeValue = eventTime.getTime();
		return shiftInstance.rows.toArray()
		    .find(row => row.actualStartTime.getTime() <= eventTimeValue && eventTimeValue < row.actualEndTime.getTime())
		    .uid;
	}
}

function getJobOrderExecutionData(jobOrderUid, modelUid) {
	let jobOrderExecutionData = Things[me.GetJobOrderManager()].GetJobOrderExecutionData({
		jobOrderUid: jobOrderUid
	});
	if (jobOrderExecutionData.rows.length) {
        
        jobOrderExecutionData = jobOrderExecutionData.Find({modelUid:modelUid});

		let idealCycleTime = jobOrderExecutionData.idealCycleTime | 0;
		return {
			idealCycleTime: idealCycleTime,
			workDefinitionRootUid: jobOrderExecutionData.workDefinitionUid,
			workMasterRootUid: jobOrderExecutionData.workMasterUid,
			materialMasterClassUid: jobOrderExecutionData.materialMasterClassUid
		};
	}
}

function getWorkCenterUid(mfgModelManager, workUnitUid) {
	let workCenter = Things[mfgModelManager].GetWorkcenterFromWorkunit({
		workunitUid: workUnitUid
	});
	if (workCenter.rows.length) {
		//TODO : when return type of GetWorkcenterFromWorkunit is fixed, need to return uid instead of parentUid
		return workCenter.uid;
	}
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="GetJobOrderProductionSummary"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[let modelManager = Things[me.GetMfgModelManager()];

result = DataShapes["PTC.OperationKPI.JobOrderProductionSummary"].CreateValues();
let newRow = {
	jobOrderUid: jobOrderUid,
	modelUid: modelUid,
	totalProducedQuantity: 0,
	goodQuantity: 0,
	scrapQuantity: 0
};

// result: INFOTABLE dataShape: "PTC.MfgModel.Model"
let workCenterUid = modelManager.GetWorkcenterFromWorkunit({
	workunitUid: modelUid /* STRING [Required] */
}).uid;
let pacemakers = me.GetPacemakerWorkUnitsForWorkCenter({
	modelUid: workCenterUid /* STRING */
});
pacemakers.rows.toArray().forEach(row => {
    let pacemakerUid = row.uid;
    let summaryResult = me.GetProductionEvents({
        filter: getFilterForProductionEvents(jobOrderUid, pacemakerUid, startTime, endTime)
    });
    let rowForScrap = summaryResult.Find({
        reasonName: "Scrap"
    });
    if (rowForScrap) {
        newRow.scrapQuantity += rowForScrap.totalQuantity;
    }
    let rowForGood = summaryResult.Find({
        reasonName: "Production"
    });
    if (rowForGood) {
        newRow.goodQuantity += rowForGood.totalQuantity;
    }
});

newRow.totalProducedQuantity = newRow.goodQuantity + newRow.scrapQuantity;
result.AddRow(newRow);


function getFilterForProductionEvents(jobOrderUid, modelUid, startTime, endTime) {
	let filterPart = getFilterPart(jobOrderUid, modelUid, startTime, endTime);

	return {
		select: [{
				dataShapeName: "PTC.OperationKPI.ProductionEvent",
				fieldName: "quantity",
				as: "totalQuantity",
				function: "SUM"
			},
			{
				dataShapeName: "PTC.ReasonCode.ReasonType",
				fieldName: "name",
				as: "reasonName"
			}
		],
		filters: filterPart,
		joins: [{
			type: "INNER",
			sourceDataShapeName: "PTC.OperationKPI.ProductionEvent",
			sourceFieldName: "reasonTypeUid",
			targetDataShapeName: "PTC.ReasonCode.ReasonType",
			targetFieldName: "uid"
		}],
		groupBy: [{
			dataShapeName: "PTC.ReasonCode.ReasonType",
			fieldName: "name"
		}]
	};
}

function getFilterPart(jobOrderUid, modelUid, startTime, endTime) {
	let reasonTypes = ["Production", "Scrap"];
	endTime = endTime || Date.now();

	let fieldsPart = [];

	fieldsPart.push({
		dataShapeName: "PTC.OperationKPI.ProductionEvent",
		fieldName: "jobOrderUid",
		type: "EQ",
		value: jobOrderUid
	});
	fieldsPart.push({
		dataShapeName: "PTC.OperationKPI.ProductionEvent",
		fieldName: "modelUid",
		type: "EQ",
		value: modelUid
	});
	fieldsPart.push({
		dataShapeName: "PTC.ReasonCode.ReasonType",
		fieldName: "name",
		type: "IN",
		values: reasonTypes
	});

	fieldsPart.push({
		dataShapeName: "PTC.OperationKPI.ProductionEvent",
		fieldName: "eventTime",
		type: "LT",
		value: endTime
	});

	if (startTime) {
		fieldsPart.push({
			dataShapeName: "PTC.OperationKPI.ProductionEvent",
			fieldName: "eventTime",
			type: "GE",
			value: startTime
		});
	}

	return {
		filters: fieldsPart,
		type: "AND"
	};
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="GetJobSummary"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[if (logger.debugEnabled) {
	logger.debug("Entering {}:GetJobSummary with parameter modelUid:{} jobOrderUid:{}", me.name, modelUid, jobOrderUid);
}
let mfgModelManager = Things[me.GetMfgModelManager()];

let result = DataShapes["PTC.OperationKPI.JobSummary"].CreateValues();

try {
	let totals = getTotalScrapQuantityAndTotalLostTime(jobOrderUid);
	let [totalScrapQuantity, totalLostTime, actualQuantity, goodProduceQuantity, expectedProduceQuantity] = [totals.totalScrapQuantity, totals.totalLostTime, totals.actualQuantity, totals.goodProduceQuantity, totals.expectedProduceQuantity];

	let joMaterialInfo = GetJobOrderAndMaterialMasterInfo(jobOrderUid, modelUid);
	let [jobOrderNumber, target, materialNumber, materialMasterUid, idealCycleTime] = [joMaterialInfo.jobOrderNumber, joMaterialInfo.target, joMaterialInfo.materialNumber, joMaterialInfo.materialMasterUid, joMaterialInfo.idealCycleTime];

	let actualCycleTime = getActualCycleTime();
	let jobOrderOEE = getJobOrderOEE(goodProduceQuantity, idealCycleTime);
	let actualStartTime = getActualStartTime();
	let jobOrderDuration = getJobOrderRunningTime(jobOrderUid, Date.now());

	result.AddRow({
		jobOrderNumber: jobOrderNumber,
		materialNumber: materialNumber,
		jobOrderUid: jobOrderUid,
		materialMasterUid: materialMasterUid,
		actual: roundUpToFixedDecimalPlaces(actualQuantity),
		good: roundUpToFixedDecimalPlaces(goodProduceQuantity),
		scrap: roundUpToFixedDecimalPlaces(totalScrapQuantity),
		target: roundUpToFixedDecimalPlaces(target),
		actualCycleTime: actualCycleTime || idealCycleTime,
		idealCycleTime: idealCycleTime,
		timeLoss: totalLostTime,
		expectedProduceQuantity: roundUpToFixedDecimalPlaces(expectedProduceQuantity),
		jobOrderOEE: jobOrderOEE,
		actualStartTime: actualStartTime,
		jobOrderDuration: jobOrderDuration,
		remainingTime: getRemainingTime(goodProduceQuantity, target, idealCycleTime)

	});
} catch (err) {
	logger.error("Thing [{}] Service [{}] error at line [{}] : {}", me.name, err.fileName, err.lineNumber, err);
	throw ("An error has occurred. Please check the script logs for more details.");
}

if (logger.debugEnabled) {
	logger.debug("Exiting {}:GetJobSummary", me.name);
}

function getRemainingTime(good, target, idealCycleTime) {
	if (isNaN(good)) {
		good = 0;
	}
	let remainingTime = ((target - good) * idealCycleTime);
	return remainingTime;
}

function getActualStartTime() {
	let actualJobOrderStartTime = Things[me.GetJobOrderManager()].GetJobOrderActualStartTime({
		jobOrderUid: jobOrderUid
	});
	return actualJobOrderStartTime.timeStamp;
}

function getJobOrderOEE(goodProduceQuantity, idealCycleTime) {
	try {
		let jobOrderRunningTime = getJobOrderRunningTime(jobOrderUid, Date.now());
		if (jobOrderRunningTime > 0) {
			return (goodProduceQuantity * idealCycleTime) / jobOrderRunningTime;
		}
		return 0;
	} catch (err) {
		logger.error("Thing [{}] Service [{}] error at line [{}] : {}", me.name, err.fileName, err.lineNumber, err);
		throw ("An error has occurred. Please check the script logs for more details.");
	}
}

function getJobOrderRunningTime(jobOrderUid, time) {
	const jobOrderManager = me.GetJobOrderManager();
	let runningDispatchStatusUid = Things[jobOrderManager].GetJobOrderDispatchStatuses().Find({
		statusName: "Running"
	}).uid;
	return Things[jobOrderManager].GetJobOrderDispatchStatusTimeForDispatchStatus({
		dispatchStatusUid: runningDispatchStatusUid,
		jobOrderUid: jobOrderUid,
		time: time
	});
}

function getActualCycleTime() {
    let actualAndBestCycleTime = me.GetShiftViewDetailsForWorkUnit({
        jobOrderUid: jobOrderUid /* STRING [Required] */,
        modelUid: modelUid /* STRING */
    });
	return +actualAndBestCycleTime.actualCycleTime;
}

function getTotalScrapQuantityAndTotalLostTime(jobOrderUid) {
	let totalScrapQuantity = 0;
	let totalLostTime = 0;
	let goodProduceQuantity = 0;
	let actualQuantity = 0;
	let expectedProduceQuantity = 0;

	let productionBlockUids = GetProductionBlockUids(jobOrderUid, modelUid);
	const CURRENT_TIME = Date.now();

	productionBlockUids.forEach(uid => {
		let productionBlockInfo = me.GetProductionBlockInfo({
			productionBlockUid: uid
		});

		let scrap = +productionBlockInfo.scrapQuantity;
		totalScrapQuantity += scrap;

		let good = +productionBlockInfo.goodProduceQuantity;
		goodProduceQuantity += good;

		let actual = +productionBlockInfo.actualProduceQuantity;
		actualQuantity += actual;

		let expected = +productionBlockInfo.expectedProduceQuantity;
		expectedProduceQuantity += expected;

		// Skipping uncompleted block for time loss calculation
		if (productionBlockInfo.endTime <= CURRENT_TIME) {
			let lossTime = +productionBlockInfo.totalLostTime;
			totalLostTime += lossTime;
		}
	});
	if (mfgModelManager.IsPacemaker({modelUid: modelUid})) {
		let goodProduceQuantityFromOtherPacemakers = GetGoodProduceQuantityFromOtherPacemakers(jobOrderUid, modelUid);
		goodProduceQuantity += goodProduceQuantityFromOtherPacemakers;
	}

	return {
		totalScrapQuantity: totalScrapQuantity,
		// The accounting of fractional time is not supported
		totalLostTime: roundUp(totalLostTime),
		goodProduceQuantity: goodProduceQuantity,
		actualQuantity: actualQuantity,
		expectedProduceQuantity: expectedProduceQuantity
	};
}

function GetGoodProduceQuantityFromOtherPacemakers(jobOrderUid, modelUid) {
	let goodProduceQuantity = 0;
	// result: INFOTABLE dataShape: "PTC.MfgModel.Model"
	let workcenter = mfgModelManager.GetWorkcenterFromWorkunit({
		workunitUid: modelUid /* STRING [Required] */
	});

	let pacemakers = me.GetPacemakerWorkUnitsForWorkCenter({
		modelUid: workcenter.uid /* STRING */
	});
	pacemakers.rows.toArray().forEach(pacemaker => {
		//Ignore the current pacemaker as we already have the data from it
		if (pacemaker.uid != modelUid) {
			let productionBlockUids = GetProductionBlockUids(jobOrderUid, pacemaker.uid);

			productionBlockUids.forEach(uid => {
				let productionBlockInfo = me.GetProductionBlockInfo({
					productionBlockUid: uid
				});

				let good = +productionBlockInfo.goodProduceQuantity;
				goodProduceQuantity += good;

			});

		}
	});
	return goodProduceQuantity;
}

function GetProductionBlockUids(jobOrderUid, modeluid) {
	return me.GetProductionBlocks({
		filter: {
			"select": [{
				"dataShapeName": "PTC.OperationKPI.ProductionBlock",
				"fieldName": "uid",
				"as": "uid"
			}],
			"filters": {
				"filters": [{
						"type": "EQ",
						"fieldName": "jobOrderUid",
						"value": jobOrderUid
					},
					{
						"type": "EQ",
						"fieldName": "modelUid",
						"value": modeluid
					}
				],
				"type": "AND"
			}
		}
	}).rows.toArray().map(e => e.uid);
}

function GetJobOrderAndMaterialMasterInfo(jobOrderUid, modelUid) {
	let jobOrderAndMaterialInfo = Things[me.GetJobOrderManager()].GetJobOrderExecutionData({
		jobOrderUid: jobOrderUid
	});

	jobOrderAndMaterialInfo = jobOrderAndMaterialInfo.Find({
		modelUid: modelUid
	});
	let targetQuantityMultiplier = Things[me.GetAnalysisManagement()].CallGetTargetQuantityMultiplier({
		jobOrderUid: jobOrderUid /* STRING */ ,
		modelUid: modelUid /* STRING */
	}).multiplier;
	return {
		jobOrderNumber: jobOrderAndMaterialInfo.jobOrderId,
		target: jobOrderAndMaterialInfo.jobOrderMaterialRequirementQuantity * targetQuantityMultiplier,
		materialNumber: jobOrderAndMaterialInfo.materialMasterId,
		materialMasterUid: jobOrderAndMaterialInfo.materialMasterUid,
		idealCycleTime: jobOrderAndMaterialInfo.idealCycleTime
	};
}

// Round up to 1 decimal
function roundUpToFixedDecimalPlaces(value) {
	return String(+parseFloat(value).toFixed(1));
}

// Round up to integer
function roundUp(value) {
	return !!value ? Math.round(value) : 0;
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="GetModelFromWorkDefinition"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[let workMasterManager = Things[me.GetConfiguredManagerForIdentifier({
	identifier: "PTC.WorkMaster.Manager" /* STRING */
})];

let workDefinition = me.GetWorkDefinition({
	workDefinitionUid: workDefinitionUid /* STRING */
});

// result: INFOTABLE dataShape: "PTC.WorkMaster.WorkMasterModelSpecification"
let result = workMasterManager.GetWorkMasterModelSpecifications({
	workMasterUid: workDefinition.WorkMasterUID /* STRING [Required] */
}).modelUid;]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="GetPacemakerWorkUnitsForWorkCenter"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[let modelManager = Things[me.GetModelManagementManager()];
let mfgModelManager = Things[me.GetMfgModelManager()];
// CreateInfoTableFromDataShape(infoTableName:STRING("InfoTable"), dataShapeName:STRING):INFOTABLE(PTC.ModelManagement.Model)
let result = Resources["InfoTableFunctions"].CreateInfoTableFromDataShape({
    infoTableName: "InfoTable",
    dataShapeName: "PTC.MfgModel.Model"
});

// result: INFOTABLE dataShape: "PTC.ModelManagement.ModelLink"
let children = modelManager.GetModelLinksForParentUid({
    uid: modelUid /* STRING */
});

children.rows.toArray().forEach(child => {
    // result: BOOLEAN
    let isPacemaker = mfgModelManager.IsPacemaker({
        modelUid: child.childUid /* STRING */
    });
    if(isPacemaker){
        // result: INFOTABLE dataShape: "PTC.MfgModel.Model"
        let model = mfgModelManager.GetModel({
            uid: child.childUid /* STRING [Required] */
        });
		result.AddRow(model.rows[0]);
    }
});]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="GetParetoInfos"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[if (logger.debugEnabled) {
	logger.debug("Entering {}:GetParetoInfos with parameter startDateTime:{} endDateTime:{} modelUid:{}, reasonTreeNodeUid:{} eventCategoryUid:{} reasonCategoryUid:{} materialMasterUid:{} shiftInstanceUid:{} reasonModelUid:{}",
		me.name, startDateTime, endDateTime, modelUid, reasonTreeNodeUid, eventCategoryUid, reasonCategoryUid, materialMasterUid, shiftInstanceUid, reasonModelUid);
}

try {
	var result;
	const mfgModelManager = Things[me.GetMfgModelManager()];

	let isWorkunit = mfgModelManager.IsModelType({
		uid: modelUid,
		type: "Workunit"
	});
// MMM Ignore following block
//	let workcenterUid;
//	if (isWorkunit) {
//		let model = mfgModelManager.GetWorkcenterFromWorkunit({
//			workunitUid: modelUid
//		});
//		if (model && model.length > 0) {
//			workcenterUid = model.uid;
//		}
//	} else {
//		workcenterUid = modelUid;
//	}

	if (modelUid) {
		result = Things[me.GetAnalysisManagement()].GetParetoInfos({
			startDateTime: startDateTime,
			endDateTime: endDateTime,
			modelUid: modelUid,
			reasonTreeNodeUid: reasonTreeNodeUid,
			eventCategoryUid: eventCategoryUid,
			reasonCategoryUid: reasonCategoryUid,
			materialMasterUid: materialMasterUid,
			shiftInstanceUid: shiftInstanceUid,
			reasonModelUid: reasonModelUid
		});
	} else {
		result = DataShapes["PTC.OperationKPI.ParetoInfo"].CreateValues();
	}
} catch (err) {
	logger.error("Thing [{}] Service [{}] error at line [{}] : {}", me.name, err.fileName, err.lineNumber, err);
	throw ("An error has occurred. Please check the script logs for more details.");
}

if (logger.debugEnabled) {
	logger.debug("Exiting {}:GetParetoInfos", me.name);
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="GetShiftViewDetailsForWorkUnit"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[let result = DataShapes["PTC.OperationKPI.CycleTime"].CreateValues();

if (jobOrderUid) {
	const jobOrderManager = me.GetJobOrderManager();
	let jobOrderExecutionData = Things[jobOrderManager].GetJobOrderExecutionData({
		jobOrderUid: jobOrderUid
	});
	if (jobOrderExecutionData.rows.length) {
		let targetAndBestCycleTime = getTargetAndBestCycleTime(jobOrderExecutionData.workMasterUid);
		

		result.AddRow({
			actualCycleTime: me.CalculateActualCycleTime({
				jobOrderUid: jobOrderUid,
				modelUid: modelUid                                       				
			}),
			targetCycleTime: targetAndBestCycleTime ? targetAndBestCycleTime.targetCycleTime : undefined
		});
	}
}

function getTargetAndBestCycleTime(workMasterUid) {
	let workMasterConfigurationSpecifications = Things[me.GetWorkMasterManager()].GetWorkMasterConfigurationSpecificationsForWorkMaster({
		workMasterUid: workMasterUid
	});
	if (workMasterConfigurationSpecifications.rows.length) {
		return {
			targetCycleTime: workMasterConfigurationSpecifications.targetCycleTime
		};
	}
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="GetTrend2Infos"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[if (logger.debugEnabled) {
    logger.debug("Entering {}:GetTrend2Infos with parameter startDateTime:{} endDateTime:{} modelUid:{} reasonTreeNodeUid:{} eventCategoryUid:{} reasonCategoryUid:{} shiftInstanceUid:{} materialMasterUid:{} reasonModelUid:{} eventTypeUids:{} reasonTypeUid:{}",
        me.name, startDateTime, endDateTime, modelUid, reasonTreeNodeUid, eventCategoryUid, reasonCategoryUid, shiftInstanceUid, materialMasterUid, reasonModelUid, eventTypeUids, reasonTypeUid);
}

try {
    let mfgModelManager = Things[me.GetMfgModelManager()];

    let model = mfgModelManager.GetModel({
        uid: modelUid
    });

    let modelType = mfgModelManager.GetModelType({
        modelUid: modelUid
    });

    let equipmentModel = model;
    
    if (equipmentModel && equipmentModel.length > 0) {
        result = Things[me.GetAnalysisManagement()].GetTrend2Infos({
            startDateTime: startDateTime,
            endDateTime: endDateTime,
            modelUid: equipmentModel.uid,
            reasonTreeNodeUid: reasonTreeNodeUid,
            eventCategoryUid: eventCategoryUid,
            reasonCategoryUid: reasonCategoryUid,
            materialMasterUid: materialMasterUid,
            shiftInstanceUid: shiftInstanceUid,
            reasonModelUid: reasonModelUid,
            eventTypeUids: eventTypeUids,
            reasonTypeUid: reasonTypeUid,
            adjustingTimeOffset: adjustingTimeOffset,
            excludeAggregateData: excludeAggregateData
        });
    } else {
        result = DataShapes["PTC.OperationKPI.TrendInfo"].CreateValues();
    }
} catch (err) {
    logger.error("{} - {}:{} - {}", me.name, err.fileName, err.lineNumber, err);
    throw err;
}
if (logger.debugEnabled) {
    logger.debug("Exiting {}:GetTrend2Infos", me.name);
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="GetWorkDefinition"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[let defaultProductionOrderManager = Things[me.GetConfiguredManagerForIdentifier({
	identifier: "PTC.SCA.SCO.DefaultProductionOrderManager" /* STRING */
})];

// result: INFOTABLE dataShape: "PTC.SCA.SCO.WorkDefinition"
let result = defaultProductionOrderManager.GetWorkDefinition({
	UID: workDefinitionUid /* STRING [Required] */
});]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="GetWorkDefinitionForModelAndJobOrder"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[let workDefinitionUid;

let jobOrderWorkDefinitions = me.GetChildWorkDefinitionsForJobOrder({
    jobOrderUid: jobOrderUid /* STRING */
});

jobOrderWorkDefinitions.rows.toArray().forEach(row => {
    if(row.wmms_modelUid == modelUid){
        workDefinitionUid = row.ChildUID;
    }
});

let result = workDefinitionUid;]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="GetWorkUnitsFromWorkCenter"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[let workcenter = Things[WorkCenterThingName];

let workcenterUid = workcenter.GetPTCModelUid();

let displayNonPacemakers = me.GetConfigurationTable({
	tableName: "DisplayNonPacemakers" /* STRING */
}).DisplayNonPacemakers;

let result;

if(displayNonPacemakers){
    // result: INFOTABLE dataShape: "PTC.MfgModel.Model"
    result = workcenter.GetPTCAllWorkunitsInWorkcenter({
        workcenterUid: workcenterUid /* STRING [Required] */
    });
} else {
    result = me.GetPacemakerWorkUnitsForWorkCenter({
	modelUid: workcenterUid /* STRING */
});
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="isFinalWorkUnitForJobOrder"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[let jobOrderManager = Things[me.GetJobOrderManager()];
let modelManager = Things[me.GetMfgModelManager()];

//Get All work unit Work Definitions for job order
let workDefinitions = me.GetChildWorkDefinitionsForJobOrder({
	jobOrderUid: jobOrderUid /* STRING */
});

let currentModelWorkDefinitionUid = me.GetWorkDefinitionForModelAndJobOrder({
	modelUid: modelUid /* STRING */,
	jobOrderUid: jobOrderUid /* STRING */
});

let isFinalWorkUnit = true;

let displayNonPacemakers = me.GetConfigurationTable({
	tableName: "DisplayNonPacemakers" /* STRING */
}).DisplayNonPacemakers;

workDefinitions.rows.toArray().forEach(row => {
    let workDefinition = me.GetWorkDefinition({
        workDefinitionUid: row.ChildUID /* STRING */
    });
    
	if(displayNonPacemakers || isPacemakerWorkDefinition(row.ChildUID)){
        if(workDefinition && workDefinition.rows.length > 0 && workDefinition.UID != currentModelWorkDefinitionUid && workDefinition.dispatchStatus != dispatchStatusUid){
            isFinalWorkUnit = false;
        }
	}
});

result = isFinalWorkUnit;

function isPacemakerWorkDefinition(workDefinitionUid){
    let workDefinitionModelUid = me.GetModelFromWorkDefinition({
        workDefinitionUid: workDefinitionUid /* STRING */
    });
    
    return modelManager.IsPacemaker({
        modelUid: workDefinitionModelUid /* STRING */
    });
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="ProcessProductionBlocks"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[if (logger.debugEnabled) {
        logger.debug("Entering {}:ProcessProductionBlocks" +
            " with parameter shiftInstanceUid:{}", me.name, shiftInstanceUid);
    }
let jobOrderManager = Things[me.GetJobOrderManager()];
let mfgModelManager = Things[me.GetMfgModelManager()];

try{
    
    var result = DataShapes["PTC.DBConnection.BatchService"].CreateValues();

    jobOrders.rows.toArray().forEach(jobOrder => {
        let startStopJobOrderInfo = startStopJobOrderInfos.Find({
            jobOrderUid: jobOrder.uid
        });

        let workUnitUid = jobOrder.__workUnitUid;
        let UIDs = getModelPRAndMMUIDs(jobOrderManager, jobOrder, workUnitUid);

        if (isStartJobOrderEvent(jobOrder, startStopJobOrderInfo)) {
            startJobOrder(UIDs, jobOrder, result);
        } else if (isAcknowledgeTimeAccountingEvent(jobOrder, startStopJobOrderInfo)) {
            acknowledgeTimeAccounting(UIDs, jobOrder, result);
        } else if (isStopJobOrderEvent(jobOrder, startStopJobOrderInfo)) {
            stopJobOrder(UIDs, jobOrder, result);
        } else {
            logger.error('State Transistion does not require PB change: {}', startStopJobOrderInfo);
        }
    });
} catch (err) {
	logger.error("{} - {}:{} - {}", me.name, err.fileName, err.lineNumber, err);
	throw (err);
}    


if (logger.debugEnabled) {
	logger.debug("Exiting {}:ProcessProductionBlocks", me.name);
}

function handleStartOrCreateNextProductionBlock(UIDs, jobOrder, eventName, batchActions) {
	let now = new Date();
	let eventTimeStamp = jobOrder.__TimeStamp ? jobOrder.__TimeStamp : now;
	let currentPB;
    let modelUid = UIDs.modelUid;
	if (eventName == "StartJobOrder") {       
		//get current pb across WC
		currentPB = me.GetProductionBlockForTime({
			time: dateAddMilliseconds(eventTimeStamp, 1),
			modelUid: modelUid,
			childrenOnly: false
		});
	} else {
		
		currentPB = me.GetProductionBlockForTime({
			time: dateAddMilliseconds(eventTimeStamp, 1),
			modelUid: modelUid
		});
	}
	let pbConfig = getProductionBlockConfiguration(UIDs.jobOrderUid, UIDs.modelUid);
	let pbDuration = !isEmpty(pbConfig) && pbConfig.productionBlockValue > 0 ? pbConfig.productionBlockValue : 60;
	UIDs.productionBlockTypeUid = !isEmpty(pbConfig) ? pbConfig.productionBlockTypeUid : getHourByHourPBTypeUid();

	let shiftPBUIDs = {
		modelUid: UIDs.modelUid,
		productionBlockTypeUid: UIDs.productionBlockTypeUid
	};
	if (isEmpty(currentPB)) {
		let shiftInstance = me.GetModelShiftInstancesByDateRange({
			startDateTime: eventTimeStamp,
			endDateTime: eventTimeStamp,
			modelUid: UIDs.modelUid
		});

		let shiftStartTime, shiftEndTime;
		let shiftExists = false;
		if (shiftInstance && shiftInstance.rows && shiftInstance.rows.length) {
			shiftExists = true;
			shiftStartTime = shiftInstance.actualStartTime;
			shiftEndTime = shiftInstance.actualEndTime;
		}
		let prevPB;
		if (eventName == "StartJobOrder") {
			//get previous pb across WC
			prevPB = me.GetLatestProductionBlockToTime({
				time: eventTimeStamp,
				modelUid: jobOrders.__workUnitUid,
				childrenOnly: false
			});
		} else {
			prevPB = me.GetLatestProductionBlockToTime({
				time: eventTimeStamp,
				modelUid: UIDs.modelUid
			});
		}
		if (isEmpty(prevPB)) {
			//previoud pb is empty add pb from now to now + duration
			if (shiftExists && eventTimeStamp > shiftStartTime) {
				addProductionBlock(shiftPBUIDs, shiftInstance.actualStartTime, eventTimeStamp, batchActions);
			}
			addProductionBlock(UIDs, eventTimeStamp, dateAddMinutes(now, pbDuration), batchActions);
		} else {
			if (eventName == "CreateNextProductionBlock") {
				addProductionBlocksToNow(UIDs, prevPB.endDateTime, pbDuration, now, batchActions);
			} else {
				if (shiftExists) {
					let prevPbEndTime = prevPB.endDateTime;
					if (prevPB.endDateTime < shiftStartTime) {
						prevPbEndTime = shiftInstance.actualStartTime;
					}
					addProductionBlock(shiftPBUIDs, prevPbEndTime, eventTimeStamp, batchActions);
				}
				addProductionBlocksToNow(UIDs, eventTimeStamp, pbDuration, now, batchActions);
			}
		}
	} else {
		if (eventName == "CreateNextProductionBlock") {
			logger.error('{}: Production block  already exist with JobOrder: {} and modeluid: {}', eventName, jobOrder.uid, modelUid);
			throw new Error(eventName + ':Production block  already exist with JobOrderr:' + jobOrder.id);
		}
		if (currentPB.jobOrderUid) {
			logger.error('{}: Production block exist with JobOrder: {} and modeluid: {}', eventName, jobOrder.uid, modelUid);
			throw new Error(eventName + ':Production block  exist with JobOrder:' + jobOrder.uid);
		}
		// this can happen if shift end created no job order PB
		//delete any PBs if exist after eventTimestamp (they will be shift PBs)
		validateAndDeleteProductionBlocks(jobOrder, UIDs, batchActions, eventName);
		currentPB.endDateTime = eventTimeStamp;
		addBatchAction(batchActions, "UpdateProductionBlocks", {
			productionBlocks: currentPB
		});
		addProductionBlocksToNow(UIDs, eventTimeStamp, pbDuration, now, batchActions);
	}
}

function addProductionBlocksToNow(UIDs, startTime, pbDuration, now, batchActions) {
	//previous pp exist new pb is previous pb.endtime + duratrion
	let calculatedPbEndTime = dateAddMinutes(startTime, pbDuration);
	if (calculatedPbEndTime > now) {
		//add new pb from previous endtime to previous endtime + duration
		addProductionBlock(UIDs, startTime, calculatedPbEndTime, batchActions);
	} else {
		//add new pb endtime is before now add a new pb from prevuious pb endtime to now
		//gap prodcution block
		addProductionBlock(UIDs, startTime, now, batchActions);
		//add a new production block from now to now + duration
		addProductionBlock(UIDs, now, dateAddMinutes(now, pbDuration), batchActions);
	}
}

function acknowledgeTimeAccounting(UIDs, jobOrder, batchActions) {
	//only execute if job order is running
	if (isJobOrderRunning(jobOrder.dispatchStatus)) {
		handleStartOrCreateNextProductionBlock(UIDs, jobOrder, "CreateNextProductionBlock", batchActions);
	}
}

function startJobOrder(UIDs, jobOrder, batchActions) {
	handleStartOrCreateNextProductionBlock(UIDs, jobOrder, "StartJobOrder", batchActions);
}

function addProductionBlock(UIDs, startTime, endTime, batchActions) {
	let productionBlock = DataShapes["PTC.OperationKPI.ProductionBlock"].CreateValues();

	if (endTime <= startTime) {
		//no need to add as there is no gap
		return;
	}
	productionBlock.AddRow({
		jobOrderUid: UIDs.jobOrderUid,
		modelUid: UIDs.modelUid,
		startDateTime: startTime,
		endDateTime: endTime,
		processingResourceUid: UIDs.processingResourceUid,
		materialMasterUid: UIDs.materialMasterUid,
		productionBlockTypeUid: UIDs.productionBlockTypeUid
	});

	addBatchAction(batchActions, "AddProductionBlocks", {
		productionBlocks: productionBlock
	});
}

function stopJobOrder(UIDs, jobOrder, batchActions, eventName) {
	validateAndDeleteProductionBlocks(jobOrder, UIDs, batchActions, "StopJobOrder");
	let now = new Date();
	let jobOrderEventTimeStamp = jobOrder.__TimeStamp ? jobOrder.__TimeStamp : now;
	let currentPB = getPBForTime(UIDs.modelUid, jobOrderEventTimeStamp);

	if (!isEmpty(currentPB)) {
		if (jobOrderEventTimeStamp > currentPB.endDateTime) {
			logger.error("[{}] Job order [{}] event timestamp {} is later than current production block end time {}", me.name, jobOrder.uid, jobOrderEventTimeStamp.toString(), currentPB.endDateTime.toString());
			throw new Error('Job order with UID ' + jobOrder.uid + ' has event timestamp ' + jobOrderEventTimeStamp + 'later than current production block end time ' + currentPB.endDateTime);
		}
		let pbUpdate = DataShapes["PTC.OperationKPI.ProductionBlock"].CreateValuesWithData({
			values: {
				uid: currentPB.uid,
				endDateTime: jobOrderEventTimeStamp
			}
		});

		addBatchAction(batchActions, "UpdateProductionBlocks", {
			productionBlocks: pbUpdate
		});
	} else {
		// for the case when current production block ended and scheduler is yet to create next producion block
		let previousPB = getPreviousProductionblock(jobOrderEventTimeStamp, UIDs.modelUid);
		if (previousPB.length && jobOrderEventTimeStamp > previousPB.endDateTime) {
			previousPB.endDateTime = jobOrderEventTimeStamp;
			addBatchAction(batchActions, "UpdateProductionBlocks", {
				productionBlocks: previousPB
			});
		} else {
			throw new Error('No production block found at ' + jobOrderEventTimeStamp);
		}
	}
}

function validateAndDeleteProductionBlocks(jobOrder, UIDs, batchActions, eventName) {
	let productionBlocksToDelete;
	if ("StartJobOrder" == eventName) {
		productionBlocksToDelete = me.GetProductionBlocksAfterTime({
			timestamp: jobOrder.__TimeStamp,
			modelUid: UIDs.modelUid,
			childrenOnly: false
		});
	} else if ("StopJobOrder" == eventName) {
		productionBlocksToDelete = me.GetProductionBlocksAfterTime({
			timestamp: jobOrder.__TimeStamp,
			modelUid: UIDs.modelUid
		});
	} else {
		throw new Error('validateAndDeleteProductionBlocks cannot be invoked for ' + eventName);
	}
	let invalidPb = productionBlocksToDelete.rows.toArray()
		.find(pb =>
			((("StartJobOrder" == eventName) && pb.jobOrderUid) || (("StopJobOrder" == eventName) && pb.jobOrderUid != jobOrder.uid))
		);
	if (invalidPb) {
		throw new Error('validateAndDeleteProductionBlocks cannot be invoked to delete production block ' + JSON.stringify(Resources["InfoTableFunctions"].ToJSON({table: productionBlocksToDelete})));
	}
	productionBlocksToDelete.rows.toArray()
		.forEach(pb =>
			addBatchAction(batchActions, "DeleteProductionBlock", {
				uid: pb.uid
			}));
}

function getPBForTime(modelUid, time) {
	return me.GetProductionBlockForTime({
		time: time,
		modelUid: modelUid
	});
}

function isStartJobOrderEvent(jobOrder, startStopJobOrderInfo) {
	return isValidEvent(jobOrder, startStopJobOrderInfo, "StartJobOrder");
}

function isAcknowledgeTimeAccountingEvent(jobOrder, startStopJobOrderInfo) {
	return isValidEvent(jobOrder, startStopJobOrderInfo, "CreateNextProductionBlock");
}

function isJobOrderRunning(uid) {
	if (!jobOrderStatus) {
		jobOrderStatus = Things[me.GetJobOrderManager()].GetJobOrderDispatchStatuses();
	}
	return jobOrderStatus.Find({
		uid: uid
	}).statusName == 'Running';
}

function isStopJobOrderEvent(jobOrder, startStopJobOrderInfo) {
	return isValidEvent(jobOrder, startStopJobOrderInfo, "StopJobOrder");
}

function isValidEvent(jobOrder, startStopJobOrderInfo, eventName) {
	let isValidEvent = startStopJobOrderInfo.event && startStopJobOrderInfo.event === eventName;
	if (isValidEvent) {
		let isValidAction = startStopJobOrderInfo.action === 'EndProductionBlock';
		if (!isValidAction) {
			throw new Error('Invalid Event "+  eventName + " for the job order ' + jobOrder.id);
		}
		return true;
	}
	return false;
}

function getHourByHourPBTypeUid() {
	if (!productionBlockTypeUid) {
		let filter = {
			filters: {
				dataShapeName: "PTC.WorkMaster.ProductionBlockType",
				fieldName: "name",
				type: "EQ",
				value: "HourByHour"
			}
		};

		let hourByHour = Things[me.GetWorkMasterManager()].GetProductionBlockTypes({
			filter: filter,
			limit: 1
		});
		productionBlockTypeUid = hourByHour.uid;
	}

	return productionBlockTypeUid;
}

function getModelPRAndMMUIDs(jobOrderManager, jobOrder, workUnitUid) {
	let fullJOExeData = jobOrderManager.GetJobOrderExecutionData({
		jobOrderUid: jobOrder.uid
	});
    
    let joExeData = fullJOExeData.Find({
    	modelUid: workUnitUid
    });

	let wcModelUid = mfgModelManager.GetWorkcenterFromWorkunit({
		workunitUid: joExeData.modelUid
	}).uid;
	let UIDs = {
		modelUid: joExeData.modelUid,
		wcModelUid: wcModelUid,
		processingResourceUid: joExeData.processingResourceUid,
		materialMasterUid: joExeData.materialMasterUid,
		jobOrderUid: joExeData.jobOrderUid
	};

	if (!UIDs.modelUid) {
		logger.error('Cannot find model for Job Order: {}', jobOrder.uid);
		throw new Error('Cannot find model for Job Order: ' + jobOrder.id);
	}

	return UIDs;
}

function isEmpty(infotable) {
	return !infotable || infotable.rows.length == 0;
}

function getProductionBlockConfiguration(joborderUid, modelUid) {
	let productionBlockConfiguration = me.GetProductionBlockConfigurationForJobOrder({
		jobOrderUid: joborderUid
	});
	if (productionBlockConfiguration.rows.length < 1) {
		let pacemakerUid = getPacemakerModelUid(modelUid);
		productionBlockConfiguration = me.GetProductionBlockConfigurationForModel({
			modelUid: pacemakerUid ? pacemakerUid : modelUid
		});
	}
	return productionBlockConfiguration;
}

function getPacemakerModelUid(modelUid) {
	let mfgModelManager = Things[me.GetMfgModelManager()];
	let model = mfgModelManager.GetModel({
		uid: modelUid
	});

	if (model.isPacemaker) {
		return model.uid;
	} else {
		let modelType = mfgModelManager.GetModelType({
			modelUid: model.uid
		});
		if (modelType.name == "Workcenter") {
			return mfgModelManager.GetPacemakerWorkUnitInWorkCenter({
				workcenterUid: model.uid
			}).uid;
		}
	}
}

function getPreviousProductionblock(timestamp, modelUid) {
	return me.GetPreviousProductionBlock({
		time: timestamp,
		modelUid: modelUid,
		lookbackRangeTimestamp: dateAddDays(timestamp, -1)
	});
}

function addBatchAction(batchActions, serviceName, pb) {
	batchActions.AddRow({
		thingName: me.name,
		serviceName: serviceName,
		parameters: pb
	});
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="StartJobOrdersInternal"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[if (logger.debugEnabled) {
	logger.debug("Entering {}:StartJobOrdersInternal", me.name);
}

let jobOrderManager = Things[me.GetJobOrderManager()];

let isNewFlag = jobOrders.__isNew;
let updatedJobOrders;
jobOrders.RemoveField("__isNew");
jobOrders.RemoveField("__workUnitUid");

if(isNewFlag){
    //Job Order is already started
     updatedJobOrders = jobOrderManager.StartJobOrders({
        jobOrders: jobOrders
    });
}

let batchServiceResults = me.BatchServiceExecute({
	services: batchServices
});

var result = createResultInfotable();
result.AddRow({
	jobOrders: updatedJobOrders,
	batchServiceResults: batchServiceResults
});

if (logger.debugEnabled) {
	logger.debug("Exiting {}:StartJobOrdersInternal", me.name);
}

function createResultInfotable() {
	let infotable = Resources["InfoTableFunctions"].FromJSON({
		json: {
			dataShape: {
				fieldDefinitions: {}
			},
			rows: []
		}
	});

	infotable.AddField({
		name: "jobOrders",
		baseType: "INFOTABLE"
	});

	infotable.AddField({
		name: "batchServiceResults",
		baseType: "INFOTABLE"
	});

	return infotable;
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="StartProductionInternal"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[let mfgModelManager = Things[me.GetMfgModelManager()];
let workMasterManager = Things[me.GetWorkMasterManager()];
let jobOrderManager = Things[me.GetJobOrderManager()];

if (logger.debugEnabled) {
	logger.debug("Entering {}:StartProductionInternal with parameter modelUid:{} quantity:{} jobOrderUid:{} materialMasterUid:{}", me.name, modelUid, quantity, jobOrderUid, materialMasterUid);
}

try {
	let workCenterUid = getWorkCenterUid(modelUid);
	if (!timestamp) {
		timestamp = new Date();
	}
	let jobOrder;
	if (!parseInt(jobOrderUid)) {
        jobOrder = me.AddJobOrder({
            modelUid: workCenterUid,
            materialMasterUid: materialMasterUid,
            quantity: quantity,
            timestamp: timestamp
        });
	} else {
		let originalJobOrder = getJobOrder(jobOrderUid);
		let joAssignedModelUid = originalJobOrder.joModelUid;
		let wdAssignedModelUid = originalJobOrder.wdModelUid;
		validateModel(joAssignedModelUid, wdAssignedModelUid, workCenterUid);
        jobOrder = DataShapes['PTC.JobOrder.JobOrder'].CreateValues();
        
		jobOrder.AddRow({
			uid: originalJobOrder.uid
		});

		let joWorkDefUid = getWorkDefinitionUidFromJobOrder(jobOrderUid);
		if (!joWorkDefUid) {
			getWorkDefinitionUid(workCenterUid, originalJobOrder.materialMasterUid, jobOrderUid);
		}
	}
    
	if (jobOrder) {
        //Determine if the Job Order is not running (i.e. it has been started on another workunit)
        let isNewFlag = isJobOrderRunning(jobOrderUid, jobOrder.dispatchStatus);
        jobOrder.AddField({
			name: "__isNew",
			baseType: 'BOOLEAN'
        });
        jobOrder.__isNew = isNewFlag;
        
        jobOrder.AddField({
			name: "__workUnitUid",
			baseType: 'STRING'
        });
        jobOrder.__workUnitUid = modelUid;
        
        jobOrder.dispatchStatus = getRunningDispatchStatusUid();
        jobOrder.AddField({
            name: "__TimeStamp",
            baseType: 'DATETIME'
        });
        jobOrder.__TimeStamp = timestamp;
        
        
        var result = me.StartJobOrders({
            jobOrders: jobOrder
        });        		

        /**********************************************************************************
        * MMM - Update work definition Execution Status in order to track status at work unit
        ***********************************************************************************/
        //Get proper Work Definition ID
        let workDefinitionUid = me.GetWorkDefinitionForModelAndJobOrder({
            modelUid: modelUid /* STRING */,
            jobOrderUid: jobOrder.uid /* STRING */
        });
       
		//Update Status
        if(workDefinitionUid){
            
            me.UpdateWorkDefinitionStatus({
                workDefinitionUid: workDefinitionUid /* STRING */,
                executionStatus: jobOrder.dispatchStatus /* STRING */,
                timestamp: timestamp
            });
        }
        
	}
} catch (err) {
	logger.error("{} - {}:{} - {}", me.name, err.fileName, err.lineNumber, err);
	throw ("An error has occurred. Please check the script logs for more details.");
}

if (logger.debugEnabled) {
	logger.debug("Exiting {}:StartProductionInternal", me.name);
}

function isModelType(modelUid, type) {
	return mfgModelManager.IsModelType({
		uid: modelUid,
		type: type
	});
}

function validateModel(joAssignedModelUid, wdAssignedModelUid, workCenterUid) {
	if (joAssignedModelUid != workCenterUid) {
		let areaUid = mfgModelManager.GetAreaFromWorkcenter({
			workcenterUid: workCenterUid
		}).uid;

		if (joAssignedModelUid != areaUid) {
			throw new Error("Job order's assignment model is not valid");
		}
	}

	if (wdAssignedModelUid && wdAssignedModelUid != workCenterUid) {
		throw new Error("Job order's route is not valid");
	}
}

function getWorkCenterUid(modelUid) {
	if (isModelType(modelUid, "Workunit")) {
		let workCenter = mfgModelManager.GetWorkcenterFromWorkunit({
			workunitUid: modelUid
		});

		if (!workCenter.uid) {
			throw new Error("No workcenter found for given Work Unit " + modelUid);
		}

		return workCenter.uid;
	} else if (!isModelType(modelUid, "Workcenter")) {
		throw new Error("A job order can be started on Work Unit or Work Center only");
	}

	return modelUid;
}

function getRunningDispatchStatusUid() {
	let statuses = Things[me.GetJobOrderManager()].GetJobOrderDispatchStatuses();
	return statuses.Find({
		statusName: 'Running'
	}).uid;
}

function getWorkDefinitionUid(modelUid, materialMasterUid, jobOrderUid) {
	let workMasterUid = me.GetModelWorkMasterForMaterial({
		modelUid: modelUid,
		materialMasterUid: materialMasterUid
	}).uid;

	let workDefinitionUid = workMasterManager.GenerateWorkDefinition({
		workMasterUid: workMasterUid
	}).UID;

	let wdlinkInfoTable = DataShapes["PTC.JobOrder.JobOrderWorkDefinitionLink"].CreateValues();
	wdlinkInfoTable.AddRow({
		jobOrderUid: jobOrderUid,
		workDefinitionUid: workDefinitionUid
	});

	jobOrderManager.AddJobOrderWorkDefinitionLinks({
		jobOrderWorkDefinitionLinks: wdlinkInfoTable
	});
}

function getWorkDefinitionUidFromJobOrder(jobOrderUid) {
	let joWorkDef = Things[me.GetJobOrderManager()].GetJobOrderWorkDefinitions({
		jobOrderUID: jobOrderUid
	});

	let workDefUid = null;
	if (joWorkDef && joWorkDef.rows && joWorkDef.rows.length == 1) {
		workDefUid = joWorkDef.UID;
	}
	return workDefUid;
}

function getJobOrder(jobOrderUid) {
	let filter = createJobOrderFilter(jobOrderUid);
	let jobOrder = Things[me.GetJobOrderManager()].GetJobOrders({
		filter: filter,
		limit: 1
	});

	if (!jobOrder.length) {
		throw new Error("Job order not found.");
	}

	return jobOrder;
}

function createJobOrderFilter(jobOrderUid) {
	return {
		select: [{
			dataShapeName: "PTC.JobOrder.JobOrder",
			fieldName: "uid"
		}, {
			dataShapeName: "PTC.JobOrder.JobOrder",
			fieldName: "id"
		}, {
			dataShapeName: "PTC.JobOrder.JobOrder",
			fieldName: "siteUid"
		}, {
			dataShapeName: "PTC.JobOrder.JobOrderWorkDefinitionLink",
			fieldName: "workDefinitionUid"
		}, {
			dataShapeName: "PTC.JobOrder.JobOrder",
			fieldName: "dispatchStatus"
		}, {
			dataShapeName: "PTC.SCA.SCO.MaterialDefinition",
			fieldName: "MaterialMasterUID",
			as: "materialMasterUid"
		}, {
			dataShapeName: "PTC.SCA.SCO.ProcessingResource",
			fieldName: "ModelUID",
			alias: "WDPR",
			as: "wdModelUid"
		}, {
			dataShapeName: "PTC.SCA.SCO.ProcessingResource",
			fieldName: "ModelUID",
			alias: "JOPR",
			as: "joModelUid"
		}],
		filters: {
			filters: [{
				dataShapeName: "PTC.JobOrder.JobOrder",
				fieldName: "uid",
				type: "EQ",
				value: jobOrderUid
			}],
			type: "AND"
		},
		joins: [{
			type: "LEFT",
			sourceDataShapeName: "PTC.JobOrder.JobOrder",
			sourceFieldName: "uid",
			targetDataShapeName: "PTC.JobOrder.JobOrderMaterialRequirement",
			targetFieldName: "jobOrderUid"
		}, {
			type: "LEFT",
			sourceDataShapeName: "PTC.JobOrder.JobOrderMaterialRequirement",
			sourceFieldName: "materialDefinitionUid",
			targetDataShapeName: "PTC.SCA.SCO.MaterialDefinition",
			targetFieldName: "UID"
		}, {
			type: "LEFT",
			sourceDataShapeName: "PTC.JobOrder.JobOrder",
			sourceFieldName: "uid",
			targetDataShapeName: "PTC.JobOrder.JobOrderWorkDefinitionLink",
			targetFieldName: "jobOrderUid"
		}, {
			type: "LEFT",
			sourceDataShapeName: "PTC.JobOrder.JobOrderWorkDefinitionLink",
			sourceFieldName: "workDefinitionUid",
			targetDataShapeName: "PTC.SCA.SCO.WorkDefinitionProcessingResourceSpecification",
			targetFieldName: "WorkDefinitionUID"
		}, {
			type: "LEFT",
			sourceDataShapeName: "PTC.SCA.SCO.WorkDefinitionProcessingResourceSpecification",
			sourceFieldName: "ProcessingResourceUID",
			targetDataShapeName: "PTC.SCA.SCO.ProcessingResource",
			targetAlias: "WDPR",
			targetFieldName: "UID"
		}, {
			type: "LEFT",
			sourceDataShapeName: "PTC.JobOrder.JobOrder",
			sourceFieldName: "uid",
			targetDataShapeName: "PTC.JobOrder.JobOrderProcessingResourceRequirement",
			targetFieldName: "jobOrderUid"
		}, {
			type: "LEFT",
			sourceDataShapeName: "PTC.JobOrder.JobOrderProcessingResourceRequirement",
			sourceFieldName: "processingResourceUid",
			targetDataShapeName: "PTC.SCA.SCO.ProcessingResource",
			targetAlias: "JOPR",
			targetFieldName: "UID"
		}]
	};
}

function isJobOrderRunning(jobOrderUid, dispatchStatus){
    let result = false;
    if(!parseInt(jobOrderUid)){
        //Brand new job order. Was just created
        result = true;
    } else if(dispatchStatus != getRunningDispatchStatusUid()){
        //Job order was already set to running by some other work unit
        result = true;
    }
    return result;
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="StopJobOrdersInternal"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[if (logger.debugEnabled) {
	logger.debug("Entering {}:StopJobOrdersInternal", me.name);
}
let jobOrderManager = Things[me.GetJobOrderManager()];

let isFinalWorkUnit = jobOrders.__IsFinalUnit;
jobOrders.RemoveField("__IsFinalUnit");
jobOrders.RemoveField("__workUnitUid");
let updatedJobOrders = jobOrders;

if(isFinalWorkUnit){
    //Stop the job Order
     updatedJobOrders = jobOrderManager.StopJobOrders({
        jobOrders: jobOrders
    });
}

let batchServiceResults = me.BatchServiceExecute({
	services: batchServices
});

var result = createResultInfotable();

result.AddRow({
	jobOrders: updatedJobOrders,
	batchServiceResults: batchServiceResults
});

if (logger.debugEnabled) {
	logger.debug("Exiting {}:StopJobOrdersInternal", me.name);
}

function createResultInfotable() {
	let infotable = Resources["InfoTableFunctions"].FromJSON({
		json: {
			dataShape: {
				fieldDefinitions: {}
			},
			rows: []
		}
	});

	infotable.AddField({
		name: "jobOrders",
		baseType: "INFOTABLE"
	});

	infotable.AddField({
		name: "batchServiceResults",
		baseType: "INFOTABLE"
	});

	return infotable;
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="StopProductionInternal"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[if (logger.debugEnabled) {
	logger.debug("Entering {}:StopProductionInternal with parameter modelUid:{} dispatchStatusUid:{}", me.name, modelUid, dispatchStatusUid);
}

let modelManager = Things[me.GetMfgModelManager()];
// result: INFOTABLE dataShape: "PTC.MfgModel.Model"
let model = Things[modelManager.GetWorkunit({
    uid: modelUid /* STRING [Required] */
}).thingName];

try {
	if (!timestamp) {
		timestamp = new Date();
	}    
    let isFinalUnit = me.isFinalWorkUnitForJobOrder({
        jobOrderUid: jobOrderUid /* STRING */,
        dispatchStatusUid: dispatchStatusUid /* STRING */,
        modelUid:modelUid
    });
    
    /**********************************************************************************
    * MMM - Update work definition Execution Status in order to track status at work unit
    ***********************************************************************************/
    
    //Get proper Work Definition ID
    let workDefinitionUid = me.GetWorkDefinitionForModelAndJobOrder({
        modelUid: modelUid /* STRING */,
        jobOrderUid: jobOrderUid /* STRING */
    });

    //Update Status
    if(workDefinitionUid){
        me.UpdateWorkDefinitionStatus({
            workDefinitionUid: workDefinitionUid /* STRING */,
            executionStatus: dispatchStatusUid /* STRING */,
            timestamp: timestamp
        });
    }
    
	var jobOrders;
    jobOrders = DataShapes["PTC.JobOrder.JobOrder"].CreateValues();

    jobOrders.AddField({
		name: "__TimeStamp",
		baseType: 'DATETIME'
	});
    
    jobOrders.AddField({
		name: "__IsFinalUnit",
		baseType: 'BOOLEAN'
	});
    
    jobOrders.AddField({
		name: "__workUnitUid",
		baseType: 'STRING'
	});
    
	jobOrders.AddRow({
		uid: jobOrderUid,
		dispatchStatus: dispatchStatusUid,
		__TimeStamp: timestamp,
        __workUnitUid: modelUid,
        __IsFinalUnit: isFinalUnit 
	});
    
	var result = me.StopJobOrders({
		jobOrders: jobOrders
	});
    
} catch (err) {
	logger.error("{} - {}:{} - {}", me.name, err.fileName, err.lineNumber, err);
	throw ("An error has occurred. Please check the script logs for more details.");
}

if (logger.debugEnabled) {
	logger.debug("Exiting {}:StopProductionInternal", me.name);
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="StopProductionInternalWithForceOption"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[if (logger.debugEnabled) {
	logger.debug("Entering {}:StopProductionInternal with parameter modelUid:{} dispatchStatusUid:{}", me.name, modelUid, dispatchStatusUid);
}

let modelManager = Things[me.GetMfgModelManager()];
// result: INFOTABLE dataShape: "PTC.MfgModel.Model"
let model = Things[modelManager.GetWorkunit({
    uid: modelUid /* STRING [Required] */
}).thingName];

try {
	if (!timestamp) {
		timestamp = new Date();
	}
        
    let isFinalUnit = me.isFinalWorkUnitForJobOrder({
        jobOrderUid: jobOrderUid /* STRING */,
        dispatchStatusUid: dispatchStatusUid /* STRING */,
        modelUid:modelUid
    });
    
    /**********************************************************************************
    * MMM - Update work definition Execution Status in order to track status at work unit
    ***********************************************************************************/
    if(forceJobOrderStop && !isFinalUnit){
        //User is forcing the job order stop while other workunits are still running/not start yet. Need to stop production on all other running work units
        let childWorkDefinitions = me.GetChildWorkDefinitionsForJobOrder({
            jobOrderUid: jobOrderUid /* STRING */
        });
        
        childWorkDefinitions.rows.toArray().forEach(row => {
            if(row.wmms_modelUid != modelUid){
                let childWorkDefinition = me.GetWorkDefinition({
                    workDefinitionUid: row.ChildUID /* STRING */
                });

                if(childWorkDefinition.dispatchStatus && childWorkDefinition.dispatchStatus == 9){
                    me.StopProduction({
                        modelUid: row.wmms_modelUid /* STRING [Required] */,
                        dispatchStatusUid: dispatchStatusUid /* STRING [Required] */,
                        jobOrderUid: jobOrderUid /* STRING [Required] */,
                        timestamp: timestamp /* DATETIME */
                    });
                }
            }
        });
    }
    //Get proper Work Definition ID
    let workDefinitionUid = me.GetWorkDefinitionForModelAndJobOrder({
        modelUid: modelUid /* STRING */,
        jobOrderUid: jobOrderUid /* STRING */
    });

    //Update Status
    if(workDefinitionUid){
        me.UpdateWorkDefinitionStatus({
            workDefinitionUid: workDefinitionUid /* STRING */,
            executionStatus: dispatchStatusUid /* STRING */,
            timestamp:timestamp
        });
    }
    
	var jobOrders;
    jobOrders = DataShapes["PTC.JobOrder.JobOrder"].CreateValues();

    jobOrders.AddField({
		name: "__TimeStamp",
		baseType: 'DATETIME'
	});
    
    jobOrders.AddField({
		name: "__IsFinalUnit",
		baseType: 'BOOLEAN'
	});
    
    jobOrders.AddField({
		name: "__workUnitUid",
		baseType: 'STRING'
	});
    
	jobOrders.AddRow({
		uid: jobOrderUid,
		dispatchStatus: dispatchStatusUid,
		__TimeStamp: timestamp,
        __workUnitUid: modelUid,
        __IsFinalUnit: forceJobOrderStop || isFinalUnit 
	});
    
	var result = me.StopJobOrders({
		jobOrders: jobOrders
	});
    
} catch (err) {
	logger.error("{} - {}:{} - {}", me.name, err.fileName, err.lineNumber, err);
	throw ("An error has occurred. Please check the script logs for more details.");
}

if (logger.debugEnabled) {
	logger.debug("Exiting {}:StopProductionInternal", me.name);
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="StopProductionWithForceOption"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[if (logger.debugEnabled) {
	logger.debug("Entering {}:StopProduction with parameter modelUid:{} dispatchStatusUid:{}", me.name, modelUid, dispatchStatusUid);
}
var result = me.StopProductionInternalWithForceOption({
	dispatchStatusUid: dispatchStatusUid,
	modelUid: modelUid,
	jobOrderUid: jobOrderUid,
	timestamp: timestamp,
    forceJobOrderStop: forceJobOrderStop
});
if (logger.debugEnabled) {
	logger.debug("Exiting {}:StopProduction", me.name);
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="UpdateAllWorkDefinitionsForJobOrder"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[//Get All work unit Work Definitions for job order
let workDefinitions = me.GetChildWorkDefinitionsForJobOrder({
    jobOrderUid: jobOrderUid /* STRING */
});

let displayNonPacemakers = me.GetConfigurationTable({
    tableName: "DisplayNonPacemakers" /* STRING */
}).DisplayNonPacemakers;

workDefinitions.rows.toArray().forEach(row => {
    let workDefinition = me.GetWorkDefinition({
        workDefinitionUid: row.ChildUID /* STRING */
    });

    if(displayNonPacemakers || isPacemakerWorkDefinition(row.ChildUID)){
        me.UpdateWorkDefinitionStatus({
            workDefinitionUid: workDefinition.UID /* STRING */,
            executionStatus: dispatchStatusUid /* STRING */
        });
    }
});]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="UpdateWorkDefinitionStatus"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[let defaultProductionOrderManager = Things[me.GetConfiguredManagerForIdentifier({
	identifier: "PTC.SCA.SCO.DefaultProductionOrderManager" /* STRING */
})];

// result: INFOTABLE dataShape: "PTC.SCA.SCO.WorkDefinition"
let workDefinition = me.GetWorkDefinition({
	workDefinitionUid: workDefinitionUid /* STRING */
});
workDefinition.AddField({
    name: "__TimeStamp",
    baseType: 'DATETIME'
});
workDefinition.__TimeStamp = timestamp;

workDefinition.dispatchStatus = executionStatus;

// result: INFOTABLE dataShape: ""
let result = defaultProductionOrderManager.UpdateWorkDefinitions({
	WorkDefinitions: workDefinition /* INFOTABLE {"dataShape":"PTC.SCA.SCO.WorkDefinition"} */
});]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation></ServiceImplementations><Subscriptions/></ThingShape><ImplementedShapes/><SharedConfigurationTables/><InstanceDesignTimePermissions><Create/><Read/><Update/><Delete/><Metadata/></InstanceDesignTimePermissions><InstanceRunTimePermissions/><InstanceVisibilityPermissions><Visibility/></InstanceVisibilityPermissions><ConfigurationChanges><ConfigurationChange changeAction="CREATE" changeReason="Importing Extension Package Metadata" timestamp="2023-08-29T15:25:37.378Z" user="SuperUser"/></ConfigurationChanges></ThingTemplate></ThingTemplates><ExtensionPackages/><Organizations><Organization aspect.isEditableExtensionObject="true" aspect.isExtension="true" description="" documentationContent="" homeMashup="" lastModifiedDate="2023-08-29T15:25:37.368Z" loginButtonStyle="" loginPrompt="" loginResetPassword="false" loginStyle="" mobileMashup="" name="PTCDTS.OperationKPIImpl.Default_OR" projectName="PTCDTS.OperationKPIImpl" resetMailContent="&lt;p&gt;[[resetemail.requestmade]]&lt;/p&gt;&lt;p&gt;[[resetemail.instructions]]&lt;/p&gt;&lt;p&gt;[[resetemail.helpneeded]]&lt;/p&gt;" resetMailServer="" resetMailSubject="[[resetemail.subject]]" tags=""><Owner name="SuperUser" type="User"/><avatar/><DesignTimePermissions><Create/><Read/><Update/><Delete/><Metadata/></DesignTimePermissions><RunTimePermissions/><VisibilityPermissions><Visibility/></VisibilityPermissions><ConfigurationTableDefinitions/><ConfigurationTables/><loginImage/><Connections><Connection from="" to="Root"/><Connection from="Root" to="PTCDTS.OperationKPIImpl.Admin_UG"/><Connection from="Root" to="PTCDTS.OperationKPIImpl.Default_UG"/></Connections><OrganizationalUnits><OrganizationalUnit description="" name="PTCDTS.OperationKPIImpl.Admin_UG"><Members><Members><Member name="PTCDTS.OperationKPIImpl.Admin_UG" type="Group"/></Members></Members></OrganizationalUnit><OrganizationalUnit description="" name="PTCDTS.OperationKPIImpl.Default_UG"><Members><Members><Member name="PTCDTS.OperationKPIImpl.Default_UG" type="Group"/></Members></Members></OrganizationalUnit><OrganizationalUnit description="" name="Root"><Members><Members/></Members></OrganizationalUnit></OrganizationalUnits><ConfigurationChanges><ConfigurationChange changeAction="CREATE" changeReason="Importing Extension Package Metadata" timestamp="2023-08-29T15:25:37.368Z" user="SuperUser"/></ConfigurationChanges></Organization></Organizations><Menus/><ThingGroups/><Resources/><DataTags/><ThingShapes><ThingShape aspect.isEditableExtensionObject="true" aspect.isExtension="true" className="" description="" documentationContent="" homeMashup="" lastModifiedDate="2023-08-29T15:25:37.370Z" name="PTCDTS.OperationKPIImpl.ModelLogic_TS" projectName="PTCDTS.OperationKPIImpl" tags=""><PropertyDefinitions/><ServiceDefinitions/><EventDefinitions/><ServiceMappings/><ServiceImplementations/><Subscriptions/><Owner name="SuperUser" type="User"/><avatar/><DesignTimePermissions><Create/><Read/><Update/><Delete/><Metadata/></DesignTimePermissions><RunTimePermissions/><VisibilityPermissions><Visibility/></VisibilityPermissions><ConfigurationTableDefinitions/><ConfigurationTables/><PropertyBindings/><RemotePropertyBindings/><RemoteServiceBindings/><RemoteEventBindings/><AlertConfigurations/><InstanceRunTimePermissions/><ConfigurationChanges><ConfigurationChange changeAction="CREATE" changeReason="Importing Extension Package Metadata" timestamp="2023-08-29T15:25:37.370Z" user="SuperUser"/></ConfigurationChanges></ThingShape></ThingShapes><Subsystems/><NotificationContents/></Entities>