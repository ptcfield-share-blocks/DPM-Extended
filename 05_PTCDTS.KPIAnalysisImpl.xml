<?xml version="1.0" encoding="UTF-8" standalone="no"?><Entities build="b141" majorVersion="9" minorVersion="5" modelPersistenceProviderPackage="MssqlPersistenceProviderPackage" revision="0" schemaVersion="1150" universal=""><StyleDefinitions/><Networks/><PersistenceProviderPackages/><Mashups/><ScriptFunctionLibraries/><Projects><Project artifactId="" aspect.isEditableExtensionObject="true" aspect.isExtension="true" aspect.projectType="Component" dependsOn="{&quot;extensions&quot;:&quot;&quot;,&quot;projects&quot;:&quot;PTC.KPIAnalysisImpl:0.0.0,PTCDTS.WorkDefinitionExecutionResponse:0.0.0&quot;}" description="" documentationContent="" groupId="" homeMashup="" lastModifiedDate="2024-01-23T19:48:35.891Z" minPlatformVersion="" name="PTCDTS.KPIAnalysisImpl" packageVersion="1.0.0" projectName="PTCDTS.KPIAnalysisImpl" publishResult="" state="DRAFT" tags=""><Owner name="SuperUser" type="User"/><avatar/><DesignTimePermissions><Create/><Read/><Update/><Delete/><Metadata/></DesignTimePermissions><RunTimePermissions/><VisibilityPermissions><Visibility><Principal isPermitted="true" name="PTCDTS.KPIAnalysisImpl.Default_OR" type="Organization"/><Principal isPermitted="true" name="PTCDTS.KPIAnalysisImpl.Default_OR:PTCDTS.KPIAnalysisImpl.Admin_UG" type="OrganizationalUnit"/></Visibility></VisibilityPermissions><ConfigurationTableDefinitions/><ConfigurationTables/><ConfigurationChanges><ConfigurationChange changeAction="CREATE" changeReason="Importing Extension Package Metadata" timestamp="2024-01-23T19:43:02.170Z" user="SuperUser"/><ConfigurationChange changeAction="MODIFY" changeReason="AddVisibilityPermission" timestamp="2024-01-23T19:48:35.889Z" user="Administrator"/><ConfigurationChange changeAction="MODIFY" changeReason="AddVisibilityPermission" timestamp="2024-01-23T19:48:35.892Z" user="Administrator"/></ConfigurationChanges></Project></Projects><Users/><DirectoryServices/><Widgets/><MediaEntities/><Groups><Group aspect.isEditableExtensionObject="true" aspect.isExtension="true" description="" documentationContent="" homeMashup="" lastModifiedDate="2024-01-23T19:48:35.910Z" name="PTCDTS.KPIAnalysisImpl.Default_UG" projectName="PTCDTS.KPIAnalysisImpl" scimDisplayName="" scimExternalId="" scimId="" tags=""><Owner name="SuperUser" type="User"/><avatar/><DesignTimePermissions><Create/><Read/><Update/><Delete/><Metadata/></DesignTimePermissions><RunTimePermissions/><VisibilityPermissions><Visibility><Principal isPermitted="true" name="PTCDTS.KPIAnalysisImpl.Default_OR" type="Organization"/><Principal isPermitted="true" name="PTCDTS.KPIAnalysisImpl.Default_OR:PTCDTS.KPIAnalysisImpl.Admin_UG" type="OrganizationalUnit"/></Visibility></VisibilityPermissions><ConfigurationTableDefinitions/><ConfigurationTables/><Members><Members><Member name="PTCDTS.Base.Permissions.Default_UG" type="Group"/></Members></Members><ConfigurationChanges><ConfigurationChange changeAction="CREATE" changeReason="Importing Extension Package Metadata" timestamp="2024-01-23T19:43:02.145Z" user="SuperUser"/><ConfigurationChange changeAction="MODIFY" changeReason="AddVisibilityPermission" timestamp="2024-01-23T19:48:35.908Z" user="Administrator"/><ConfigurationChange changeAction="MODIFY" changeReason="AddVisibilityPermission" timestamp="2024-01-23T19:48:35.911Z" user="Administrator"/></ConfigurationChanges></Group><Group aspect.isEditableExtensionObject="true" aspect.isExtension="true" description="" documentationContent="" homeMashup="" lastModifiedDate="2024-01-23T19:48:35.897Z" name="PTCDTS.KPIAnalysisImpl.Admin_UG" projectName="PTCDTS.KPIAnalysisImpl" scimDisplayName="" scimExternalId="" scimId="" tags=""><Owner name="SuperUser" type="User"/><avatar/><DesignTimePermissions><Create/><Read/><Update/><Delete/><Metadata/></DesignTimePermissions><RunTimePermissions/><VisibilityPermissions><Visibility><Principal isPermitted="true" name="PTCDTS.KPIAnalysisImpl.Default_OR" type="Organization"/><Principal isPermitted="true" name="PTCDTS.KPIAnalysisImpl.Default_OR:PTCDTS.KPIAnalysisImpl.Admin_UG" type="OrganizationalUnit"/></Visibility></VisibilityPermissions><ConfigurationTableDefinitions/><ConfigurationTables/><Members><Members><Member name="PTCDTS.Base.Permissions.ApplicationAdmin_UG" type="Group"/></Members></Members><ConfigurationChanges><ConfigurationChange changeAction="CREATE" changeReason="Importing Extension Package Metadata" timestamp="2024-01-23T19:43:02.146Z" user="SuperUser"/><ConfigurationChange changeAction="MODIFY" changeReason="AddVisibilityPermission" timestamp="2024-01-23T19:48:35.895Z" user="Administrator"/><ConfigurationChange changeAction="MODIFY" changeReason="AddVisibilityPermission" timestamp="2024-01-23T19:48:35.898Z" user="Administrator"/></ConfigurationChanges></Group></Groups><PersistenceProviders/><ModelTags/><LocalizationTables/><Dashboards/><StyleThemes/><DataShapes/><Things><Thing aspect.isEditableExtensionObject="true" aspect.isExtension="true" aspect.isSystemObject="false" description="Custom Impl of KPIAnalysisImpl to add custom metrics" documentationContent="" effectiveThingPackage="ConfiguredThing" enabled="true" homeMashup="" identifier="" inheritedValueStream="" lastModifiedDate="2024-01-23T19:48:35.980Z" name="PTCDTS.KPIAnalysisImpl.EntryPoint" projectName="PTCDTS.KPIAnalysisImpl" published="false" tags="" thingTemplate="PTCDTS.KPIAnalysisImpl.EntryPoint_TT" valueStream=""><Owner name="SuperUser" type="User"/><avatar/><DesignTimePermissions><Create/><Read/><Update/><Delete/><Metadata/></DesignTimePermissions><RunTimePermissions/><VisibilityPermissions><Visibility><Principal isPermitted="true" name="PTCDTS.KPIAnalysisImpl.Default_OR" type="Organization"/><Principal isPermitted="true" name="PTCDTS.KPIAnalysisImpl.Default_OR:PTCDTS.KPIAnalysisImpl.Admin_UG" type="OrganizationalUnit"/></Visibility></VisibilityPermissions><ConfigurationTableDefinitions/><ConfigurationTables><ConfigurationTable dataShapeName="" description="Configuration table to store the components core manager" isMultiRow="true" name="ComponentManager" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="true" baseType="STRING" description="unique identifier for the manager that needs to be configured" name="id" ordinal="1"/><FieldDefinition aspect.isPrimaryKey="false" aspect.thingShape="PTC.Base.CommonManagement_TS" baseType="THINGNAME" description="Name of the Manager Thing to be configured" name="managerThingName" ordinal="2"/></FieldDefinitions></DataShape><Rows><Row><id><![CDATA[ComponentManager]]></id><managerThingName><![CDATA[PTCDTS.KPIAnalysisImpl.Manager]]></managerThingName></Row></Rows></ConfigurationTable></ConfigurationTables><ThingShape><PropertyDefinitions/><ServiceDefinitions/><EventDefinitions/><ServiceMappings/><ServiceImplementations/><Subscriptions/></ThingShape><PropertyBindings/><RemotePropertyBindings/><RemoteServiceBindings/><RemoteEventBindings/><AlertConfigurations/><ImplementedShapes/><ThingProperties><componentDefaultOrg><Value><![CDATA[PTCDTS.KPIAnalysisImpl.Default_OR]]></Value><Timestamp>2023-05-11T15:29:04.375Z</Timestamp><Quality>GOOD</Quality></componentDefaultOrg><componentDefaultUserGroup><Value><![CDATA[PTCDTS.KPIAnalysisImpl.Default_UG]]></Value><Timestamp>2023-05-11T15:29:04.375Z</Timestamp><Quality>GOOD</Quality></componentDefaultUserGroup><componentDeploymentState><Value><![CDATA[Configured]]></Value><Timestamp>2024-01-23T19:43:56.372Z</Timestamp><Quality>GOOD</Quality></componentDeploymentState><componentDescription><Value><![CDATA[Custom Impl of KPIAnalysisImpl to add custom metrics]]></Value><Timestamp>2023-05-11T15:29:04.375Z</Timestamp><Quality>GOOD</Quality></componentDescription><componentMainMashup><Value/><Timestamp>2024-01-23T19:43:02.216Z</Timestamp><Quality>GOOD</Quality></componentMainMashup><componentName><Value><![CDATA[PTCDTS.KPIAnalysisImpl]]></Value><Timestamp>2023-05-11T15:29:04.375Z</Timestamp><Quality>GOOD</Quality></componentName><componentThumbnail><Value/><Timestamp>2024-01-23T19:43:02.216Z</Timestamp><Quality>GOOD</Quality></componentThumbnail><componentType><Value><![CDATA[Implementation]]></Value><Timestamp>2023-05-11T15:29:04.375Z</Timestamp><Quality>GOOD</Quality></componentType><componentVersion><Value><![CDATA[9.5.0]]></Value><Timestamp>2023-05-11T15:29:04.410Z</Timestamp><Quality>GOOD</Quality></componentVersion><dependentComponents><Value><infoTable><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="Common name of the component" name="ComponentName" ordinal="1"/><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="Component's project name" name="ComponentProjectName" ordinal="2"/></FieldDefinitions></DataShape><Rows/></infoTable></Value><Timestamp>2024-01-23T19:43:02.215Z</Timestamp><Quality>GOOD</Quality></dependentComponents><deployComponentStatus><Value><infoTable><DataShape><FieldDefinitions><FieldDefinition aspect.defaultValue="{}" aspect.isPrimaryKey="false" baseType="JSON" description="Information about the internal status." name="additionalInfo" ordinal="4"/><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="Name of the Component" name="name" ordinal="1"/><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="config status of the component" name="status" ordinal="3"/><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="Type of action." name="type" ordinal="2"/></FieldDefinitions></DataShape><Rows/></infoTable></Value><Timestamp>2024-01-23T19:43:02.215Z</Timestamp><Quality>GOOD</Quality></deployComponentStatus><migrateComponentStatus><Value><infoTable><DataShape><FieldDefinitions><FieldDefinition aspect.defaultValue="{}" aspect.isPrimaryKey="false" baseType="JSON" description="Information about the internal status." name="additionalInfo" ordinal="4"/><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="Name of the Component" name="name" ordinal="1"/><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="config status of the component" name="status" ordinal="3"/><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="Type of action." name="type" ordinal="2"/></FieldDefinitions></DataShape><Rows/></infoTable></Value><Timestamp>2024-01-23T19:43:02.215Z</Timestamp><Quality>GOOD</Quality></migrateComponentStatus><upgradeComponentStatus><Value><infoTable><DataShape><FieldDefinitions><FieldDefinition aspect.defaultValue="{}" aspect.isPrimaryKey="false" baseType="JSON" description="Information about the internal status." name="additionalInfo" ordinal="4"/><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="Name of the Component" name="name" ordinal="1"/><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="config status of the component" name="status" ordinal="3"/><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="Type of action." name="type" ordinal="2"/></FieldDefinitions></DataShape><Rows/></infoTable></Value><Timestamp>2024-01-23T19:43:02.216Z</Timestamp><Quality>GOOD</Quality></upgradeComponentStatus><componentAbstractBlockName><Value/><Timestamp>2024-01-23T19:43:02.216Z</Timestamp><Quality>GOOD</Quality></componentAbstractBlockName></ThingProperties><ConfigurationChanges><ConfigurationChange changeAction="CREATE" changeReason="Importing Extension Package Metadata" timestamp="2024-01-23T19:43:02.175Z" user="SuperUser"/><ConfigurationChange changeAction="MODIFY" changeReason="AddVisibilityPermission" timestamp="2024-01-23T19:48:35.914Z" user="Administrator"/><ConfigurationChange changeAction="MODIFY" changeReason="AddVisibilityPermission" timestamp="2024-01-23T19:48:35.917Z" user="Administrator"/><ConfigurationChange changeAction="DELETE" changeReason="DeleteRunTimePermissions" timestamp="2024-01-23T19:48:35.960Z" user="Administrator"/><ConfigurationChange changeAction="DELETE" changeReason="DeleteRunTimePermissions" timestamp="2024-01-23T19:48:35.962Z" user="Administrator"/><ConfigurationChange changeAction="DELETE" changeReason="DeleteRunTimePermissions" timestamp="2024-01-23T19:48:35.965Z" user="Administrator"/><ConfigurationChange changeAction="DELETE" changeReason="DeleteRunTimePermissions" timestamp="2024-01-23T19:48:35.967Z" user="Administrator"/><ConfigurationChange changeAction="DELETE" changeReason="DeleteRunTimePermissions" timestamp="2024-01-23T19:48:35.969Z" user="Administrator"/><ConfigurationChange changeAction="DELETE" changeReason="DeleteRunTimePermissions" timestamp="2024-01-23T19:48:35.972Z" user="Administrator"/><ConfigurationChange changeAction="DELETE" changeReason="DeleteRunTimePermissions" timestamp="2024-01-23T19:48:35.974Z" user="Administrator"/><ConfigurationChange changeAction="DELETE" changeReason="DeleteRunTimePermissions" timestamp="2024-01-23T19:48:35.976Z" user="Administrator"/><ConfigurationChange changeAction="DELETE" changeReason="DeleteRunTimePermissions" timestamp="2024-01-23T19:48:35.979Z" user="Administrator"/><ConfigurationChange changeAction="DELETE" changeReason="DeleteRunTimePermissions" timestamp="2024-01-23T19:48:35.981Z" user="Administrator"/></ConfigurationChanges></Thing><Thing aspect.isEditableExtensionObject="true" aspect.isExtension="true" description="" documentationContent="" effectiveThingPackage="SQLThingPackage" enabled="true" homeMashup="" identifier="" inheritedValueStream="" lastModifiedDate="2024-01-23T19:48:36.095Z" name="PTCDTS.KPIAnalysisImpl.SQLThingUtility" projectName="PTCDTS.KPIAnalysisImpl" published="false" tags="" thingTemplate="PTCDTS.KPIAnalysisImpl.SQLThingUtility_TT" valueStream=""><Owner name="SuperUser" type="User"/><avatar/><DesignTimePermissions><Create/><Read/><Update/><Delete/><Metadata/></DesignTimePermissions><RunTimePermissions/><VisibilityPermissions><Visibility><Principal isPermitted="true" name="PTCDTS.KPIAnalysisImpl.Default_OR" type="Organization"/><Principal isPermitted="true" name="PTCDTS.KPIAnalysisImpl.Default_OR:PTCDTS.KPIAnalysisImpl.Admin_UG" type="OrganizationalUnit"/></Visibility></VisibilityPermissions><ConfigurationTableDefinitions/><ConfigurationTables><ConfigurationTable dataShapeName="" description="Connection Monitoring Settings" isMultiRow="false" name="ConnectionMonitoring" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.defaultValue="30000.0" aspect.friendlyName="Monitor Rate (milliseconds)" baseType="NUMBER" description="Monitor rate in milliseconds" name="connectionMonitorRate" ordinal="1"/><FieldDefinition aspect.defaultValue="false" aspect.friendlyName="Enable Monitoring" baseType="BOOLEAN" description="Enable connection monitoring" name="enableMonitor" ordinal="0"/><FieldDefinition aspect.defaultValue="1.0" aspect.friendlyName="Number of Retries" baseType="NUMBER" description="Number of retries" name="numberOfRetries" ordinal="2"/><FieldDefinition aspect.defaultValue="2000.0" aspect.friendlyName="Retry Delay (milliseconds)" baseType="NUMBER" description="Retry delay in milliseconds" name="retryDelay" ordinal="3"/></FieldDefinitions></DataShape><Rows><Row><connectionMonitorRate>30000.0</connectionMonitorRate><enableMonitor>false</enableMonitor><numberOfRetries>1.0</numberOfRetries><retryDelay>2000.0</retryDelay></Row></Rows></ConfigurationTable><ConfigurationTable dataShapeName="" description="Connection Provider" isMultiRow="false" name="ConnectionProvider" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.defaultValue="false" aspect.friendlyName="Participate in platform transactions" baseType="BOOLEAN" description="Participate in platform transactions" name="isTransactional" ordinal="0"/><FieldDefinition aspect.defaultValue="ThingworxPersistenceProvider" aspect.friendlyName="Persistence Provider Name" baseType="PERSISTENCEPROVIDERNAME" description="The Persistence Provider from which to retrieve connections" name="persistenceProviderName" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><isTransactional>false</isTransactional><persistenceProviderName><![CDATA[PTC.DBConnection.JdbcPersistenceProvider]]></persistenceProviderName></Row></Rows></ConfigurationTable><ConfigurationTable dataShapeName="" description="Field/Column Name Aliases" isMultiRow="true" name="ColumnAliases" ordinal="1"><DataShape><FieldDefinitions><FieldDefinition aspect.friendlyName="Database Column Name" baseType="STRING" description="Database column name" name="columnName" ordinal="0"/><FieldDefinition aspect.friendlyName="Thingworx Field Name" baseType="STRING" description="Thingworx field name" name="fieldName" ordinal="1"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable></ConfigurationTables><ThingShape><PropertyDefinitions/><ServiceDefinitions/><EventDefinitions/><ServiceMappings/><ServiceImplementations/><Subscriptions/></ThingShape><PropertyBindings/><RemotePropertyBindings/><RemoteServiceBindings/><RemoteEventBindings/><AlertConfigurations/><ImplementedShapes/><ThingProperties/><ConfigurationChanges><ConfigurationChange changeAction="CREATE" changeReason="Importing Extension Package Metadata" timestamp="2024-01-23T19:43:02.172Z" user="SuperUser"/><ConfigurationChange changeAction="MODIFY" changeReason="AddVisibilityPermission" timestamp="2024-01-23T19:48:35.945Z" user="Administrator"/><ConfigurationChange changeAction="MODIFY" changeReason="AddVisibilityPermission" timestamp="2024-01-23T19:48:35.948Z" user="Administrator"/><ConfigurationChange changeAction="DELETE" changeReason="DeleteRunTimePermissions" timestamp="2024-01-23T19:48:36.074Z" user="Administrator"/><ConfigurationChange changeAction="DELETE" changeReason="DeleteRunTimePermissions" timestamp="2024-01-23T19:48:36.077Z" user="Administrator"/><ConfigurationChange changeAction="DELETE" changeReason="DeleteRunTimePermissions" timestamp="2024-01-23T19:48:36.079Z" user="Administrator"/><ConfigurationChange changeAction="DELETE" changeReason="DeleteRunTimePermissions" timestamp="2024-01-23T19:48:36.081Z" user="Administrator"/><ConfigurationChange changeAction="DELETE" changeReason="DeleteRunTimePermissions" timestamp="2024-01-23T19:48:36.084Z" user="Administrator"/><ConfigurationChange changeAction="DELETE" changeReason="DeleteRunTimePermissions" timestamp="2024-01-23T19:48:36.086Z" user="Administrator"/><ConfigurationChange changeAction="DELETE" changeReason="DeleteRunTimePermissions" timestamp="2024-01-23T19:48:36.089Z" user="Administrator"/><ConfigurationChange changeAction="DELETE" changeReason="DeleteRunTimePermissions" timestamp="2024-01-23T19:48:36.091Z" user="Administrator"/><ConfigurationChange changeAction="DELETE" changeReason="DeleteRunTimePermissions" timestamp="2024-01-23T19:48:36.093Z" user="Administrator"/><ConfigurationChange changeAction="DELETE" changeReason="DeleteRunTimePermissions" timestamp="2024-01-23T19:48:36.096Z" user="Administrator"/></ConfigurationChanges></Thing><Thing aspect.isEditableExtensionObject="true" aspect.isExtension="true" aspect.isSystemObject="false" description="Custom Impl of KPIAnalysisImpl to add custom metrics" documentationContent="" effectiveThingPackage="ConfiguredThing" enabled="true" homeMashup="" identifier="" inheritedValueStream="" lastModifiedDate="2024-01-23T19:48:36.052Z" name="PTCDTS.KPIAnalysisImpl.Manager" projectName="PTCDTS.KPIAnalysisImpl" published="false" tags="" thingTemplate="PTCDTS.KPIAnalysisImpl.Manager_TT" valueStream=""><Owner name="SuperUser" type="User"/><avatar/><DesignTimePermissions><Create/><Read/><Update/><Delete/><Metadata/></DesignTimePermissions><RunTimePermissions/><VisibilityPermissions><Visibility><Principal isPermitted="true" name="PTCDTS.KPIAnalysisImpl.Default_OR" type="Organization"/><Principal isPermitted="true" name="PTCDTS.KPIAnalysisImpl.Default_OR:PTCDTS.KPIAnalysisImpl.Admin_UG" type="OrganizationalUnit"/></Visibility></VisibilityPermissions><ConfigurationTableDefinitions/><ConfigurationTables><ConfigurationTable dataShapeName="PTC.KPIAnalysis.AnalysisManagementConfiguration" description="NON-PUBLIC " isMultiRow="false" name="AnalysisManagement" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="true" aspect.thingShape="PTC.KPIAnalysis.AnalysisManagement_TS" baseType="THINGNAME" description="" name="analysisManagement" ordinal="1"/></FieldDefinitions></DataShape><Rows><Row><analysisManagement><![CDATA[PTCDTS.KPIAnalysisImpl.SQLThingUtility]]></analysisManagement></Row></Rows></ConfigurationTable><ConfigurationTable dataShapeName="" description="Configuration table used to identify managers that the building block should use" isMultiRow="true" name="ManagerConfiguration" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="true" baseType="STRING" description="unique identifier for the manager that needs to be configured" name="id" ordinal="1"/><FieldDefinition aspect.isPrimaryKey="false" aspect.thingShape="PTC.Base.CommonManagement_TS" baseType="THINGNAME" description="Name of the Manager Thing to be configured" name="managerThingName" ordinal="2"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable><ConfigurationTable dataShapeName="" description="" isMultiRow="true" name="MashupConfiguration" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="true" baseType="STRING" description="unique identifier used to identify the thing or mashup that is being configured" name="id" ordinal="1"/><FieldDefinition aspect.isPrimaryKey="false" baseType="MASHUPNAME" description="name of the mashup to configure" name="mashupName" ordinal="2"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable><ConfigurationTable dataShapeName="" description="Configuration table for dynamic menus. Menu Items can be specified here and they will show up for the given menu name. " isMultiRow="true" name="MenuConfiguration" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="" name="menuItemMashupName" ordinal="2"/><FieldDefinition aspect.isPrimaryKey="true" baseType="STRING" description="" name="menuName" ordinal="3"/><FieldDefinition aspect.isPrimaryKey="false" baseType="INTEGER" description="An optional field to indicate the ordering of the menu items" name="menuOrderPreference" ordinal="5"/><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="Localization table key for the optional section that groups like menus together" name="menuSectionKey" ordinal="4"/><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="Localization table key for the menu label" name="menuTitleKey" ordinal="1"/><FieldDefinition aspect.dataShape="PTC.Base.ComponentMenuConfiguration" aspect.isPrimaryKey="false" baseType="INFOTABLE" description="" name="submenu" ordinal="6"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable><ConfigurationTable dataShapeName="" description="Configuration table for any Things that need to be configured. This allows for OOTB things to be customized, and the new version that should be used can be configured here" isMultiRow="true" name="ThingConfiguration" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="true" baseType="STRING" description="unique identifier used to identify the thing or mashup that is being configured" name="id" ordinal="1"/><FieldDefinition aspect.isPrimaryKey="false" baseType="THINGNAME" description="Name of the Thing entity or Mashup entity that is to be configured" name="thingName" ordinal="2"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable></ConfigurationTables><ThingShape><PropertyDefinitions/><ServiceDefinitions/><EventDefinitions/><ServiceMappings/><ServiceImplementations/><Subscriptions/></ThingShape><PropertyBindings/><RemotePropertyBindings/><RemoteServiceBindings/><RemoteEventBindings/><AlertConfigurations/><ImplementedShapes/><ThingProperties/><ConfigurationChanges><ConfigurationChange changeAction="CREATE" changeReason="Importing Extension Package Metadata" timestamp="2024-01-23T19:43:02.173Z" user="SuperUser"/><ConfigurationChange changeAction="MODIFY" changeReason="AddVisibilityPermission" timestamp="2024-01-23T19:48:35.932Z" user="Administrator"/><ConfigurationChange changeAction="MODIFY" changeReason="AddVisibilityPermission" timestamp="2024-01-23T19:48:35.936Z" user="Administrator"/><ConfigurationChange changeAction="DELETE" changeReason="DeleteRunTimePermissions" timestamp="2024-01-23T19:48:36.031Z" user="Administrator"/><ConfigurationChange changeAction="DELETE" changeReason="DeleteRunTimePermissions" timestamp="2024-01-23T19:48:36.033Z" user="Administrator"/><ConfigurationChange changeAction="DELETE" changeReason="DeleteRunTimePermissions" timestamp="2024-01-23T19:48:36.036Z" user="Administrator"/><ConfigurationChange changeAction="DELETE" changeReason="DeleteRunTimePermissions" timestamp="2024-01-23T19:48:36.038Z" user="Administrator"/><ConfigurationChange changeAction="DELETE" changeReason="DeleteRunTimePermissions" timestamp="2024-01-23T19:48:36.040Z" user="Administrator"/><ConfigurationChange changeAction="DELETE" changeReason="DeleteRunTimePermissions" timestamp="2024-01-23T19:48:36.043Z" user="Administrator"/><ConfigurationChange changeAction="DELETE" changeReason="DeleteRunTimePermissions" timestamp="2024-01-23T19:48:36.045Z" user="Administrator"/><ConfigurationChange changeAction="DELETE" changeReason="DeleteRunTimePermissions" timestamp="2024-01-23T19:48:36.048Z" user="Administrator"/><ConfigurationChange changeAction="DELETE" changeReason="DeleteRunTimePermissions" timestamp="2024-01-23T19:48:36.050Z" user="Administrator"/><ConfigurationChange changeAction="DELETE" changeReason="DeleteRunTimePermissions" timestamp="2024-01-23T19:48:36.052Z" user="Administrator"/></ConfigurationChanges></Thing></Things><Logs/><Authenticators/><ThingPackages/><NotificationDefinitions/><ApplicationKeys/><StateDefinitions/><ThingTemplates><ThingTemplate aspect.isEditableExtensionObject="true" aspect.isExtension="true" aspect.isSystemObject="false" baseThingTemplate="PTC.KPIAnalysisImpl.EntryPoint_TT" description="Custom Impl of KPIAnalysisImpl to add custom metrics" documentationContent="" effectiveThingPackage="ConfiguredThing" homeMashup="" inheritedValueStream="" lastModifiedDate="2024-01-23T19:48:35.923Z" name="PTCDTS.KPIAnalysisImpl.EntryPoint_TT" projectName="PTCDTS.KPIAnalysisImpl" tags="" thingPackage="" valueStream=""><Owner name="SuperUser" type="User"/><avatar/><DesignTimePermissions><Create/><Read/><Update/><Delete/><Metadata/></DesignTimePermissions><RunTimePermissions/><VisibilityPermissions><Visibility><Principal isPermitted="true" name="PTCDTS.KPIAnalysisImpl.Default_OR" type="Organization"/><Principal isPermitted="true" name="PTCDTS.KPIAnalysisImpl.Default_OR:PTCDTS.KPIAnalysisImpl.Admin_UG" type="OrganizationalUnit"/></Visibility></VisibilityPermissions><ConfigurationTableDefinitions/><ConfigurationTables><ConfigurationTable dataShapeName="" description="Configuration table to store the components core manager" isMultiRow="true" name="ComponentManager" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="true" baseType="STRING" description="unique identifier for the manager that needs to be configured" name="id" ordinal="1"/><FieldDefinition aspect.isPrimaryKey="false" aspect.thingShape="PTC.Base.CommonManagement_TS" baseType="THINGNAME" description="Name of the Manager Thing to be configured" name="managerThingName" ordinal="2"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable></ConfigurationTables><PropertyBindings/><RemotePropertyBindings/><RemoteServiceBindings/><RemoteEventBindings/><AlertConfigurations/><ThingShape><PropertyDefinitions/><ServiceDefinitions><ServiceDefinition aspect.isAsync="false" category="" description="" isAllowOverride="true" isLocalOnly="false" isOpen="false" isPrivate="false" name="CreateCustomMetrics"><ResultType baseType="NOTHING" description="" name="result" ordinal="0"/><ParameterDefinitions/></ServiceDefinition><ServiceDefinition aspect.isAsync="false" category="" description="" isAllowOverride="false" isLocalOnly="false" isOpen="false" isPrivate="false" name="GetDeployManagement"><ResultType baseType="THINGNAME" description="" name="result" ordinal="0"/><ParameterDefinitions/></ServiceDefinition><ServiceDefinition aspect.isAsync="false" category="" description="" isAllowOverride="false" isLocalOnly="false" isOpen="false" isPrivate="false" name="UpdateDBFunctions"><ResultType baseType="NOTHING" description="" name="result" ordinal="0"/><ParameterDefinitions/></ServiceDefinition><ServiceDefinition aspect.isAsync="false" category="" description="" isAllowOverride="false" isLocalOnly="false" isOpen="false" isPrivate="false" name="UpdateGlobalManagerConfig"><ResultType baseType="NOTHING" description="" name="result" ordinal="0"/><ParameterDefinitions/></ServiceDefinition></ServiceDefinitions><EventDefinitions/><ServiceMappings/><ServiceImplementations><ServiceImplementation description="" handlerName="Script" name="CreateCustomMetrics"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[let manager = Things[me.GetConfiguredComponentManager()];
let metricManager = Things[manager.GetConfiguredManagerForIdentifier({
	identifier: "PTC.Metric.Manager" /* STRING */
})];

let percentTimeMetrics = ["Planned Downtime", "Unplanned Downtime", "Changeover", "Speed Loss", "Small Stops"];
let oeeMetrics = {
    "Availability": {
        "calculationDescription": "Available Time / Planned Production Time",
        "description": "Percent Availability of the Machine over time"
    }, 
    "Performance":{
        "calculationDescription": "(Available Time - Speed Loss) / Available Time",
        "description": "Percent of Actual Performance vs Ideal Performance"
    }, 
    "Quality":{
        "calculationDescription": "Good Count / Total Count",
        "description": "Percent of Good Production vs Total Production"
    }
};
// result: INFOTABLE dataShape: "PTC.Metric.Metric"
let existingMetrics = metricManager.GetMetrics({});

// CreateInfoTableFromDataShape(infoTableName:STRING("InfoTable"), dataShapeName:STRING):INFOTABLE(PTC.Metric.Metric)
let metrics = Resources["InfoTableFunctions"].CreateInfoTableFromDataShape({
    infoTableName: "InfoTable",
    dataShapeName: "PTC.Metric.Metric"
});

let metricsToUpdate = Resources["InfoTableFunctions"].CreateInfoTableFromDataShape({
    infoTableName: "InfoTable",
    dataShapeName: "PTC.Metric.Metric"
});

percentTimeMetrics.forEach(customMetricName => {
    if(!doesMetricAlreadyExist(existingMetrics, customMetricName)){
        // PTC.Metric.Metric entry object
        let newEntry = {
            name: customMetricName, // STRING
            name_Token: undefined, // LONG
            calculationDescription: customMetricName + " / Total Production Time", // STRING
            calculationDescription_Token: undefined, // LONG
            description: "The percentage of time spent in " + customMetricName, // STRING
            description_Token: undefined, // LONG
            unitOfMeasure: 1, // LONG
            metricRollUp: 1, // LONG
            metricCorrelation: 2, // LONG
            acceptsInheritance: true // BOOLEAN
        };

        metrics.AddRow(newEntry);
    }
});

for (var customMetricName in oeeMetrics) {
    // PTC.Metric.Metric entry object
    let newEntry = {
        name: customMetricName, // STRING
        name_Token: undefined, // LONG
        calculationDescription: oeeMetrics[customMetricName].calculationDescription, // STRING
        calculationDescription_Token: undefined, // LONG
        description: oeeMetrics[customMetricName].description, // STRING
        description_Token: undefined, // LONG
        unitOfMeasure: 1, // LONG
        metricRollUp: 1, // LONG
        metricCorrelation: 1, // LONG
        acceptsInheritance: true // BOOLEAN
    };
    let searchUid = doesMetricAlreadyExist(existingMetrics, customMetricName);
    if(searchUid == -1){
        metrics.AddRow(newEntry);
    } else {
        newEntry.uid = searchUid;
        metricsToUpdate.AddRow(newEntry);
    }
}

if(metrics && metrics.rows && metrics.rows.length >0){
    // result: INFOTABLE dataShape: "PTC.Metric.Metric"
    metrics = metricManager.AddMetrics({
        metrics: metrics /* INFOTABLE [Required] {"dataShape":"PTC.Metric.Metric"} */
    });
}

if(metricsToUpdate && metricsToUpdate.rows && metricsToUpdate.rows.length >0){
    // result: INFOTABLE dataShape: "PTC.Metric.Metric"
    metricsToUpdate = metricManager.UpdateMetrics({
		metrics: metricsToUpdate /* INFOTABLE [Required] {"dataShape":"PTC.Metric.Metric"} */
	});
}

function doesMetricAlreadyExist(existingMetrics, metricName){
    let exists = -1;
    let query = {
     "filters": {
       "type": "EQ",
       "fieldName": "name",
       "value": metricName
     }
    };
    
    let params = {
        t: existingMetrics /* INFOTABLE */,
        query: query /* QUERY */
    };

    // result: INFOTABLE
    let metricExists = Resources["InfoTableFunctions"].Query(params);
	if(metricExists && metricExists.rows && metricExists.rows.length > 0){
        exists = metricExists.uid;
    }
	return exists;    
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="DeployComponent"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[let implementationProjectName = me.GetProjectName();
if (!implementationProjectName) {
	throw new Error("Implementation building block project name is missing");
}

let managerName = implementationProjectName + ".Manager";
let managerThing = Things[managerName];
if (!managerThing) {
	throw new Error("Manager [" + managerName + "] is missing");
}

me.CreateCustomMetrics();
me.UpdateGlobalManagerConfig();
me.UpdateDBFunctions();

//let databaseUtility = managerThing.GetAnalysisManagement();
//Things[databaseUtility].CreateDBFunctions();
let result = true;]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="GetComponentDeployConfigurationParameters"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[var result = {};]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="GetDeployManagement"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[let manager = me.GetConfiguredComponentManager();
result = Things[manager].GetAnalysisManagement();]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="UpdateDBFunctions"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[let dbUtil = me.GetDeployManagement();

Things[dbUtil].CreateDBFunctions();]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="UpdateGlobalManagerConfig"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[// table: INFOTABLE dataShape: ""
let table = Things["PTC.Base.Manager"].GetConfigurationTable({
	tableName: "DefaultGlobalManagerConfiguration" /* STRING */
});

table.rows.toArray().forEach(row => {
    if(row.id == "PTC.KPIAnalysis.Manager"){
        row.managerThingName = "PTCDTS.KPIAnalysisImpl.Manager";
    }
});

Things["PTC.Base.Manager"].SetMultiRowConfigurationTable({
	configurationTable: table /* INFOTABLE */,
	persistent: undefined /* BOOLEAN {"defaultValue":true} */,
	tableName: "DefaultGlobalManagerConfiguration" /* STRING */
});]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation></ServiceImplementations><Subscriptions/></ThingShape><ImplementedShapes/><SharedConfigurationTables/><InstanceDesignTimePermissions><Create/><Read/><Update/><Delete/><Metadata/></InstanceDesignTimePermissions><InstanceRunTimePermissions/><InstanceVisibilityPermissions><Visibility/></InstanceVisibilityPermissions><ConfigurationChanges><ConfigurationChange changeAction="CREATE" changeReason="Importing Extension Package Metadata" timestamp="2024-01-23T19:43:02.163Z" user="SuperUser"/><ConfigurationChange changeAction="MODIFY" changeReason="AddVisibilityPermission" timestamp="2024-01-23T19:48:35.920Z" user="Administrator"/><ConfigurationChange changeAction="MODIFY" changeReason="AddVisibilityPermission" timestamp="2024-01-23T19:48:35.923Z" user="Administrator"/></ConfigurationChanges></ThingTemplate><ThingTemplate aspect.isEditableExtensionObject="true" aspect.isExtension="true" baseThingTemplate="PTC.KPIAnalysisImpl.SQLThingUtility_TT" description="" documentationContent="" effectiveThingPackage="SQLThingPackage" homeMashup="" inheritedValueStream="" lastModifiedDate="2024-01-23T19:48:35.954Z" name="PTCDTS.KPIAnalysisImpl.SQLThingUtility_TT" projectName="PTCDTS.KPIAnalysisImpl" tags="" thingPackage="" valueStream=""><Owner name="SuperUser" type="User"/><avatar/><DesignTimePermissions><Create/><Read/><Update/><Delete/><Metadata/></DesignTimePermissions><RunTimePermissions/><VisibilityPermissions><Visibility><Principal isPermitted="true" name="PTCDTS.KPIAnalysisImpl.Default_OR" type="Organization"/><Principal isPermitted="true" name="PTCDTS.KPIAnalysisImpl.Default_OR:PTCDTS.KPIAnalysisImpl.Admin_UG" type="OrganizationalUnit"/></Visibility></VisibilityPermissions><ConfigurationTableDefinitions/><ConfigurationTables><ConfigurationTable dataShapeName="" description="Connection Monitoring Settings" isMultiRow="false" name="ConnectionMonitoring" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.defaultValue="30000.0" aspect.friendlyName="Monitor Rate (milliseconds)" baseType="NUMBER" description="Monitor rate in milliseconds" name="connectionMonitorRate" ordinal="1"/><FieldDefinition aspect.defaultValue="false" aspect.friendlyName="Enable Monitoring" baseType="BOOLEAN" description="Enable connection monitoring" name="enableMonitor" ordinal="0"/><FieldDefinition aspect.defaultValue="1.0" aspect.friendlyName="Number of Retries" baseType="NUMBER" description="Number of retries" name="numberOfRetries" ordinal="2"/><FieldDefinition aspect.defaultValue="2000.0" aspect.friendlyName="Retry Delay (milliseconds)" baseType="NUMBER" description="Retry delay in milliseconds" name="retryDelay" ordinal="3"/></FieldDefinitions></DataShape><Rows><Row><connectionMonitorRate>30000.0</connectionMonitorRate><enableMonitor>false</enableMonitor><numberOfRetries>1.0</numberOfRetries><retryDelay>2000.0</retryDelay></Row></Rows></ConfigurationTable><ConfigurationTable dataShapeName="" description="Connection Provider" isMultiRow="false" name="ConnectionProvider" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.defaultValue="false" aspect.friendlyName="Participate in platform transactions" baseType="BOOLEAN" description="Participate in platform transactions" name="isTransactional" ordinal="0"/><FieldDefinition aspect.defaultValue="ThingworxPersistenceProvider" aspect.friendlyName="Persistence Provider Name" baseType="PERSISTENCEPROVIDERNAME" description="The Persistence Provider from which to retrieve connections" name="persistenceProviderName" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><isTransactional>false</isTransactional><persistenceProviderName><![CDATA[PTC.DBConnection.JdbcPersistenceProvider]]></persistenceProviderName></Row></Rows></ConfigurationTable><ConfigurationTable dataShapeName="" description="Field/Column Name Aliases" isMultiRow="true" name="ColumnAliases" ordinal="1"><DataShape><FieldDefinitions><FieldDefinition aspect.friendlyName="Database Column Name" baseType="STRING" description="Database column name" name="columnName" ordinal="0"/><FieldDefinition aspect.friendlyName="Thingworx Field Name" baseType="STRING" description="Thingworx field name" name="fieldName" ordinal="1"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable></ConfigurationTables><PropertyBindings/><RemotePropertyBindings/><RemoteServiceBindings/><RemoteEventBindings/><AlertConfigurations/><ThingShape><PropertyDefinitions/><ServiceDefinitions><ServiceDefinition aspect.isAsync="false" category="" description="" isAllowOverride="true" isLocalOnly="false" isOpen="false" isPrivate="false" name="AddCustomMetricsToResult"><ResultType baseType="JSON" description="" name="result" ordinal="0"/><ParameterDefinitions><FieldDefinition baseType="DATETIME" description="" name="endDate" ordinal="4"/><FieldDefinition baseType="INTEGER" description="" name="GoodCount" ordinal="6"/><FieldDefinition baseType="JSON" description="" name="json" ordinal="3"/><FieldDefinition baseType="STRING" description="" name="modelUid" ordinal="5"/><FieldDefinition baseType="INTEGER" description="" name="ScrapCount" ordinal="7"/><FieldDefinition baseType="DATETIME" description="" name="startDate" ordinal="3"/><FieldDefinition baseType="NUMBER" description="" name="totalTimeDuration" ordinal="4"/></ParameterDefinitions></ServiceDefinition></ServiceDefinitions><EventDefinitions/><ServiceMappings/><ServiceImplementations><ServiceImplementation description="" handlerName="Script" name="AddCustomMetricsToResult"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[let result = json;
let operationKPIManager = Things[Things["PTCDTS.KPIAnalysisImpl.Manager"].GetConfiguredManagerForIdentifier({
	identifier: "PTC.OperationKPI.Manager" /* STRING */
})];
try{
    
    let eventDurations = operationKPIManager.GetWaterfallInfos({
        startDateTime: startDate /* DATETIME [Required] */,
        endDateTime: endDate /* DATETIME [Required] */,
        modelUid: modelUid /* STRING [Required] */,
        timeRatio: 1
    });

	//Custom metrics
    let plannedDowntime = getTotalDurationByCategory(eventDurations, "Planned Downtime");
    let unplannedDowntime = getTotalDurationByCategory(eventDurations, "Unplanned Downtime");
    let changeover = getTotalDurationByCategory(eventDurations, "Changeover");
    let speedLoss = getTotalDurationByCategory(eventDurations, "Speed Loss");
    let smallStops = getTotalDurationByCategory(eventDurations, "Small Stops"); 
    
    result['Planned Downtime'] = totalTimeDuration > 0 ? plannedDowntime / totalTimeDuration * 100: 0;
    result['Unplanned Downtime'] = totalTimeDuration > 0 ? unplannedDowntime / totalTimeDuration * 100: 0;
    result['Changeover'] = totalTimeDuration > 0 ? changeover / totalTimeDuration * 100: 0;
    result['Speed Loss'] = totalTimeDuration > 0 ? speedLoss / totalTimeDuration * 100: 0;
    result['Small Stops'] = totalTimeDuration > 0 ? smallStops / totalTimeDuration * 100: 0;
    //Custom OEE metrics
    
    let downtime = getTotalDurationByType(eventDurations, "Down");
    
    let plannedProductionTime = getTotalDurationByName(eventDurations, "PlannedProduction");
    let overtime = getTotalDurationByName(eventDurations, "OverTime");
    let unplannedProduction = getTotalDurationByName(eventDurations, "UnplannedProduction");
    let totalProductionTime = plannedProductionTime + overtime;
    
    let runTime = totalProductionTime - downtime;
    

    let unaccountedTime =  getTotalDurationByName(eventDurations, "UnaccountedTime");
    
    let availability = totalProductionTime > 0 ? runTime / totalProductionTime : 0;
    let performance = runTime > 0 ? (runTime - speedLoss - smallStops - unaccountedTime)/ runTime : 0;
    let quality = (GoodCount + ScrapCount) > 0 ? GoodCount / (GoodCount + ScrapCount) : 0;
       
    result['Availability'] = availability * 100;
    result['Performance'] = performance * 100;
    result['Quality'] = quality * 100;
    
} catch (err) {
	logger.error("Thing [{}] Service [{}] error at line [{}] : {}", me.name, err.fileName, err.lineNumber, err);
	throw ("An error has occurred. Please check the script logs for more details.");
}

function getTotalDurationByCategory(eventDurations, eventCategoryName) {
    return totalDurationByField(eventDurations, "eventcategoryname", eventCategoryName);
}

function getTotalDurationByType(eventDurations, eventTypeName) {
    return totalDurationByField(eventDurations, "eventtypename", eventTypeName);
}

function getTotalDurationByName(eventDurations, eventName) {
    return totalDurationByField(eventDurations, "name", eventName);
}

function totalDurationByField(eventDurations, field, value){
    let returnValue = 0;
	if (eventDurations) {
        // Provide your filter using the format as described in the help topic "Query Parameter for Query Services"
        let query = {
         "filters": {
           "type": "EQ",
           "fieldName": field,
           "value": value
         }
        };
        
        let params = {
            t: eventDurations /* INFOTABLE */,
            query: query /* QUERY */
        };

        // result: INFOTABLE
        let categoryRow = Resources["InfoTableFunctions"].Query(params);
        
		if(categoryRow && categoryRow.rows && categoryRow.rows.length > 0){
            categoryRow.rows.toArray().forEach(row => {
                returnValue += row.duration;
            });  
        }
	}
	return returnValue; 
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="SQLQuery" name="CallGetProductionEventDurationPeriods"><ConfigurationTables><ConfigurationTable dataShapeName="" description="SQLQuery" isMultiRow="false" name="Query" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="NUMBER" description="maxItems" name="maxItems" ordinal="0"/><FieldDefinition baseType="STRING" description="sql" name="sql" ordinal="0"/><FieldDefinition baseType="NUMBER" description="timeout" name="timeout" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><maxItems>0.0</maxItems><sql><![CDATA[DECLARE @flag BIT 
SELECT @flag = CASE WHEN 6 NOT IN (SELECT m.modeltypeuid FROM STRING_SPLIT([[modelUids]], ',') ids JOIN model m ON m.uid = ids.value) THEN 1 ELSE 0 END

DECLARE @parent_children uidmap;
INSERT INTO @parent_children(touid, fromuid)
    SELECT treemodels.childuid, models.value
    FROM STRING_SPLIT([[modelUids]], ',') models
    CROSS APPLY GetTreeModels(models.value, @flag) treemodels
    WHERE treemodels.childtype = 'Workunit';

DECLARE @timeperiods timeperiodtype
INSERT INTO @timeperiods(id, starttime, endtime)
SELECT id, starttime, endtime
FROM OPENJSON([[timePeriods]])
WITH (
    id INT 'strict $.id',
    starttime DATETIME '$.startDateTime',
    endtime DATETIME '$.endDateTime'
)

EXEC GetProductionEventDurations @timeperiods, @parent_children, NULL, NULL]]></sql><timeout>0.0</timeout></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="SQLQuery" name="CallGetUnplannedProductionDurationPeriods"><ConfigurationTables><ConfigurationTable dataShapeName="" description="SQLQuery" isMultiRow="false" name="Query" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="NUMBER" description="maxItems" name="maxItems" ordinal="0"/><FieldDefinition baseType="STRING" description="sql" name="sql" ordinal="0"/><FieldDefinition baseType="NUMBER" description="timeout" name="timeout" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><maxItems>0.0</maxItems><sql><![CDATA[DECLARE @flag BIT 
SELECT @flag = CASE WHEN 6 NOT IN (SELECT m.modeltypeuid FROM STRING_SPLIT([[modelUids]], ',') ids JOIN model m ON m.uid = ids.value) THEN 1 ELSE 0 END

DECLARE @parent_children uidmap;
INSERT INTO @parent_children(touid, fromuid)
    SELECT treemodels.childuid, models.value
    FROM STRING_SPLIT([[modelUids]], ',') models
    CROSS APPLY GetTreeModels(models.value, @flag) treemodels
    WHERE treemodels.childtype = 'Workunit';

DECLARE @timeperiods timeperiodtype
INSERT INTO @timeperiods(id, starttime, endtime)
SELECT id, starttime, endtime
FROM OPENJSON([[timePeriods]])
WITH (
    id INT 'strict $.id',
    starttime DATETIME '$.startDateTime',
    endtime DATETIME '$.endDateTime'
)

EXEC GetTotalUnplannedProductionDuration @parent_children, @timeperiods, 14]]></sql><timeout>0.0</timeout></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="CreateDBFunctions"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[//execution of those services need to respect that order for dependecy and avoid failing 
let services = [
	"CreateGetUnplannedProductionDuration",
//	"CreateGetTotalScheduledAndCompletedJobOrders",
	"CreateGetTotalUnplannedProductionDuration"
];

services.forEach(service => {
	try {
		me[service]();
	} catch (err) {
		logger.error("Thing [{}] Service [{}] error at line [{}] : {}", me.name, err.fileName, err.lineNumber, err);
		logger.error("Error running service : [{}]", service);
	}
});]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="SQLCommand" name="CreateGetTotalUnplannedProductionDuration"><ConfigurationTables><ConfigurationTable dataShapeName="" description="SQLCommand" isMultiRow="false" name="Query" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="NUMBER" description="maxItems" name="maxItems" ordinal="0"/><FieldDefinition baseType="STRING" description="sql" name="sql" ordinal="0"/><FieldDefinition baseType="NUMBER" description="timeout" name="timeout" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><maxItems>500.0</maxItems><sql><![CDATA[CREATE OR ALTER PROCEDURE GetTotalUnplannedProductionDuration(
    @parent_children uidmap READONLY,
    @timeperiods timeperiodtype READONLY,
    @minExecutionResponseAgeInDays INT = 14,
	@materialmasteruid BIGINT = NULL)
AS

DECLARE @parent_children_wc TABLE(fromuid BIGINT, touid BIGINT, wcuid BIGINT,modeltypeuid BIGINT)
INSERT INTO @parent_children_wc(fromuid, touid, wcuid, modeltypeuid)
SELECT pc.*, ml.parentuid as wcuid, m.modeltypeuid 
FROM @parent_children pc
JOIN modellink ml ON pc.touid = ml.childuid
JOIN model m ON pc.fromuid = m.uid

DECLARE @isWorkUnitOnly BIT = CASE WHEN 6 IN (SELECT modeltypeuid FROM @parent_children_wc)  THEN 1 ELSE 0 END


DECLARE @currentTime DATETIMEOFFSET = GETDATE();

DECLARE @running NVARCHAR(MAX) = 'Running';

DECLARE @historicaltimeperiods modeltimeperiodtype
DECLARE @remainingtimeperiods modeltimeperiodtype

IF @materialmasteruid IS NULL
BEGIN
INSERT INTO @historicaltimeperiods(modeluid, id, starttime, endtime)
    SELECT
        pc.touid AS modeluid,
        tp.id AS id,
        IIF(tp.starttime < COALESCE(MIN(ajo.startdatetime), tp.starttime),
            COALESCE(MIN(ajo.startdatetime), tp.starttime),
            tp.starttime) AS starttime,
        IIF(tp.endtime < COALESCE(MAX(ajo.enddatetime), tp.endtime),
            tp.endtime,
            COALESCE(MAX(ajo.enddatetime), tp.endtime)) AS endtime
    FROM
        @timeperiods tp
        CROSS JOIN @parent_children_wc pc
        INNER JOIN aggregatedjoborder ajo ON ajo.workcenteruid = pc.wcuid
    GROUP BY
        tp.id,
        tp.starttime,
        tp.endtime,
        pc.touid

INSERT INTO @remainingtimeperiods(modeluid, id, starttime, endtime)
    SELECT
        pc.touid AS modeluid,
        tp.id AS id,
        IIF(tp.starttime < COALESCE(MAX(ajo.enddatetime), tp.starttime),
            COALESCE(MAX(ajo.enddatetime), tp.starttime),
            tp.starttime) AS starttime,
            tp.endtime AS endtime
    FROM
        @timeperiods tp
        CROSS JOIN @parent_children_wc pc
        LEFT JOIN aggregatedjoborder ajo ON ajo.workcenteruid = pc.wcuid
    GROUP BY
        tp.id,
        tp.starttime,
        tp.endtime,
        pc.touid
END
ELSE
   BEGIN
    INSERT INTO @remainingtimeperiods(modeluid, id, starttime, endtime)
    SELECT
        pc.touid AS modeluid,
        tp.id AS id,
        tp.starttime AS starttime,
        tp.endtime AS endtime
    FROM
        @timeperiods tp
        CROSS JOIN @parent_children pc
END

DROP TABLE IF EXISTS #unplannedProductionDurations;
CREATE TABLE #unplannedProductionDurations(
    modeluid BIGINT,
	materialmasteruid BIGINT,
    timeperiodid BIGINT,
    duration NUMERIC(38, 5),
    overtimeduration NUMERIC(38, 5),
	plannedduration NUMERIC(38, 5)
);

IF EXISTS (SELECT TOP(1) id FROM @historicaltimeperiods)
BEGIN
    INSERT INTO #unplannedProductionDurations(modeluid, timeperiodid, duration, overtimeduration)
        SELECT
            pc.fromuid AS modeluid,
            tp.id AS timeperiodid,
            SUM(jos.unplannedduration) * 60 AS duration,
            SUM(jos.overtimeduration) * 60 AS overtimeduration
        FROM
            @parent_children_wc pc
            LEFT JOIN aggregatedjoborder jos ON pc.wcuid = jos.workcenteruid
            INNER JOIN @historicaltimeperiods tp ON (
                jos.workcenteruid = tp.modeluid AND
                jos.startdatetime < tp.endtime AND
                tp.starttime < jos.enddatetime AND tp.endtime >= jos.enddatetime
            )
        GROUP BY
            pc.fromuid, tp.id
END;

IF EXISTS (SELECT TOP(1) id FROM @remainingtimeperiods)
BEGIN
    DECLARE @minjoerdate DATETIMEOFFSET
    DECLARE @maxjoerdate DATETIMEOFFSET

    SELECT
        @minjoerdate = DATEADD(DAY, - @minExecutionResponseAgeInDays, MIN(starttime)),
        @maxjoerdate = DATEADD(DAY, + @minExecutionResponseAgeInDays, MAX(endtime))
    FROM
        @remainingtimeperiods;

    DROP TABLE IF EXISTS #jobOrderExecutionTimeTable;
    CREATE TABLE #jobOrderExecutionTimeTable (
        modeluid BIGINT INDEX IX1 NONCLUSTERED,
		materialmasteruid BIGINT INDEX IX2 NONCLUSTERED,
        timeperiodid BIGINT INDEX IX3 NONCLUSTERED,
        duration NUMERIC(38, 5),
        starttime DATETIMEOFFSET INDEX IX4 NONCLUSTERED,
        endtime DATETIMEOFFSET INDEX IX5 NONCLUSTERED,
        joborderuid BIGINT INDEX IX6 NONCLUSTERED
	    );
    INSERT INTO #jobOrderExecutionTimeTable(modeluid, materialmasteruid, timeperiodid, duration, starttime, endtime, joborderuid)
        SELECT
            joet.modeluid,
			materialmasteruid,
            tp.id,
            DATEDIFF(SECOND,
                IIF(joet.starttimestamp < tp.starttime, tp.starttime, joet.starttimestamp),
                IIF(joet.endtimestamp > tp.endtime, tp.endtime, joet.endtimestamp))/ppd.divisor AS duration,
            IIF(joet.starttimestamp < tp.starttime, tp.starttime, joet.starttimestamp) AS starttime,
            IIF(tp.endtime < endtimestamp, tp.endtime, joet.endtimestamp) AS endtime,
            joet.joborderuid
        FROM
            (
                SELECT
                    ml.childuid AS modeluid, -- WC modeluid
                    wder.timestamp AS starttimestamp,
                    LEAD(wder.timestamp, 1, @currentTime) OVER (PARTITION BY wder.modeluid, wder.joborderuid ORDER BY wder.timestamp,wder.inserttimestamp) AS endtimestamp,
                    ds.name AS startstatus,
					wder.materialmasteruid as materialmasteruid,
                	wder.joborderuid
                FROM
                    workdefinitionexecutionresponse as wder
                    --joborderexecutionresponse AS joer
                    INNER JOIN dispatchstatus AS ds ON wder.status = ds.uid
                    INNER JOIN modellink AS ml ON ml.childuid = wder.modeluid
                WHERE
                    ml.parentuid IN (SELECT wcuid FROM @parent_children_wc) AND
                    (@minjoerdate < wder.timestamp AND wder.timestamp < @maxjoerdate)
            ) AS joet
            CROSS APPLY GetParallelPacemakerDivisor(joet.modeluid,joet.joborderuid,@isWorkUnitOnly) AS ppd
            INNER JOIN @remainingtimeperiods tp ON (
                tp.modeluid = joet.modeluid AND
                tp.starttime < joet.endtimestamp AND
                joet.starttimestamp < tp.endtime
            )
        WHERE
            joet.startstatus = @running

    DROP TABLE IF EXISTS #runningHoursTable;
    CREATE TABLE #runningHoursTable (
        modeluid BIGINT,
		materialmasteruid BIGINT,
        timeperiodid BIGINT,
        duration NUMERIC(38, 5)
    );
    INSERT INTO #runningHoursTable(modeluid, materialmasteruid, timeperiodid, duration)
        SELECT
            modeluid,
			materialmasteruid,
            timeperiodid,
            SUM(duration) AS duration
        FROM
            #jobOrderExecutionTimeTable
        GROUP BY
            modeluid, materialmasteruid, timeperiodid;

    DROP TABLE IF EXISTS #plannedProductionTable;
    CREATE TABLE #plannedProductionTable(
        modeluid BIGINT,
		materialmasteruid BIGINT,
        timeperiodid BIGINT,
        duration NUMERIC(38, 5),
        overtimeduration NUMERIC(38, 5),
		plannedduration NUMERIC(38, 5)
    );
    INSERT INTO #plannedProductionTable(modeluid, materialmasteruid, timeperiodid, duration, overtimeduration, plannedduration)
        SELECT
            siet.modeluid,
			siet.materialmasteruid,
            siet.timeperiodid,
            SUM(DATEDIFF(SECOND,
                IIF(siet.actualstarttime < siet.starttime, siet.starttime, siet.actualstarttime),
                IIF(siet.endtime < siet.actualendtime,
                    IIF(siet.endtime > endtime, endtime, siet.endtime),
                    IIF(siet.actualendtime > endtime, endtime, siet.actualendtime))
            )/ppd.divisor) AS duration,
            SUM(IIF(siet.isovertime = 1, DATEDIFF(SECOND,
                IIF(siet.actualstarttime < siet.starttime, siet.starttime, siet.actualstarttime),
                IIF(siet.endtime < siet.actualendtime,
                    IIF(siet.endtime > endtime, endtime, siet.endtime),
                    IIF(siet.actualendtime > endtime, endtime, siet.actualendtime))
            ), 0)/ppd.divisor) AS overtimeduration,
			SUM(IIF(COALESCE(siet.isovertime, 0) = 0, DATEDIFF(SECOND,
                IIF(siet.actualstarttime < siet.starttime, siet.starttime, siet.actualstarttime),
                IIF(siet.endtime < siet.actualendtime,
                    IIF(siet.endtime > endtime, endtime, siet.endtime),
                    IIF(siet.actualendtime > endtime, endtime, siet.actualendtime))
            ), 0)/ppd.divisor) AS plannedduration

        FROM
            (
                SELECT
                    shi.actualstarttime,
                    shi.actualendtime,
                    shi.modeluid,
                    joet.timeperiodid,
                    joet.starttime AS starttime,
                    joet.endtime AS endtime,
                    joet.joborderuid AS joborderuid,
                    shi.isovertime,
					joet.materialmasteruid AS materialmasteruid
                FROM
                    shiftinstance AS shi
                    INNER JOIN #jobOrderExecutionTimeTable AS joet ON (
                        shi.actualstarttime < joet.endtime AND
                        joet.starttime < shi.actualendtime AND
                        shi.modeluid = joet.modeluid)
            ) AS siet
            CROSS APPLY GetParallelPacemakerDivisor(siet.modeluid,siet.joborderuid,@isWorkUnitOnly) AS ppd
        GROUP BY
            siet.modeluid, siet.timeperiodid, siet.materialmasteruid

    INSERT INTO #unplannedProductionDurations(modeluid, materialmasteruid, timeperiodid, duration, overtimeduration, plannedduration)
        SELECT
            pc.fromuid,
			rh.materialmasteruid,
            rh.timeperiodid,
            SUM(rh.duration - COALESCE(pp.duration, 0)) AS duration,
            SUM(COALESCE(pp.overtimeduration, 0)) AS overtimeduration,
			SUM(COALESCE(pp.plannedduration, 0)) AS plannedduration
        FROM
            @parent_children pc
            INNER JOIN #runningHoursTable rh ON pc.touid = rh.modeluid
            LEFT JOIN #plannedProductionTable pp ON rh.timeperiodid = pp.timeperiodid AND
                                                    rh.modeluid = pp.modeluid AND (rh.materialmasteruid = pp.materialmasteruid)
        GROUP BY
            pc.fromuid, rh.timeperiodid , rh.materialmasteruid
END;

IF @materialmasteruid IS NOT NULL
BEGIN
    SELECT
        modeluid,
        timeperiodid,
        IIF(SUM(duration) > 0, SUM(duration), 0) AS duration,
		IIF(SUM(IIF(materialmasteruid <> @materialmasteruid,duration,0)) > 0, SUM(IIF(materialmasteruid <> @materialmasteruid,duration,0)), 0) AS unplanneddurationforothermaterials,
        IIF(SUM(overtimeduration) > 0, SUM(overtimeduration), 0) AS overtimeduration,
		IIF(SUM(IIF(materialmasteruid <> @materialmasteruid,overtimeduration,0)) > 0, SUM(IIF(materialmasteruid <> @materialmasteruid,overtimeduration,0)), 0) AS overtimedurationforothermaterials,
		IIF(SUM(IIF(materialmasteruid <> @materialmasteruid,plannedduration,0)) > 0, SUM(IIF(materialmasteruid <> @materialmasteruid,plannedduration,0)), 0) AS planneddurationforothermaterials

    FROM
        #unplannedProductionDurations
    GROUP BY
        modeluid, timeperiodid;
END
ELSE
BEGIN
    SELECT
        modeluid,
        timeperiodid,
        IIF(SUM(duration) > 0, SUM(duration), 0) AS duration,
        IIF(SUM(overtimeduration) > 0, SUM(overtimeduration), 0) AS overtimeduration
    FROM
        #unplannedProductionDurations
    GROUP BY
        modeluid, timeperiodid;
END]]></sql><timeout>0.0</timeout></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="SQLCommand" name="CreateGetUnplannedProductionDuration"><ConfigurationTables><ConfigurationTable dataShapeName="" description="SQLCommand" isMultiRow="false" name="Query" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="NUMBER" description="maxItems" name="maxItems" ordinal="0"/><FieldDefinition baseType="STRING" description="sql" name="sql" ordinal="0"/><FieldDefinition baseType="NUMBER" description="timeout" name="timeout" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><maxItems>500.0</maxItems><sql><![CDATA[CREATE OR ALTER FUNCTION GetUnplannedProductionDuration(
    @productionblocks productionblocktype READONLY,
    @status NVARCHAR(255)
) RETURNS @result TABLE(
    productionblockuid BIGINT INDEX IX1 NONCLUSTERED,
    modeluid BIGINT INDEX IX2 NONCLUSTERED,
    duration NUMERIC(38, 5),
    overtimeduration NUMERIC(38, 5)
)

AS BEGIN
    DECLARE @currentTime DATETIMEOFFSET = GETDATE();
    
    DECLARE @jobOrderExecutionTimeTable TABLE (
        modeluid BIGINT INDEX IX1 NONCLUSTERED,
        productionblockuid BIGINT INDEX IX2 NONCLUSTERED,
        duration NUMERIC(38, 5),
        starttime DATETIMEOFFSET INDEX IX3 NONCLUSTERED,
        endtime DATETIMEOFFSET INDEX IX4 NONCLUSTERED
    );
     INSERT INTO @jobOrderExecutionTimeTable
        SELECT
            joet.modeluid,
            pb.productionblockuid,
            DATEDIFF(SECOND, IIF(starttimestamp < pb.starttime, pb.starttime, starttimestamp), IIF(endtimestamp > pb.endtime, pb.endtime, endtimestamp)),
            IIF(starttimestamp < pb.starttime, pb.starttime, starttimestamp),
            IIF(endtimestamp > pb.endtime, pb.endtime, endtimestamp)
        FROM
            (
                SELECT
                    timestamp AS starttimestamp,
                    ds.name AS startstatus,
                    COALESCE(LEAD(timestamp, 1) OVER (PARTITION BY joer.joborderuid ORDER BY timestamp), @currentTime) AS endtimestamp,
                    LEAD(ds.name, 1) OVER (PARTITION BY joer.joborderuid, joer.modeluid ORDER BY timestamp, inserttimestamp) AS endstatus,
                    joer.modeluid
                FROM
                    workdefinitionexecutionresponse AS joer
                    INNER JOIN dispatchstatus AS ds ON joer.status = ds.uid
                WHERE joer.modeluid IN (SELECT modeluid FROM @productionblocks)
            ) AS joet
            CROSS APPLY @productionblocks pb
        WHERE
            joet.modeluid = pb.modeluid AND
            joet.startstatus = @status AND
            (pb.starttime < joet.endtimestamp AND joet.starttimestamp < pb.endtime);

    IF EXISTS (SELECT modeluid FROM @jobOrderExecutionTimeTable)
    BEGIN
        DECLARE @runningHoursTable TABLE (
            modeluid BIGINT INDEX IX1 NONCLUSTERED,
            productionblockuid BIGINT INDEX IX2 NONCLUSTERED,
            duration NUMERIC(38, 5)
        );

        INSERT INTO @runningHoursTable
            SELECT
                modeluid,
                productionblockuid,
                SUM(duration) as duration
            FROM @jobOrderExecutionTimeTable
            GROUP BY modeluid, productionblockuid;

        DECLARE @plannedProductionTable TABLE (
            modeluid BIGINT INDEX IX1 NONCLUSTERED,
            productionblockuid BIGINT INDEX IX2 NONCLUSTERED,
            duration NUMERIC(38, 5),
            overtimeduration NUMERIC(38, 5)
        );

        INSERT INTO @plannedProductionTable
            SELECT
                siet.modeluid,
                siet.productionblockuid,
                SUM(DATEDIFF(SECOND,
                    IIF(siet.actualstarttime < siet.starttime, siet.starttime, siet.actualstarttime),
                    IIF(siet.endtime < siet.actualendtime,
                        IIF(siet.endtime > endtime, endtime, siet.endtime),
                        IIF(siet.actualendtime > endtime, endtime, siet.actualendtime))
                )) AS duration,
                SUM(IIF(siet.isovertime = 1, DATEDIFF(SECOND,
                    IIF(siet.actualstarttime < siet.starttime, siet.starttime, siet.actualstarttime),
                    IIF(siet.endtime < siet.actualendtime,
                        IIF(siet.endtime > endtime, endtime, siet.endtime),
                        IIF(siet.actualendtime > endtime, endtime, siet.actualendtime))
                ), 0)) AS overtimeduration
            FROM
                (SELECT
                    shi.actualstarttime,
                    shi.actualendtime,
                    shi.modeluid,
                    joett.productionblockuid,
                    shi.isovertime,
                    joett.starttime AS starttime,
                    joett.endtime AS endtime
                FROM
                    shiftinstance AS shi
                    CROSS APPLY(
                        SELECT 
                            modeluid,
                            productionblockuid,
                            starttime,
                            endtime
                        FROM @jobOrderExecutionTimeTable
                        WHERE shi.actualendtime > starttime AND shi.actualstarttime < endtime
                    ) AS joett
                WHERE
                    shi.modeluid = joett.modeluid AND
                    (joett.starttime < shi.actualendtime AND shi.actualstarttime < joett.endtime)
                ) AS siet
            INNER JOIN @runningHoursTable rh ON rh.productionblockuid = siet.productionblockuid
                                             AND rh.modeluid = siet.modeluid
            GROUP BY
                siet.modeluid,
                siet.productionblockuid

        INSERT INTO @result
            SELECT
                rh.productionblockuid,
                rh.modeluid,
                SUM(rh.duration - COALESCE(pp.duration, 0)) AS duration,
                SUM(COALESCE(pp.overtimeduration, 0)) AS overtimeduration
            FROM @runningHoursTable rh
                LEFT JOIN @plannedProductionTable pp ON rh.productionblockuid = pp.productionblockuid
                                                     AND rh.modeluid = pp.modeluid
            GROUP BY rh.modeluid, rh.productionblockuid
    END
RETURN END]]></sql><timeout>60.0</timeout></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="GetScorecardGroupedSummaryInfos"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[if (logger.debugEnabled) {
	logger.debug("Entering {}:GetScorecardGroupedSummaryInfos with parameter modelUids:{} metricName:{} startDateTime:{} endDateTime:{} timeRatio:{}",
		me.name, modelUids.ToJSON(), metricName, startDateTime.toString(), endDateTime.toString(), timeRatio);
}

try {
	var result = DataShapes["PTC.KPIAnalysis.ScorecardSummaryInfo"].CreateValues();

	let requiredQueries = getScorecardRequiredQueries(metricName);

	let timePeriods = getTimePeriods(startDateTime, endDateTime);

	let eventDurations = {};
	if (requiredQueries.hasOwnProperty('GetProductionEventDurations')) {
		eventDurations = getProductionEventDurationPeriods(modelUids, timePeriods);
	}
	let scheduledAndCompletedJobOrders = {};
	if (requiredQueries.hasOwnProperty('GetScheduledAndCompletedJobOrders')) {
		scheduledAndCompletedJobOrders = getScheduledAndCompletedJobOrders(modelUids, timePeriods);
	}
	let shiftDurations = {};
	if (requiredQueries.hasOwnProperty('GetShiftDurations')) {
		shiftDurations = getShiftDurationPeriods(modelUids, timePeriods);
	}
	let totalTimes = {};
	if (requiredQueries.hasOwnProperty('GetTotalTimes')) {
		totalTimes = getTotalTimes(modelUids, timePeriods);
	}
	let unplannedProductionDurations = {};
	if (requiredQueries.hasOwnProperty('GetUnplannedProductionDurations')) {
		unplannedProductionDurations = getUnplannedProductionDurationPeriods(modelUids, timePeriods);
	}

	let modelUidArray = modelUids.rows.toArray();

	for (let i = 0; i < modelUidArray.length; ++i) {
		let modelUid = modelUidArray[i].item;

		let calculatedMetrics = calculateMetrics(modelUid, timePeriods, totalTimes, eventDurations, shiftDurations, unplannedProductionDurations, scheduledAndCompletedJobOrders);

		var scorecardSummaryPeriod = calculatedMetrics[timePeriods[0].id];
		var scorecardBasePeriod = calculatedMetrics[timePeriods[1].id];
		var scorecardChangePeriod = calculatedMetrics[timePeriods[2].id];

		result.AddRow({
			modelUid: modelUid,
			metricName: metricName,
			actual: scorecardSummaryPeriod[metricName],
			percentageChange: getPercentageChange(scorecardBasePeriod[metricName], scorecardChangePeriod[metricName])
		});
	}
} catch (err) {
	logger.error("{} - {}:{} - {}", me.name, err.fileName, err.lineNumber, err);
	throw err;
}
if (logger.debugEnabled) {
	logger.debug("Exiting {}:GetScorecardGroupedSummaryInfos", me.name);
}

function getPercentageChange(prev, curr) {
	if (!prev) {
		return undefined;
	}
	return 100 * (curr - prev) / prev;
}

function calculateMetrics(modelUid, timePeriods, totalTimes, eventDurations, shiftDurations, unplannedProductionDurations, scheduledAndCompletedJobOrders) {
	let result = {};

	for (let i = 0; i < timePeriods.length; ++i) {
		let timePeriod = timePeriods[i];
		let timePeriodId = timePeriod.id;

		let totalTime = getTotalTime(totalTimes, modelUid, timePeriodId);
		let productionTime = getTotalDuration(eventDurations, modelUid, timePeriodId, 'Production');
		let productionQuantity = getTotalQuantity(eventDurations, modelUid, timePeriodId, 'Production');
		let scrapQuantity = getTotalQuantity(eventDurations, modelUid, timePeriodId, 'Scrap');
		let [unplannedProductionTime, overtimeProduction] = getTotalUnplannedProductionTime(unplannedProductionDurations, modelUid, timePeriodId);
		let regularShiftDuration = getTotalRegularShiftDuration(shiftDurations, modelUid, timePeriodId);
		let overtimeShiftDuration = getTotalOvertimeShiftDuration(shiftDurations, modelUid, timePeriodId);
		let jobsCompleted = getCompletedJobOrders(scheduledAndCompletedJobOrders, modelUid, timePeriodId);
		let jobsScheduled = getScheduledJobOrders(scheduledAndCompletedJobOrders, modelUid, timePeriodId);
        
		let overtime = unplannedProductionTime + overtimeShiftDuration;
		let plannedProductionTime = regularShiftDuration;
		let totalEffectiveTime = productionTime;
		let totalLossHours = (plannedProductionTime + overtime) - totalEffectiveTime;
		let totalProductionTime = plannedProductionTime + unplannedProductionTime + overtimeProduction;
		let averageThroughput = totalProductionTime == 0 ? 0 : productionQuantity / totalProductionTime;
		let scrapRate = (productionQuantity + scrapQuantity) == 0 ? 0 : scrapQuantity / (productionQuantity + scrapQuantity);
		let productionOEE = totalProductionTime > 0 ? 100 * totalEffectiveTime / totalProductionTime : 0;
		let totalAvailableOEE = totalTime > 0 ? 100 * totalEffectiveTime / totalTime : 0;
		
		result[timePeriodId] = {
			'Jobs Completed': jobsCompleted,
			'Jobs Scheduled': jobsScheduled,
			'Overtime': overtime / timeRatio,
			'Planned Production Time': plannedProductionTime / timeRatio,
			'Production OEE': productionOEE,
			'Production Quantity': productionQuantity,
			'Scrap Rate': scrapRate * 100,
			'Average Throughput': averageThroughput * timeRatio,
			'Total Available OEE': totalAvailableOEE,
			'Total Effective Time': totalEffectiveTime / timeRatio,
			'Total Loss Hours': totalLossHours / timeRatio,
			'Total Production Time': totalProductionTime / timeRatio
		};
        
        result[timePeriodId] = me.AddCustomMetricsToResult({
            json: result[timePeriodId] /* JSON */,
            startDate: timePeriod.startDateTime /* DATETIME */,
            totalTimeDuration: totalProductionTime /* NUMBER */,
            endDate: timePeriod.endDateTime /* DATETIME */,
            modelUid: modelUid /* STRING */,
            GoodCount: productionQuantity /* NUMBER */,
            ScrapCount: scrapQuantity /* NUMBER */
        });

	}

	return result;
}

function getTotalTime(allTotalTimes, modelUid, timePeriodId) {
	let totalTimesByPeriod = allTotalTimes[modelUid];
	if (totalTimesByPeriod == undefined || totalTimesByPeriod == null) {
		return 0;
	}
	let totalTime = totalTimesByPeriod[timePeriodId];
	if (totalTime == undefined || totalTime == null) {
		return 0;
	}
	return totalTime;
}

function getTotalDuration(allEventDurations, modelUid, timePeriodId, eventTypeName) {
	let eventDurationsByPeriod = allEventDurations[modelUid];
	if (eventDurationsByPeriod == undefined || eventDurationsByPeriod == null) {
		return 0;
	}
	let eventDurations = eventDurationsByPeriod[timePeriodId];
	if (eventDurations == undefined || eventDurations == null) {
		return 0;
	}
	return eventDurations.filter(r => r.eventtypename === eventTypeName).reduce((sum, e) => sum + e.duration, 0);
}

function getTotalQuantity(allEventDurations, modelUid, timePeriodId, eventTypeName) {
	let eventDurationsByPeriod = allEventDurations[modelUid];
	if (eventDurationsByPeriod == undefined || eventDurationsByPeriod == null) {
		return 0;
	}
	let eventDurations = eventDurationsByPeriod[timePeriodId];
	if (eventDurations == undefined || eventDurations == null) {
		return 0;
	}
	return eventDurations.filter(r => r.eventtypename === eventTypeName).reduce((sum, e) => sum + e.quantity, 0);
}

function getTotalUnplannedProductionTime(allUnplannedProductionDurations, modelUid, timePeriodId) {
	let unplannedProductionDurationsByPeriod = allUnplannedProductionDurations[modelUid];
	if (unplannedProductionDurationsByPeriod == undefined || unplannedProductionDurationsByPeriod == null) {
		return 0;
	}
	let unplannedProductionDurations = unplannedProductionDurationsByPeriod[timePeriodId];
	if (unplannedProductionDurations == undefined || unplannedProductionDurations == null) {
		return 0;
	}

	let duration = unplannedProductionDurations.reduce((sum, e) => sum + e.duration, 0);
	let overtimeDuration = unplannedProductionDurations.reduce((sum, e) => sum + e.overtimeduration, 0);

	return [duration, overtimeDuration];
}

function getTotalRegularShiftDuration(allShiftDurations, modelUid, timePeriodId) {
	let shiftDurationsByPeriod = allShiftDurations[modelUid];
	if (shiftDurationsByPeriod == undefined || shiftDurationsByPeriod == null) {
		return 0;
	}
	let shiftDurations = shiftDurationsByPeriod[timePeriodId];
	if (shiftDurations == undefined || shiftDurations == null) {
		return 0;
	}
	return shiftDurations.reduce((sum, e) => sum + e.regularshiftduration, 0);
}

function getTotalOvertimeShiftDuration(allShiftDurations, modelUid, timePeriodId) {
	let shiftDurationsByPeriod = allShiftDurations[modelUid];
	if (shiftDurationsByPeriod == undefined || shiftDurationsByPeriod == null) {
		return 0;
	}
	let shiftDurations = shiftDurationsByPeriod[timePeriodId];
	if (shiftDurations == undefined || shiftDurations == null) {
		return 0;
	}
	return shiftDurations.reduce((sum, e) => sum + e.overtimeshiftduration, 0);
}

function getCompletedJobOrders(allScheduledAndCompletedJobOrders, modelUid, timePeriodId) {
	let scheduledAndCompletedJobOrdersByPeriod = allScheduledAndCompletedJobOrders[modelUid];
	if (scheduledAndCompletedJobOrdersByPeriod == undefined || scheduledAndCompletedJobOrdersByPeriod == null) {
		return 0;
	}
	let scheduledAndCompletedJobOrders = scheduledAndCompletedJobOrdersByPeriod[timePeriodId];
	if (scheduledAndCompletedJobOrders == undefined || scheduledAndCompletedJobOrders == null) {
		return 0;
	}
	return scheduledAndCompletedJobOrders.reduce((sum, e) => sum + e.completedjoborders, 0);
}

function getScheduledJobOrders(allScheduledAndCompletedJobOrders, modelUid, timePeriodId) {
	let scheduledAndCompletedJobOrdersByPeriod = allScheduledAndCompletedJobOrders[modelUid];
	if (scheduledAndCompletedJobOrdersByPeriod == undefined || scheduledAndCompletedJobOrdersByPeriod == null) {
		return 0;
	}
	let scheduledAndCompletedJobOrders = scheduledAndCompletedJobOrdersByPeriod[timePeriodId];
	if (scheduledAndCompletedJobOrders == undefined || scheduledAndCompletedJobOrders == null) {
		return 0;
	}
	return scheduledAndCompletedJobOrders.reduce((sum, e) => sum + e.scheduledjoborders, 0);
}

// startDateTime is inclusive, always consider startDateTime <= event-date
// endDateTime is exclusive, always consider event-date < endDateTime
// if UI has TO: 2022-02-28,
// ... then Scorecard UI receives endDate: 2022-02-28 23:59:59.999
// ... and then adds 1millis
// ... then GetScorecardSummaryInfos receives endDateTime: 2022-03-01 00:00:00.000
function getTimePeriods(startDateTime, endDateTime) {
	var timePeriods = [];

	var previousWeekStartDateTime = dateAddDays(startDateTime, -6);
	var previousWeekEndDateTime = dateAddDays(startDateTime, 1);
	var currentWeekStartDateTime = dateAddDays(endDateTime, -7);
	var currentWeekEndDateTime = endDateTime;

	// account for endDate being truncated to now()
	previousWeekStartDateTime = min(previousWeekStartDateTime, currentWeekStartDateTime);
	previousWeekEndDateTime = min(previousWeekEndDateTime, currentWeekEndDateTime);

	timePeriods.push({
		id: 1,
		startDateTime: startDateTime,
		endDateTime: endDateTime
	});
	timePeriods.push({
		id: 2,
		startDateTime: previousWeekStartDateTime,
		endDateTime: previousWeekEndDateTime,
	});
	timePeriods.push({
		id: 3,
		startDateTime: currentWeekStartDateTime,
		endDateTime: currentWeekEndDateTime
	});
	return timePeriods;
}

function getTotalTimes(modelUids, timePeriods) {
	let totalTimesByModelByPeriod = {};
	modelUids.getRows().toArray().forEach(row => {
		let modelUid = row.item;
		let totalTimesByPeriod = {};
		totalTimesByModelByPeriod[modelUid] = totalTimesByPeriod;
		let workcenterCount = getWorkcentersCount(modelUid) || 1;
		for (let i = 0; i < timePeriods.length; ++i) {
			let timePeriod = timePeriods[i];
			let timeRangeInSeconds = (timePeriod.endDateTime - timePeriod.startDateTime) / 1000;
			totalTimesByPeriod[timePeriod.id] = Math.round(workcenterCount * timeRangeInSeconds);
		}
	});
	return totalTimesByModelByPeriod;
}

function getWorkcentersCount(modelUid) {
	let treeModels = me.GetTreeModels({
		modelUid: modelUid,
		onlyPacemaker: false
	});

	return treeModels.rows.toArray().filter(r => r.childtype === 'Workcenter').length;
}

function getProductionEventDurationPeriods(modelUids, timePeriods) {
	let modelUidsCSV = getModelUidsAsCommaSeparatedString(modelUids);
	let allRows = me.GetProductionEventDurationPeriods({
		modelUids: modelUidsCSV,
		timePeriods: JSON.stringify(timePeriods)
	});
	let eventDurationsByModelByPeriod = getEmptyArraysByModelByPeriod(modelUids, timePeriods);
	allRows.rows.toArray().forEach(row => {
		// modeluid, timeperiodid, eventtyname, ..., duration, quantity
		eventDurationsByModelByPeriod[row.modeluid][row.timeperiodid].push(row);
	});
	return eventDurationsByModelByPeriod;
}

function getUnplannedProductionDurationPeriods(modelUids, timePeriods) {
	let modelUidsCSV = getModelUidsAsCommaSeparatedString(modelUids);
	let allRows = me.GetUnplannedProductionDurationPeriods({
		modelUids: modelUidsCSV,
		timePeriods: JSON.stringify(timePeriods)
	});

	let unplannedProductionDurationsByModelByPeriod = getEmptyArraysByModelByPeriod(modelUids, timePeriods);
	allRows.rows.toArray().forEach(row => {
		// modeluid, timeperiodid, duration
		unplannedProductionDurationsByModelByPeriod[row.modeluid][row.timeperiodid].push(row);
	});
	return unplannedProductionDurationsByModelByPeriod;
}

function getShiftDurationPeriods(modelUids, timePeriods) {
	let modelUidsCSV = getModelUidsAsCommaSeparatedString(modelUids);
	let allRows = me.GetShiftDurationPeriods({
		modelUids: modelUidsCSV,
		timePeriods: JSON.stringify(timePeriods)
	});
	let shiftDurationsByModelByPeriod = getEmptyArraysByModelByPeriod(modelUids, timePeriods);
	allRows.rows.toArray().forEach(row => {
		// modeluid, timeperiodid, regularshiftduration, overtimeshiftduration
		shiftDurationsByModelByPeriod[row.modeluid][row.timeperiodid].push(row);
	});
	return shiftDurationsByModelByPeriod;
}

function getScheduledAndCompletedJobOrders(modelUids, timePeriods) {
	let modelUidsCSV = getModelUidsAsCommaSeparatedString(modelUids);
	let allRows = me.GetScheduledAndCompletedJobOrders({
		modelUids: modelUidsCSV,
		timePeriods: JSON.stringify(timePeriods)
	});
	let scheduledAndCompletedJobOrdersByModelByPeriod = getEmptyArraysByModelByPeriod(modelUids, timePeriods);
	allRows.rows.toArray().forEach(row => {
		// modeluid, timeperiodid, scheduledjoborders, completedjoborders
		scheduledAndCompletedJobOrdersByModelByPeriod[row.modeluid][row.timeperiodid].push(row);
	});
	return scheduledAndCompletedJobOrdersByModelByPeriod;
}

function getScorecardRequiredQueries(metricName) {
	var metricNames = DataShapes["GenericStringList"].CreateValues();
	metricNames.AddRow({
		item: metricName
	});
	let queries = me.GetScorecardRequiredQueries({
		metricNames: metricNames
	});

	let result = {};
	queries.rows.toArray().forEach(row => {
		result[row.item] = row.item;
	});
	return result;
}

function getEmptyArraysByModelByPeriod(modelUids, timePeriods) {
	let emptyArraysByModelByPeriod = {};
	modelUids.getRows().toArray().forEach(row => {
		let modelUid = row.item;
		let emptyArraysByPeriod = {};
		emptyArraysByModelByPeriod[modelUid] = emptyArraysByPeriod;
		for (let i = 0; i < timePeriods.length; ++i) {
			let timePeriod = timePeriods[i];
			emptyArraysByPeriod[timePeriod.id] = [];
		}
	});
	return emptyArraysByModelByPeriod;
}

function getModelUidsAsCommaSeparatedString(modelUids) {
	var csv = '';
	modelUids.getRows().toArray().forEach(row => {
		csv += row.item + ',';
	});
	return csv;
}

function min(date1, date2) {
	return date1 < date2 ? date1 : date2;
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="GetScorecardRequiredQueries"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[if (logger.debugEnabled) {
	logger.debug("Entering {}:GetScorecardRequiredQueries with parameter metricNames:{}", me.name, metricNames.ToJSON());
}

let result;

var queries = {};
try {
	metricNames.rows.toArray().forEach((row) => {
		let metricName = row.item;
        queries['GetUnplannedProductionDurations'] = 'GetUnplannedProductionDurations';
		switch (metricName) {
			case 'Jobs Completed':
				queries['GetScheduledAndCompletedJobOrders'] = 'GetScheduledAndCompletedJobOrders';
				break;
			case 'Jobs Scheduled':
				queries['GetScheduledAndCompletedJobOrders'] = 'GetScheduledAndCompletedJobOrders';
				break;
			case 'Overtime':
				queries['GetShiftDurations'] = 'GetShiftDurations';
				queries['GetUnplannedProductionDurations'] = 'GetUnplannedProductionDurations';
				break;
			case 'Planned Production Time':
				queries['GetShiftDurations'] = 'GetShiftDurations';
				break;
			case 'Production OEE':
				queries['GetProductionEventDurations'] = 'GetProductionEventDurations';
				queries['GetShiftDurations'] = 'GetShiftDurations';
				queries['GetUnplannedProductionDurations'] = 'GetUnplannedProductionDurations';
				break;
			case 'Production Quantity':
				queries['GetProductionEventDurations'] = 'GetProductionEventDurations';
				break;
			case 'Scrap Rate':
				queries['GetProductionEventDurations'] = 'GetProductionEventDurations';
				break;
			case 'Average Throughput':
				queries['GetProductionEventDurations'] = 'GetProductionEventDurations';
				queries['GetShiftDurations'] = 'GetShiftDurations';
				queries['GetUnplannedProductionDurations'] = 'GetUnplannedProductionDurations';
				break;
			case 'Total Available OEE':
				queries['GetProductionEventDurations'] = 'GetProductionEventDurations';
				queries['GetShiftDurations'] = 'GetShiftDurations';
				queries['GetUnplannedProductionDurations'] = 'GetUnplannedProductionDurations';
				queries['GetTotalTimes'] = 'GetTotalTimes';
				break;
			case 'Total Effective Time':
				queries['GetProductionEventDurations'] = 'GetProductionEventDurations';
				queries['GetShiftDurations'] = 'GetShiftDurations';
				queries['GetUnplannedProductionDurations'] = 'GetUnplannedProductionDurations';
				break;
			case 'Total Loss Hours':
				queries['GetProductionEventDurations'] = 'GetProductionEventDurations';
				queries['GetShiftDurations'] = 'GetShiftDurations';
				queries['GetUnplannedProductionDurations'] = 'GetUnplannedProductionDurations';
				break;
			case 'Total Production Time':
				queries['GetShiftDurations'] = 'GetShiftDurations';
				queries['GetUnplannedProductionDurations'] = 'GetUnplannedProductionDurations';
				break;
           	case 'Planned Downtime':
				queries['GetShiftDurations'] = 'GetShiftDurations';
				queries['GetUnplannedProductionDurations'] = 'GetUnplannedProductionDurations';
				break;
            case 'Unplanned Downtime':
				queries['GetShiftDurations'] = 'GetShiftDurations';
				queries['GetUnplannedProductionDurations'] = 'GetUnplannedProductionDurations';
				break;
            case 'Changeover':
				queries['GetShiftDurations'] = 'GetShiftDurations';
				queries['GetUnplannedProductionDurations'] = 'GetUnplannedProductionDurations';
				break;
            case 'Speed Loss':
				queries['GetShiftDurations'] = 'GetShiftDurations';
				queries['GetUnplannedProductionDurations'] = 'GetUnplannedProductionDurations';
				break;
            case 'Availability':
                queries['GetProductionEventDurations'] = 'GetProductionEventDurations';
				queries['GetShiftDurations'] = 'GetShiftDurations';
				queries['GetUnplannedProductionDurations'] = 'GetUnplannedProductionDurations';
				queries['GetTotalTimes'] = 'GetTotalTimes';
                break;
            case 'Performance':
                queries['GetProductionEventDurations'] = 'GetProductionEventDurations';
				queries['GetShiftDurations'] = 'GetShiftDurations';
				queries['GetUnplannedProductionDurations'] = 'GetUnplannedProductionDurations';
				queries['GetTotalTimes'] = 'GetTotalTimes';
                break;
            case 'Quality':
                queries['GetProductionEventDurations'] = 'GetProductionEventDurations';
				queries['GetShiftDurations'] = 'GetShiftDurations';
				queries['GetUnplannedProductionDurations'] = 'GetUnplannedProductionDurations';
				queries['GetTotalTimes'] = 'GetTotalTimes';
                break;
		}
	});

	result = DataShapes["GenericStringList"].CreateValues();
	Object.keys(queries).forEach((key, index) => {
		result.AddRow({item: key});
	});
} catch (err) {
	logger.error("{} - {}:{} - {}", me.name, err.fileName, err.lineNumber, err);
	throw err;
}
if (logger.debugEnabled) {
	logger.debug("Exiting {}:GetScorecardRequiredQueries", me.name);
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="GetScorecardSummaryInfos"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[if (logger.debugEnabled) {
	logger.debug("Entering {}:GetScorecardSummaryInfos with parameter modelUid:{} metricNames:{} startDateTime:{} endDateTime:{} timeRatio:{}",
		me.name, modelUid, metricNames.ToJSON(), startDateTime.toString(), endDateTime.toString(), timeRatio);
}

try {
	var result = DataShapes["PTC.KPIAnalysis.ScorecardSummaryInfo"].CreateValues();

	let metricNamesSet = {};
	metricNames.rows.toArray().forEach((row) => {
		metricNamesSet[row.item] = row.item;
	});

	let requiredQueries = getScorecardRequiredQueries(metricNames);

	let timePeriods = getTimePeriods(startDateTime, endDateTime);

	let eventDurations = {};
	if (requiredQueries.hasOwnProperty('GetProductionEventDurations')) {
		eventDurations = getProductionEventDurationPeriods(modelUid, timePeriods);
	}
	let scheduledAndCompletedJobOrders = {};
	if (requiredQueries.hasOwnProperty('GetScheduledAndCompletedJobOrders')) {
		scheduledAndCompletedJobOrders = getScheduledAndCompletedJobOrders(modelUid, timePeriods);
	}
	let shiftDurations = {};
	if (requiredQueries.hasOwnProperty('GetShiftDurations')) {
		shiftDurations = getShiftDurationPeriods(modelUid, timePeriods);
	}
	let totalTimes = {};
	if (requiredQueries.hasOwnProperty('GetTotalTimes')) {
		totalTimes = getTotalTimes(modelUid, timePeriods);
	}
	let unplannedProductionDurations = {};
	if (requiredQueries.hasOwnProperty('GetUnplannedProductionDurations')) {
		unplannedProductionDurations = getUnplannedProductionDurationPeriods(modelUid, timePeriods);
	}

	let calculatedMetrics = calculateMetrics(timePeriods, totalTimes, eventDurations, shiftDurations, unplannedProductionDurations, scheduledAndCompletedJobOrders);

	var scorecardSummaryPeriod = calculatedMetrics[timePeriods[0].id];
	var scorecardBasePeriod = calculatedMetrics[timePeriods[1].id];
	var scorecardChangePeriod = calculatedMetrics[timePeriods[2].id];

	for (var metricName in metricNamesSet) {
		if (metricNamesSet.hasOwnProperty(metricName)) {
			result.AddRow({
				modelUid: modelUid,
				metricName: metricName,
				actual: scorecardSummaryPeriod[metricName],
				percentageChange: getPercentageChange(scorecardBasePeriod[metricName], scorecardChangePeriod[metricName])
			});
		}
	}
} catch (err) {
	logger.error("{} - {}:{} - {}", me.name, err.fileName, err.lineNumber, err);
	throw err;
}
if (logger.debugEnabled) {
	logger.debug("Exiting {}:GetScorecardSummaryInfos", me.name);
}

function getPercentageChange(prev, curr) {
	if (!prev) {
		return undefined;
	}
	return 100 * (curr - prev) / prev;
}

function calculateMetrics(timePeriods, totalTimes, eventDurations, shiftDurations, unplannedProductionDurations, scheduledAndCompletedJobOrders) {
	let result = {};

	for (let i = 0; i < timePeriods.length; ++i) {
		let timePeriod = timePeriods[i];
		let timePeriodId = timePeriod.id;

		let totalTime = getTotalTime(totalTimes, timePeriodId);
		let productionTime = getTotalDuration(eventDurations, timePeriodId, 'Production');
		let productionQuantity = getTotalQuantity(eventDurations, timePeriodId, 'Production');
		let scrapQuantity = getTotalQuantity(eventDurations, timePeriodId, 'Scrap');
		let [unplannedProductionTime, overtimeProduction] = getTotalUnplannedProductionTime(unplannedProductionDurations, timePeriodId);
		let regularShiftDuration = getTotalRegularShiftDuration(shiftDurations, timePeriodId);
		let overtimeShiftDuration = getTotalOvertimeShiftDuration(shiftDurations, timePeriodId);
		let jobsCompleted = getCompletedJobOrders(scheduledAndCompletedJobOrders, timePeriodId);
		let jobsScheduled = getScheduledJobOrders(scheduledAndCompletedJobOrders, timePeriodId);

		let overtime = unplannedProductionTime + overtimeShiftDuration;
		let plannedProductionTime = regularShiftDuration;
		let totalEffectiveTime = productionTime;
		let totalLossHours = (plannedProductionTime + overtime) - totalEffectiveTime;
		let totalProductionTime = plannedProductionTime + unplannedProductionTime + overtimeProduction;
		let averageThroughput = totalProductionTime == 0 ? 0 : productionQuantity / totalProductionTime;
		let scrapRate = (productionQuantity + scrapQuantity) == 0 ? 0 : scrapQuantity / (productionQuantity + scrapQuantity);
		let productionOEE = totalProductionTime > 0 ? 100 * totalEffectiveTime / totalProductionTime : 0;
		let totalAvailableOEE = totalTime > 0 ? 100 * totalEffectiveTime / totalTime : 0;

		result[timePeriodId] = {
			'Jobs Completed': jobsCompleted,
			'Jobs Scheduled': jobsScheduled,
			'Overtime': overtime / timeRatio,
			'Planned Production Time': plannedProductionTime / timeRatio,
			'Production OEE': productionOEE,
			'Production Quantity': productionQuantity,
			'Scrap Rate': scrapRate * 100,
			'Average Throughput': averageThroughput * timeRatio,
			'Total Available OEE': totalAvailableOEE,
			'Total Effective Time': totalEffectiveTime / timeRatio,
			'Total Loss Hours': totalLossHours / timeRatio,
			'Total Production Time': totalProductionTime / timeRatio
		};
        
        result[timePeriodId] = me.AddCustomMetricsToResult({
            json: result[timePeriodId] /* JSON */,
            startDate: timePeriod.startDateTime /* DATETIME */,
            totalTimeDuration: totalProductionTime /* NUMBER */,
            endDate: timePeriod.endDateTime /* DATETIME */,
            modelUid: modelUid /* STRING */,
            GoodCount: productionQuantity /* NUMBER */,
            ScrapCount: scrapQuantity /* NUMBER */
        });
	}

	return result;
}

function getTotalTimes(modelUid, timePeriods) {
	let workcenterCount = getWorkcentersCount(modelUid) || 1;
	let totalTimes = {};
	for (let i = 0; i < timePeriods.length; ++i) {
		let timePeriod = timePeriods[i];
		let timeRangeInSeconds = (timePeriod.endDateTime - timePeriod.startDateTime) / 1000;
		totalTimes[timePeriod.id] = Math.round(workcenterCount * timeRangeInSeconds);
	}
	return totalTimes;
}

function getWorkcentersCount(modelUid) {
	let treeModels = me.GetTreeModels({
		modelUid: modelUid,
		onlyPacemaker: false
	});

	return treeModels.rows.toArray()
		.filter(r => r.childtype === 'Workcenter').length;
}

function getTotalTime(alltotalTimes, timePeriodId) {
	let totalTime = alltotalTimes[timePeriodId];
	if (totalTime == undefined || totalTime == null) {
		return 0;
	}
	return totalTime;
}

function getTotalDuration(allEventDurations, timePeriodId, eventTypeName) {
	let eventDurations = allEventDurations[timePeriodId];
	if (eventDurations) {
		return eventDurations.filter(r => r.eventtypename === eventTypeName)
			.reduce((sum, e) => sum + e.duration, 0);
	}
	return 0;
}

function getTotalQuantity(allEventDurations, timePeriodId, eventTypeName) {
	let eventDurations = allEventDurations[timePeriodId];
	if (eventDurations) {
		return eventDurations.filter(r => r.eventtypename === eventTypeName)
			.reduce((sum, e) => sum + e.quantity, 0);
	}
	return 0;
}

function getTotalUnplannedProductionTime(allUnplannedProductionDurations, timePeriodId) {
	let unplannedProductionDurations = allUnplannedProductionDurations[timePeriodId];
	if (unplannedProductionDurations) {
		let duration = unplannedProductionDurations.reduce((sum, e) => sum + e.duration, 0);
		let overtimeDuration = unplannedProductionDurations.reduce((sum, e) => sum + e.overtimeduration, 0);

		return [duration, overtimeDuration];
	}
	return [0, 0];
}

function getTotalRegularShiftDuration(allShiftDurations, timePeriodId) {
	let shiftDurations = allShiftDurations[timePeriodId];
	if (shiftDurations) {
		return shiftDurations.reduce((sum, e) => sum + e.regularshiftduration, 0);
	}
	return 0;
}

function getTotalOvertimeShiftDuration(allShiftDurations, timePeriodId) {
	let shiftDurations = allShiftDurations[timePeriodId];
	if (shiftDurations) {
		return shiftDurations.reduce((sum, e) => sum + e.overtimeshiftduration, 0);
	}
	return 0;
}

function getCompletedJobOrders(allScheduledAndCompletedJobOrders, timePeriodId) {
	let scheduledAndCompletedJobOrders = allScheduledAndCompletedJobOrders[timePeriodId];
	if (scheduledAndCompletedJobOrders) {
		return scheduledAndCompletedJobOrders.reduce((sum, e) => sum + e.completedjoborders, 0);
	}
	return 0;
}

function getScheduledJobOrders(allScheduledAndCompletedJobOrders, timePeriodId) {
	let scheduledAndCompletedJobOrders = allScheduledAndCompletedJobOrders[timePeriodId];
	if (scheduledAndCompletedJobOrders) {
		return scheduledAndCompletedJobOrders.reduce((sum, e) => sum + e.scheduledjoborders, 0);
	}
	return 0;
}

// startDateTime is inclusive, always consider startDateTime <= event-date
// endDateTime is exclusive, always consider event-date < endDateTime
// also, if UI has TO: 2022-02-28,
// ... then Scorecard UI receives endDate: 2022-02-28 23:59:59.999
// ... but GetScorecardSummaryInfos receives endDateTime: 2022-03-01 00:00:00.000
function getTimePeriods(startDateTime, endDateTime) {
	var timePeriods = [];

	var previousWeekStartDateTime = dateAddDays(startDateTime, -6);
	var previousWeekEndDateTime = dateAddDays(startDateTime, 1);
	var currentWeekStartDateTime = dateAddDays(endDateTime, -7);
	var currentWeekEndDateTime = endDateTime;

	// account for endDate being truncated to now()
	previousWeekStartDateTime = min(previousWeekStartDateTime, currentWeekStartDateTime);
	previousWeekEndDateTime = min(previousWeekEndDateTime, currentWeekEndDateTime);

	timePeriods.push({
		id: 1,
		startDateTime: startDateTime,
		endDateTime: endDateTime
	});
	timePeriods.push({
		id: 2,
		startDateTime: previousWeekStartDateTime,
		endDateTime: previousWeekEndDateTime,
	});
	timePeriods.push({
		id: 3,
		startDateTime: currentWeekStartDateTime,
		endDateTime: currentWeekEndDateTime
	});
	return timePeriods;
}

function getProductionEventDurationPeriods(modelUid, timePeriods) {
	let eventDurationsByPeriod = getEmptyArraysByPeriod(timePeriods);
	let allRows = me.GetProductionEventDurationPeriods({
		modelUids: modelUid,
		timePeriods: JSON.stringify(timePeriods)
	});
	allRows.rows.toArray().forEach(row => {
		// equipmentuid, timeperiodid, eventtyname, ..., duration, quantity, unknowntime
		eventDurationsByPeriod[row.timeperiodid].push(row);
	});
	return eventDurationsByPeriod;
}

function getUnplannedProductionDurationPeriods(modelUid, timePeriods) {
	let unplannedProductionDurationsByPeriod = getEmptyArraysByPeriod(timePeriods);
	let allRows = me.GetUnplannedProductionDurationPeriods({
		modelUids: modelUid,
		timePeriods: JSON.stringify(timePeriods)
	});
	allRows.rows.toArray().forEach(row => {
		// modeluid, timeperiodid, duration
		unplannedProductionDurationsByPeriod[row.timeperiodid].push(row);
	});
	return unplannedProductionDurationsByPeriod;
}

function getShiftDurationPeriods(modelUid, timePeriods) {
	let shiftDurationsByPeriod = getEmptyArraysByPeriod(timePeriods);
	let allRows = me.GetShiftDurationPeriods({
		modelUids: modelUid,
		timePeriods: JSON.stringify(timePeriods)
	});
	allRows.rows.toArray().forEach(row => {
		// modeluid, timeperiodid, regularshiftduration, overtimeshiftduration
		shiftDurationsByPeriod[row.timeperiodid].push(row);
	});
	return shiftDurationsByPeriod;
}

function getScheduledAndCompletedJobOrders(modelUid, timePeriods) {
	let scheduledAndCompletedJobOrdersByPeriod = getEmptyArraysByPeriod(timePeriods);
	let allRows = me.GetScheduledAndCompletedJobOrders({
		modelUids: modelUid,
		timePeriods: JSON.stringify(timePeriods)
	});
	allRows.rows.toArray().forEach(row => {
		// modeluid, timeperiodid, scheduledjoborders, completedjoborders
		scheduledAndCompletedJobOrdersByPeriod[row.timeperiodid].push(row);
	});
	return scheduledAndCompletedJobOrdersByPeriod;
}

function getEmptyArraysByPeriod(timePeriods) {
	let emptyArraysByPeriod = {};
	for (let i = 0; i < timePeriods.length; ++i) {
		let timePeriod = timePeriods[i];
		emptyArraysByPeriod[timePeriod.id] = [];
	}
	return emptyArraysByPeriod;
}

function getScorecardRequiredQueries(metricNames) {
	let queries = me.GetScorecardRequiredQueries({
		metricNames: metricNames
	});

	let result = {};
	queries.rows.toArray().forEach(row => {
		result[row.item] = row.item;
	});
	return result;
}

function min(date1, date2) {
	return date1 < date2 ? date1 : date2;
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation><ServiceImplementation description="" handlerName="Script" name="GetScorecardTrendInfos"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[if (logger.debugEnabled) {
	logger.debug("Entering {}:GetScorecardTrendInfos with parameter modelUid:{} metricName:{} startDateTime:{} endDateTime:{} timeRatio:{}",
		me.name, modelUid, metricName, startDateTime.toString(), endDateTime.toString(), timeRatio);
}

try {
	var result = DataShapes["PTC.KPIAnalysis.ScorecardTrendInfo"].CreateValues();

	let requiredQueries = getScorecardRequiredQueries(metricName);

	let timePeriods = getTimePeriods(startDateTime, endDateTime);
	let daysPerPeriod = 365;
	let timePeriodsChunks = spliceIntoChunks(timePeriods, daysPerPeriod);

	for (let i = 0; i < timePeriodsChunks.length; ++i) {
		let timePeriods = timePeriodsChunks[i];
		let eventDurations = {};
		if (requiredQueries.hasOwnProperty('GetProductionEventDurations')) {
			eventDurations = getProductionEventDurationPeriods(modelUid, timePeriods);
		}
		let scheduledAndCompletedJobOrders = {};
		if (requiredQueries.hasOwnProperty('GetScheduledAndCompletedJobOrders')) {
			scheduledAndCompletedJobOrders = getScheduledAndCompletedJobOrders(modelUid, timePeriods);
		}
		let shiftDurations = {};
		if (requiredQueries.hasOwnProperty('GetShiftDurations')) {
			shiftDurations = getShiftDurationPeriods(modelUid, timePeriods);
		}
		let totalTimes = {};
		if (requiredQueries.hasOwnProperty('GetTotalTimes')) {
			totalTimes = getTotalTimes(modelUid, timePeriods);
		}
		let unplannedProductionDurations = {};
		if (requiredQueries.hasOwnProperty('GetUnplannedProductionDurations')) {
			unplannedProductionDurations = getUnplannedProductionDurationPeriods(modelUid, timePeriods);
		}

		let calculatedMetrics = calculateMetrics(timePeriods, totalTimes, eventDurations, shiftDurations, unplannedProductionDurations, scheduledAndCompletedJobOrders);
		for (let i = 0; i < timePeriods.length; ++i) {
			let timePeriod = timePeriods[i];
			let timePeriodId = timePeriod.id;
			var calculatedMetric = calculatedMetrics[timePeriodId][metricName];

			var scorecardTrendInfo = {
				modelUid: modelUid,
				metricName: metricName,
				eventDate: timePeriod.startDateTime,
				startDateTime: timePeriod.startDateTime,
				endDateTime: timePeriod.endDateTime,
				actual: calculatedMetric
			};

			result.AddRow(scorecardTrendInfo);
		}
	}

} catch (err) {
	logger.error("{} - {}:{} - {}", me.name, err.fileName, err.lineNumber, err);
	throw err;
}
if (logger.debugEnabled) {
	logger.debug("Exiting {}:GetScorecardTrendInfos", me.name);
}

function calculateMetrics(timePeriods, totalTimes, eventDurations, shiftDurations, unplannedProductionDurations, scheduledAndCompletedJobOrders) {
	let result = {};

	for (let i = 0; i < timePeriods.length; ++i) {
		let timePeriod = timePeriods[i];
		let timePeriodId = timePeriod.id;

		let totalTime = getTotalTime(totalTimes, timePeriodId);
		let productionTime = getTotalDuration(eventDurations, timePeriodId, 'Production');
		let productionQuantity = getTotalQuantity(eventDurations, timePeriodId, 'Production');
		let scrapQuantity = getTotalQuantity(eventDurations, timePeriodId, 'Scrap');
		let [unplannedProductionTime, overtimeProduction] = getTotalUnplannedProductionTime(unplannedProductionDurations, timePeriodId);
		let regularShiftDuration = getTotalRegularShiftDuration(shiftDurations, timePeriodId);
		let overtimeShiftDuration = getTotalOvertimeShiftDuration(shiftDurations, timePeriodId);
		let jobsCompleted = getCompletedJobOrders(scheduledAndCompletedJobOrders, timePeriodId);
		let jobsScheduled = getScheduledJobOrders(scheduledAndCompletedJobOrders, timePeriodId);

		let overtime = unplannedProductionTime + overtimeShiftDuration;
		let plannedProductionTime = regularShiftDuration;
		let totalEffectiveTime = productionTime;
		let totalLossHours = (plannedProductionTime + overtime) - totalEffectiveTime;
		let totalProductionTime = plannedProductionTime + unplannedProductionTime + overtimeProduction;
		let averageThroughput = totalProductionTime == 0 ? 0 : productionQuantity / totalProductionTime;
		let scrapRate = (productionQuantity + scrapQuantity) == 0 ? 0 : scrapQuantity / (productionQuantity + scrapQuantity);
		let productionOEE = totalProductionTime > 0 ? 100 * totalEffectiveTime / totalProductionTime : 0;
		let totalAvailableOEE = totalTime > 0 ? 100 * totalEffectiveTime / totalTime : 0;

		result[timePeriodId] = {
			'Jobs Completed': jobsCompleted,
			'Jobs Scheduled': jobsScheduled,
			'Overtime': overtime / timeRatio,
			'Planned Production Time': plannedProductionTime / timeRatio,
			'Production OEE': productionOEE,
			'Production Quantity': productionQuantity,
			'Scrap Rate': scrapRate * 100,
			'Average Throughput': averageThroughput * timeRatio,
			'Total Available OEE': totalAvailableOEE,
			'Total Effective Time': totalEffectiveTime / timeRatio,
			'Total Loss Hours': totalLossHours / timeRatio,
			'Total Production Time': totalProductionTime / timeRatio
		};
       result[timePeriodId] = me.AddCustomMetricsToResult({
            json: result[timePeriodId] /* JSON */,
            startDate: timePeriod.startDateTime /* DATETIME */,
            totalTimeDuration: totalProductionTime /* NUMBER */,
            endDate: timePeriod.endDateTime /* DATETIME */,
            modelUid: modelUid /* STRING */,
            GoodCount: productionQuantity /* NUMBER */,
            ScrapCount: scrapQuantity /* NUMBER */
        });
	}

	return result;
}

function getTotalTimes(modelUid, timePeriods) {
	let workcenterCount = getWorkcentersCount(modelUid) || 1;
	let totalTimes = {};
	for (let i = 0; i < timePeriods.length; ++i) {
		let timePeriod = timePeriods[i];
		let timeRangeInSeconds = (timePeriod.endDateTime - timePeriod.startDateTime) / 1000;
		totalTimes[timePeriod.id] = Math.round(workcenterCount * timeRangeInSeconds);
	}
	return totalTimes;
}

function getWorkcentersCount(modelUid) {
	let treeModels = me.GetTreeModels({
		modelUid: modelUid,
		onlyPacemaker: false
	});

	return treeModels.rows.toArray()
		.filter(r => r.childtype === 'Workcenter').length;
}

function getTotalTime(alltotalTimes, timePeriodId) {
	let totalTime = alltotalTimes[timePeriodId];
	if (totalTime == undefined || totalTime == null) {
		return 0;
	}
	return totalTime;
}

function getTotalDuration(allEventDurations, timePeriodId, eventTypeName) {
	let eventDurations = allEventDurations[timePeriodId];
	if (eventDurations) {
		return eventDurations.filter(r => r.eventtypename === eventTypeName)
			.reduce((sum, e) => sum + e.duration, 0);
	}
	return 0;
}

function getTotalQuantity(allEventDurations, timePeriodId, eventTypeName) {
	let eventDurations = allEventDurations[timePeriodId];
	if (eventDurations) {
		return eventDurations.filter(r => r.eventtypename === eventTypeName)
			.reduce((sum, e) => sum + e.quantity, 0);
	}
	return 0;
}

function getTotalUnplannedProductionTime(allUnplannedProductionDurations, timePeriodId) {
	let unplannedProductionDurations = allUnplannedProductionDurations[timePeriodId];
	if (unplannedProductionDurations) {
		let duration = unplannedProductionDurations.reduce((sum, e) => sum + e.duration, 0);
		let overtimeDuration = unplannedProductionDurations.reduce((sum, e) => sum + e.overtimeduration, 0);

		return [duration, overtimeDuration];
	}
	return [0, 0];
}

function getTotalRegularShiftDuration(allShiftDurations, timePeriodId) {
	let shiftDurations = allShiftDurations[timePeriodId];
	if (shiftDurations) {
		return shiftDurations.reduce((sum, e) => sum + e.regularshiftduration, 0);
	}
	return 0;
}

function getTotalOvertimeShiftDuration(allShiftDurations, timePeriodId) {
	let shiftDurations = allShiftDurations[timePeriodId];
	if (shiftDurations) {
		return shiftDurations.reduce((sum, e) => sum + e.overtimeshiftduration, 0);
	}
	return 0;
}

function getCompletedJobOrders(allScheduledAndCompletedJobOrders, timePeriodId) {
	let scheduledAndCompletedJobOrders = allScheduledAndCompletedJobOrders[timePeriodId];
	if (scheduledAndCompletedJobOrders) {
		return scheduledAndCompletedJobOrders.reduce((sum, e) => sum + e.completedjoborders, 0);
	}
	return 0;
}

function getScheduledJobOrders(allScheduledAndCompletedJobOrders, timePeriodId) {
	let scheduledAndCompletedJobOrders = allScheduledAndCompletedJobOrders[timePeriodId];
	if (scheduledAndCompletedJobOrders) {
		return scheduledAndCompletedJobOrders.reduce((sum, e) => sum + e.scheduledjoborders, 0);
	}
	return 0;
}

function getTimePeriods(startDateTime, endDateTime) {
	var timePeriods = [];
	var currentStartDateTime = startDateTime;
	var timePeriodId = 1;

	while (dateDifferenceInDays(endDateTime, currentStartDateTime) > 0) {
		nextStartDateTime = dateAddDays(currentStartDateTime, 1);
		if (dateDifferenceInDays(endDateTime, nextStartDateTime) < 0) {
			nextStartDateTime = endDateTime;
		}
		timePeriods.push({
			id: timePeriodId,
			startDateTime: currentStartDateTime,
			endDateTime: nextStartDateTime
		});
		timePeriodId++;
		currentStartDateTime = nextStartDateTime;
	}
	return timePeriods;
}

function getProductionEventDurationPeriods(modelUid, timePeriods) {
	let eventDurationsByPeriod = getEmptyArraysByPeriod(timePeriods);
	let allRows = me.GetProductionEventDurationPeriods({
		modelUids: modelUid,
		timePeriods: JSON.stringify(timePeriods)
	});
	allRows.rows.toArray().forEach(row => {
		// equipmentuid, timeperiodid, eventtyname, ..., duration, quantity, unknowntime
		eventDurationsByPeriod[row.timeperiodid].push(row);
	});
	return eventDurationsByPeriod;
}

function getUnplannedProductionDurationPeriods(modelUid, timePeriods) {
	let unplannedProductionDurationsByPeriod = getEmptyArraysByPeriod(timePeriods);
	let allRows = me.GetUnplannedProductionDurationPeriods({
		modelUids: modelUid,
		timePeriods: JSON.stringify(timePeriods)
	});
	allRows.rows.toArray().forEach(row => {
		// modeluid, timeperiodid, duration
		unplannedProductionDurationsByPeriod[row.timeperiodid].push(row);
	});
	return unplannedProductionDurationsByPeriod;
}

function getShiftDurationPeriods(modelUid, timePeriods) {
	let shiftDurationsByPeriod = getEmptyArraysByPeriod(timePeriods);
	let allRows = me.GetShiftDurationPeriods({
		modelUids: modelUid,
		timePeriods: JSON.stringify(timePeriods)
	});
	allRows.rows.toArray().forEach(row => {
		// modeluid, timeperiodid, regularshiftduration, overtimeshiftduration
		shiftDurationsByPeriod[row.timeperiodid].push(row);
	});
	return shiftDurationsByPeriod;
}

function getScheduledAndCompletedJobOrders(modelUid, timePeriods) {
	let scheduledAndCompletedJobOrdersByPeriod = getEmptyArraysByPeriod(timePeriods);
	let allRows = me.GetScheduledAndCompletedJobOrders({
		modelUids: modelUid,
		timePeriods: JSON.stringify(timePeriods)
	});
	allRows.rows.toArray().forEach(row => {
		// modeluid, timeperiodid, scheduledjoborders, completedjoborders
		scheduledAndCompletedJobOrdersByPeriod[row.timeperiodid].push(row);
	});
	return scheduledAndCompletedJobOrdersByPeriod;
}

function getScorecardRequiredQueries(metricName) {
	var metricNames = DataShapes["GenericStringList"].CreateValues();
	metricNames.AddRow({
		item: metricName
	});
	let queries = me.GetScorecardRequiredQueries({
		metricNames: metricNames
	});

	let result = {};
	queries.rows.toArray().forEach(row => {
		result[row.item] = row.item;
	});
	return result;
}

function getEmptyArraysByPeriod(timePeriods) {
	let emptyArraysByPeriod = {};
	for (let i = 0; i < timePeriods.length; ++i) {
		let timePeriod = timePeriods[i];
		emptyArraysByPeriod[timePeriod.id] = [];
	}
	return emptyArraysByPeriod;
}

function dateDifferenceInDays(endDate, startDate) {
	let difference = dateDifference(endDate, startDate);
	return difference / (1000 * 60 * 60 * 24);
}


function spliceIntoChunks(arr, size) {
	var myArray = [];
	for (var i = 0; i < arr.length; i += size) {
		myArray.push(arr.slice(i, i + size));
	}
	return myArray;

}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation></ServiceImplementations><Subscriptions/></ThingShape><ImplementedShapes/><SharedConfigurationTables/><InstanceDesignTimePermissions><Create/><Read/><Update/><Delete/><Metadata/></InstanceDesignTimePermissions><InstanceRunTimePermissions><Permissions resourceName="AddCustomMetricsToResult"><PropertyRead/><PropertyWrite/><ServiceInvoke><Principal isPermitted="true" name="PTCDTS.KPIAnalysisImpl.Default_UG" type="Group"/></ServiceInvoke><EventInvoke/><EventSubscribe/></Permissions></InstanceRunTimePermissions><InstanceVisibilityPermissions><Visibility/></InstanceVisibilityPermissions><ConfigurationChanges><ConfigurationChange changeAction="CREATE" changeReason="Importing Extension Package Metadata" timestamp="2024-01-23T19:43:02.153Z" user="SuperUser"/><ConfigurationChange changeAction="MODIFY" changeReason="AddVisibilityPermission" timestamp="2024-01-23T19:48:35.951Z" user="Administrator"/><ConfigurationChange changeAction="MODIFY" changeReason="AddVisibilityPermission" timestamp="2024-01-23T19:48:35.954Z" user="Administrator"/></ConfigurationChanges></ThingTemplate><ThingTemplate aspect.isEditableExtensionObject="true" aspect.isExtension="true" aspect.isSystemObject="false" baseThingTemplate="PTC.KPIAnalysisImpl.Manager_TT" description="Custom Impl of KPIAnalysisImpl to add custom metrics" documentationContent="" effectiveThingPackage="ConfiguredThing" homeMashup="" inheritedValueStream="" lastModifiedDate="2024-01-23T19:48:35.941Z" name="PTCDTS.KPIAnalysisImpl.Manager_TT" projectName="PTCDTS.KPIAnalysisImpl" tags="" thingPackage="" valueStream=""><Owner name="SuperUser" type="User"/><avatar/><DesignTimePermissions><Create/><Read/><Update/><Delete/><Metadata/></DesignTimePermissions><RunTimePermissions/><VisibilityPermissions><Visibility><Principal isPermitted="true" name="PTCDTS.KPIAnalysisImpl.Default_OR" type="Organization"/><Principal isPermitted="true" name="PTCDTS.KPIAnalysisImpl.Default_OR:PTCDTS.KPIAnalysisImpl.Admin_UG" type="OrganizationalUnit"/></Visibility></VisibilityPermissions><ConfigurationTableDefinitions/><ConfigurationTables><ConfigurationTable dataShapeName="PTC.KPIAnalysis.AnalysisManagementConfiguration" description="NON-PUBLIC " isMultiRow="false" name="AnalysisManagement" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="true" aspect.thingShape="PTC.KPIAnalysis.AnalysisManagement_TS" baseType="THINGNAME" description="" name="analysisManagement" ordinal="1"/></FieldDefinitions></DataShape><Rows><Row><analysisManagement><![CDATA[PTC.KPIAnalysisImpl.SQLThingUtility]]></analysisManagement></Row></Rows></ConfigurationTable><ConfigurationTable dataShapeName="" description="Configuration table used to identify managers that the building block should use" isMultiRow="true" name="ManagerConfiguration" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="true" baseType="STRING" description="unique identifier for the manager that needs to be configured" name="id" ordinal="1"/><FieldDefinition aspect.isPrimaryKey="false" aspect.thingShape="PTC.Base.CommonManagement_TS" baseType="THINGNAME" description="Name of the Manager Thing to be configured" name="managerThingName" ordinal="2"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable><ConfigurationTable dataShapeName="" description="" isMultiRow="true" name="MashupConfiguration" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="true" baseType="STRING" description="unique identifier used to identify the thing or mashup that is being configured" name="id" ordinal="1"/><FieldDefinition aspect.isPrimaryKey="false" baseType="MASHUPNAME" description="name of the mashup to configure" name="mashupName" ordinal="2"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable><ConfigurationTable dataShapeName="" description="Configuration table for dynamic menus. Menu Items can be specified here and they will show up for the given menu name. " isMultiRow="true" name="MenuConfiguration" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="" name="menuItemMashupName" ordinal="2"/><FieldDefinition aspect.isPrimaryKey="true" baseType="STRING" description="" name="menuName" ordinal="3"/><FieldDefinition aspect.isPrimaryKey="false" baseType="INTEGER" description="An optional field to indicate the ordering of the menu items" name="menuOrderPreference" ordinal="5"/><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="Localization table key for the optional section that groups like menus together" name="menuSectionKey" ordinal="4"/><FieldDefinition aspect.isPrimaryKey="false" baseType="STRING" description="Localization table key for the menu label" name="menuTitleKey" ordinal="1"/><FieldDefinition aspect.dataShape="PTC.Base.ComponentMenuConfiguration" aspect.isPrimaryKey="false" baseType="INFOTABLE" description="" name="submenu" ordinal="6"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable><ConfigurationTable dataShapeName="" description="Configuration table for any Things that need to be configured. This allows for OOTB things to be customized, and the new version that should be used can be configured here" isMultiRow="true" name="ThingConfiguration" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition aspect.isPrimaryKey="true" baseType="STRING" description="unique identifier used to identify the thing or mashup that is being configured" name="id" ordinal="1"/><FieldDefinition aspect.isPrimaryKey="false" baseType="THINGNAME" description="Name of the Thing entity or Mashup entity that is to be configured" name="thingName" ordinal="2"/></FieldDefinitions></DataShape><Rows/></ConfigurationTable></ConfigurationTables><PropertyBindings/><RemotePropertyBindings/><RemoteServiceBindings/><RemoteEventBindings/><AlertConfigurations/><ThingShape><PropertyDefinitions/><ServiceDefinitions/><EventDefinitions/><ServiceMappings/><ServiceImplementations><ServiceImplementation description="" handlerName="Script" name="GetMetrics"><ConfigurationTables><ConfigurationTable dataShapeName="" description="" isMultiRow="false" name="Script" ordinal="0"><DataShape><FieldDefinitions><FieldDefinition baseType="STRING" description="code" name="code" ordinal="0"/></FieldDefinitions></DataShape><Rows><Row><code><![CDATA[const METRIC_DS = "PTC.Metric.Metric";
const METRIC_CORRELATION_DS = "PTC.Metric.MetricCorrelation";
const METRIC_ROLL_UP_DS = "PTC.Metric.MetricRollUp";
const MATERIAL_MASTER_UOM_DS = "PTC.MaterialMaster.UOM";

try {
	const baseCommonHelper = Things[me.GetBaseCommonHelper()];
	const USER_LOCALE = baseCommonHelper.GetCurrentUserLocale();
	var result = Things[me.GetMetricManager()].GetMetrics({
		filter: getFilter()
	});
    result.rows.toArray().forEach(row => {
        if(!row.metric_name_localized){
           row.metric_name_localized = row.metricName;
        }
    });


} catch (err) {
	logger.error("Thing [{}] Service [{}] error at line [{}] : {}", me.name, err.fileName, err.lineNumber, err);
	throw localize("PTC.Base.ErrorMessage");
}

function getFilter() {
	return {
		locale: USER_LOCALE,
		select: [{
				dataShapeName: METRIC_DS,
				fieldName: "uid",
				as: "metricUid"
			}, {
				dataShapeName: METRIC_DS,
				fieldName: "name",
				as: "metricName"
			}, {
				fieldName: "name_Token",
				dataShapeName: METRIC_DS,
				localizedFieldName: "metric_name_localized",
			},
			{
				dataShapeName: METRIC_CORRELATION_DS,
				fieldName: "uid",
				as: "correlationUid"
			}, {
				dataShapeName: METRIC_CORRELATION_DS,
				fieldName: "name",
				as: "correlationName"
			}, {
				dataShapeName: METRIC_ROLL_UP_DS,
				fieldName: "uid",
				as: "rollUpUid"
			}, {
				dataShapeName: METRIC_ROLL_UP_DS,
				fieldName: "name",
				as: "rollUpName"
			}, {
				dataShapeName: MATERIAL_MASTER_UOM_DS,
				fieldName: "uid",
				as: "unitOfMeasureUid"
			}, {
				dataShapeName: MATERIAL_MASTER_UOM_DS,
				fieldName: "abbreviation",
				as: "unitOfMeasureAbbreviation"
			},
			{
				dataShapeName: MATERIAL_MASTER_UOM_DS,
				fieldName: "abbreviation_Token",
				localizedFieldName: "uom_abbreviation_localized",
			},
			{
				dataShapeName: MATERIAL_MASTER_UOM_DS,
				fieldName: "description_Token",
				localizedFieldName: "uom_description_localized",
			}
		],
		joins: [{
			type: "INNER",
			sourceDataShapeName: METRIC_DS,
			sourceFieldName: "metricCorrelation",
			targetDataShapeName: METRIC_CORRELATION_DS,
			targetFieldName: "uid"
		}, {
			type: "INNER",
			sourceDataShapeName: METRIC_DS,
			sourceFieldName: "metricRollUp",
			targetDataShapeName: METRIC_ROLL_UP_DS,
			targetFieldName: "uid"
		}, {
			type: "INNER",
			sourceDataShapeName: METRIC_DS,
			sourceFieldName: "unitOfMeasure",
			targetDataShapeName: MATERIAL_MASTER_UOM_DS,
			targetFieldName: "uid"
		}]
	};
}

function localize(token) {
	return me.LocalizeToken({
		stringToken: token
	});
}]]></code></Row></Rows></ConfigurationTable></ConfigurationTables></ServiceImplementation></ServiceImplementations><Subscriptions/></ThingShape><ImplementedShapes><ImplementedShape name="PTCDTS.KPIAnalysisImpl.Management_TS" type="ThingShape"/></ImplementedShapes><SharedConfigurationTables/><InstanceDesignTimePermissions><Create/><Read/><Update/><Delete/><Metadata/></InstanceDesignTimePermissions><InstanceRunTimePermissions/><InstanceVisibilityPermissions><Visibility/></InstanceVisibilityPermissions><ConfigurationChanges><ConfigurationChange changeAction="CREATE" changeReason="Importing Extension Package Metadata" timestamp="2024-01-23T19:43:02.151Z" user="SuperUser"/><ConfigurationChange changeAction="MODIFY" changeReason="AddVisibilityPermission" timestamp="2024-01-23T19:48:35.938Z" user="Administrator"/><ConfigurationChange changeAction="MODIFY" changeReason="AddVisibilityPermission" timestamp="2024-01-23T19:48:35.942Z" user="Administrator"/></ConfigurationChanges></ThingTemplate></ThingTemplates><ExtensionPackages/><Organizations><Organization aspect.isEditableExtensionObject="true" aspect.isExtension="true" description="" documentationContent="" homeMashup="" lastModifiedDate="2024-01-23T19:48:35.903Z" loginButtonStyle="" loginPrompt="" loginResetPassword="false" loginStyle="" mobileMashup="" name="PTCDTS.KPIAnalysisImpl.Default_OR" projectName="PTCDTS.KPIAnalysisImpl" resetMailContent="&lt;p&gt;[[resetemail.requestmade]]&lt;/p&gt;&lt;p&gt;[[resetemail.instructions]]&lt;/p&gt;&lt;p&gt;[[resetemail.helpneeded]]&lt;/p&gt;" resetMailServer="" resetMailSubject="[[resetemail.subject]]" tags=""><Owner name="SuperUser" type="User"/><avatar/><DesignTimePermissions><Create/><Read/><Update/><Delete/><Metadata/></DesignTimePermissions><RunTimePermissions/><VisibilityPermissions><Visibility><Principal isPermitted="true" name="PTCDTS.KPIAnalysisImpl.Default_OR" type="Organization"/><Principal isPermitted="true" name="PTCDTS.KPIAnalysisImpl.Default_OR:PTCDTS.KPIAnalysisImpl.Admin_UG" type="OrganizationalUnit"/></Visibility></VisibilityPermissions><ConfigurationTableDefinitions/><ConfigurationTables/><loginImage/><Connections><Connection from="" to="Root"/><Connection from="Root" to="PTCDTS.KPIAnalysisImpl.Admin_UG"/><Connection from="Root" to="PTCDTS.KPIAnalysisImpl.Default_UG"/></Connections><OrganizationalUnits><OrganizationalUnit description="" name="PTCDTS.KPIAnalysisImpl.Admin_UG"><Members><Members><Member name="PTCDTS.KPIAnalysisImpl.Admin_UG" type="Group"/></Members></Members></OrganizationalUnit><OrganizationalUnit description="" name="PTCDTS.KPIAnalysisImpl.Default_UG"><Members><Members><Member name="PTCDTS.KPIAnalysisImpl.Default_UG" type="Group"/></Members></Members></OrganizationalUnit><OrganizationalUnit description="" name="Root"><Members><Members/></Members></OrganizationalUnit></OrganizationalUnits><ConfigurationChanges><ConfigurationChange changeAction="CREATE" changeReason="Importing Extension Package Metadata" timestamp="2024-01-23T19:43:02.148Z" user="SuperUser"/><ConfigurationChange changeAction="MODIFY" changeReason="AddVisibilityPermission" timestamp="2024-01-23T19:48:35.901Z" user="Administrator"/><ConfigurationChange changeAction="MODIFY" changeReason="AddVisibilityPermission" timestamp="2024-01-23T19:48:35.904Z" user="Administrator"/></ConfigurationChanges></Organization></Organizations><Menus/><ThingGroups/><Resources/><DataTags/><ThingShapes><ThingShape aspect.isEditableExtensionObject="true" aspect.isExtension="true" aspect.isSystemObject="false" className="" description="Custom Impl of KPIAnalysisImpl to add custom metrics" documentationContent="" homeMashup="" lastModifiedDate="2024-01-23T19:48:35.929Z" name="PTCDTS.KPIAnalysisImpl.Management_TS" projectName="PTCDTS.KPIAnalysisImpl" tags=""><PropertyDefinitions/><ServiceDefinitions/><EventDefinitions/><ServiceMappings/><ServiceImplementations/><Subscriptions/><Owner name="SuperUser" type="User"/><avatar/><DesignTimePermissions><Create/><Read/><Update/><Delete/><Metadata/></DesignTimePermissions><RunTimePermissions/><VisibilityPermissions><Visibility><Principal isPermitted="true" name="PTCDTS.KPIAnalysisImpl.Default_OR" type="Organization"/><Principal isPermitted="true" name="PTCDTS.KPIAnalysisImpl.Default_OR:PTCDTS.KPIAnalysisImpl.Admin_UG" type="OrganizationalUnit"/></Visibility></VisibilityPermissions><ConfigurationTableDefinitions/><ConfigurationTables/><PropertyBindings/><RemotePropertyBindings/><RemoteServiceBindings/><RemoteEventBindings/><AlertConfigurations/><InstanceRunTimePermissions/><ConfigurationChanges><ConfigurationChange changeAction="CREATE" changeReason="Importing Extension Package Metadata" timestamp="2024-01-23T19:43:02.149Z" user="SuperUser"/><ConfigurationChange changeAction="MODIFY" changeReason="AddVisibilityPermission" timestamp="2024-01-23T19:48:35.926Z" user="Administrator"/><ConfigurationChange changeAction="MODIFY" changeReason="AddVisibilityPermission" timestamp="2024-01-23T19:48:35.929Z" user="Administrator"/></ConfigurationChanges></ThingShape></ThingShapes><Subsystems/><NotificationContents/></Entities>